[
  {
    "objectID": "tutorials/tutorial-04.html",
    "href": "tutorials/tutorial-04.html",
    "title": "4: Functional Traits Across Seabed Habitats",
    "section": "",
    "text": "This tutorial is currently under development.\n\n\n\nDemonstrating combined use of emodnet.wfs, emodnet.wcs, and CopernicusMarine packages\nRetrieving and visualising body size traits for benthic species using trait databases\nExploring trait–environment relationships across habitat types\nPractical geospatial workflows including raster extraction and spatial joins\n\n\n\n\n\nEMODnet WFS:\n\neb185_benthos_full_matched: Benthic species records in the Aegean\neu_seabed_habitats_2019: Seabed habitat polygons\n\nEMODnet WCS:\n\nemodnet__mean_2020: Bathymetry raster (mean depth of seafloor)\n\nCopernicus Marine Service:\n\nGLOBAL_MULTIYEAR_PHY_001_030: Bottom temperature and/or salinity reanalysis data\n\nExternal Resources:\n\nMOBS (Marine Organism Body Size) database: github.com/crmcclain/MOBS_OPEN\n\n\n\n\n\nAegean Sea\nCheck back soon for the complete tutorial!"
  },
  {
    "objectID": "tutorials/tutorial-04.html#tutorial-content",
    "href": "tutorials/tutorial-04.html#tutorial-content",
    "title": "4: Functional Traits Across Seabed Habitats",
    "section": "",
    "text": "This tutorial is currently under development.\n\n\n\nDemonstrating combined use of emodnet.wfs, emodnet.wcs, and CopernicusMarine packages\nRetrieving and visualising body size traits for benthic species using trait databases\nExploring trait–environment relationships across habitat types\nPractical geospatial workflows including raster extraction and spatial joins\n\n\n\n\n\nEMODnet WFS:\n\neb185_benthos_full_matched: Benthic species records in the Aegean\neu_seabed_habitats_2019: Seabed habitat polygons\n\nEMODnet WCS:\n\nemodnet__mean_2020: Bathymetry raster (mean depth of seafloor)\n\nCopernicus Marine Service:\n\nGLOBAL_MULTIYEAR_PHY_001_030: Bottom temperature and/or salinity reanalysis data\n\nExternal Resources:\n\nMOBS (Marine Organism Body Size) database: github.com/crmcclain/MOBS_OPEN\n\n\n\n\n\nAegean Sea\nCheck back soon for the complete tutorial!"
  },
  {
    "objectID": "tutorials/tutorial-02.html",
    "href": "tutorials/tutorial-02.html",
    "title": "2: Copepods and Fish Spawning Grounds",
    "section": "",
    "text": "The North Sea is a critical spawning area for commercially important gadoid fish, including whiting (Merlangius merlangus) and haddock (Melanogrammus aeglefinus). The larvae of these species depend heavily on copepods for food, and the match between larval emergence and copepod availability is a key factor in recruitment success.\nIn this tutorial, we’ll use EMODnet data to characterize copepod conditions across predicted spawning grounds for these species. This is a descriptive analysis: we’re not testing whether fish “choose” spawning sites based on copepods, but rather documenting the zooplankton environment that larvae would encounter.\nWe’ll access gridded (raster) data from EMODnet using Web Coverage Services (WCS). Unlike the vector data explored in Tutorial 1, raster data represents continuous surfaces divided into regular grid cells, making it ideal for environmental layers like zooplankton relative abundance.\n\n\nBy the end of this tutorial, you will be able to:\n\nExplore and discover available WCS coverages using emodnet.wcs functions\nRetrieve raster data for a specific area and time period using emdn_get_coverage()\nAlign rasters from different sources with different resolutions\nExtract and summarize environmental conditions within habitat areas\nVisualize multi-layer raster data with spawning ground overlays\n\n\n\n\nEMODnet Biology WCS: Copepod relative abundance layers\n\n\n\n\n\n\n\nCoverage ID\nDescription\n\n\n\n\nEmodnetbio__cal_fin_*\nCalanus finmarchicus - key prey for gadoid larvae\n\n\nEmodnetbio__tem_lon_*\nTemora longicornis - important coastal copepod\n\n\nEmodnetbio__tot_lar_*\nTotal large copepods\n\n\nEmodnetbio__tot_sma_*\nTotal small copepods\n\n\n\nEMODnet Seabed Habitats WCS: UK Essential Fish Habitat spawning ground predictions\n\n\n\nSpecies\nCoverage ID\n\n\n\n\nWhiting\nGB000050_EFH_Whiting_SpawningGrounds\n\n\nHaddock\nGB000051_EFH_Haddock_SpawningGrounds"
  },
  {
    "objectID": "tutorials/tutorial-02.html#introduction",
    "href": "tutorials/tutorial-02.html#introduction",
    "title": "2: Copepods and Fish Spawning Grounds",
    "section": "",
    "text": "The North Sea is a critical spawning area for commercially important gadoid fish, including whiting (Merlangius merlangus) and haddock (Melanogrammus aeglefinus). The larvae of these species depend heavily on copepods for food, and the match between larval emergence and copepod availability is a key factor in recruitment success.\nIn this tutorial, we’ll use EMODnet data to characterize copepod conditions across predicted spawning grounds for these species. This is a descriptive analysis: we’re not testing whether fish “choose” spawning sites based on copepods, but rather documenting the zooplankton environment that larvae would encounter.\nWe’ll access gridded (raster) data from EMODnet using Web Coverage Services (WCS). Unlike the vector data explored in Tutorial 1, raster data represents continuous surfaces divided into regular grid cells, making it ideal for environmental layers like zooplankton relative abundance.\n\n\nBy the end of this tutorial, you will be able to:\n\nExplore and discover available WCS coverages using emodnet.wcs functions\nRetrieve raster data for a specific area and time period using emdn_get_coverage()\nAlign rasters from different sources with different resolutions\nExtract and summarize environmental conditions within habitat areas\nVisualize multi-layer raster data with spawning ground overlays\n\n\n\n\nEMODnet Biology WCS: Copepod relative abundance layers\n\n\n\n\n\n\n\nCoverage ID\nDescription\n\n\n\n\nEmodnetbio__cal_fin_*\nCalanus finmarchicus - key prey for gadoid larvae\n\n\nEmodnetbio__tem_lon_*\nTemora longicornis - important coastal copepod\n\n\nEmodnetbio__tot_lar_*\nTotal large copepods\n\n\nEmodnetbio__tot_sma_*\nTotal small copepods\n\n\n\nEMODnet Seabed Habitats WCS: UK Essential Fish Habitat spawning ground predictions\n\n\n\nSpecies\nCoverage ID\n\n\n\n\nWhiting\nGB000050_EFH_Whiting_SpawningGrounds\n\n\nHaddock\nGB000051_EFH_Haddock_SpawningGrounds"
  },
  {
    "objectID": "tutorials/tutorial-02.html#setup",
    "href": "tutorials/tutorial-02.html#setup",
    "title": "2: Copepods and Fish Spawning Grounds",
    "section": "Setup",
    "text": "Setup\n\nPackages\nWe’ll use emodnet.wcs to access EMODnet WCS services, terra for raster data handling, sf for spatial operations, dplyr for data manipulation, and ggplot2 with tidyterra for visualization.\n\nlibrary(emodnet.wcs)\nlibrary(terra)\nlibrary(sf)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(purrr)\nlibrary(ggplot2)\nlibrary(tidyterra)\nlibrary(tmap)\n\n\n\n\n\n\n\nTipPackage installation\n\n\n\n\n\nIf you haven’t installed these packages, run:\ninstall.packages(c(\"terra\", \"sf\", \"dplyr\", \"tidyr\", \"purrr\", \"ggplot2\", \"tidyterra\", \"tmap\"))\nFor the EMODnet packages (development versions from GitHub):\n# install.packages(\"pak\")\npak::pak(c(\"EMODnet/emodnet.wfs\", \"EMODnet/emodnet.wcs\"))\n\n\n\n\n\nStudy Area\nWe’ll focus on the North Sea, where UK Essential Fish Habitat data overlaps with EMODnet Biology copepod coverage:\n\n# Geographic bbox for WCS queries (EPSG:4326)\nnorth_sea_bbox &lt;- c(xmin = -4, ymin = 50, xmax = 10, ymax = 62)\n\n# Create bbox polygon for visualization\nbbox_polygon &lt;- sf::st_as_sfc(sf::st_bbox(north_sea_bbox, crs = 4326))\n\nNote that unlike WFS queries (which use a character string like \"xmin,ymin,xmax,ymax\"), WCS queries in emodnet.wcs expect a named numeric vector with xmin, ymin, xmax, and ymax elements. The bbox is assumed to be in WGS84 (EPSG:4326) by default, but you can specify a different CRS using the crs argument.\n\n\n\n\n\n\n\n\nFigure 1: Study area: North Sea"
  },
  {
    "objectID": "tutorials/tutorial-02.html#exploring-emodnet-wcs-services",
    "href": "tutorials/tutorial-02.html#exploring-emodnet-wcs-services",
    "title": "2: Copepods and Fish Spawning Grounds",
    "section": "Exploring EMODnet WCS Services",
    "text": "Exploring EMODnet WCS Services\nBefore downloading raster data, let’s explore what’s available.\n\nDiscovering Available Services\nEMODnet provides raster data through several thematic WCS services:\n\nemdn_wcs()\n\n\n\n\n\n\n\n\n\n\nservice_name\nservice_url\n\n\n\n\nbathymetry\nhttps://ows.emodnet-bathymetry.eu/wcs\n\n\nbiology\nhttps://geo.vliz.be/geoserver/Emodnetbio/wcs\n\n\nhuman_activities\nhttps://ows.emodnet-humanactivities.eu/wcs\n\n\nseabed_habitats\nhttps://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_open_maplibrary/wcs\n\n\n\n\n\nFor this tutorial, we’ll use the biology service for copepod data and the seabed_habitats service for spawning ground predictions.\n\n\nConnecting to Services\nTo query a WCS service, we first create client connections:\n\nbio_wcs &lt;- emdn_init_wcs_client(service = \"biology\")\nhabitat_wcs &lt;- emdn_init_wcs_client(service = \"seabed_habitats\")\n\n\n\nDiscovering Copepod Coverages\nLet’s explore what copepod data is available:\n\nbio_coverage_ids &lt;- emdn_get_coverage_ids(bio_wcs)\nbio_coverage_ids\n#&gt;  [1] \"Emodnetbio__ratio_large_to_small_19582016_L1_err\"\n#&gt;  [2] \"Emodnetbio__aca_spp_19582016_L1\"                 \n#&gt;  [3] \"Emodnetbio__cal_fin_19582016_L1_err\"             \n#&gt;  [4] \"Emodnetbio__cal_hel_19582016_L1_err\"             \n#&gt;  [5] \"Emodnetbio__met_luc_19582016_L1_err\"             \n#&gt;  [6] \"Emodnetbio__oit_spp_19582016_L1_err\"             \n#&gt;  [7] \"Emodnetbio__tem_lon_19582016_L1_err\"             \n#&gt;  [8] \"Emodnetbio__chli_19582016_L1_err\"                \n#&gt;  [9] \"Emodnetbio__tot_lar_19582016_L1_err\"             \n#&gt; [10] \"Emodnetbio__tot_sma_19582016_L1_err\"\n\nThe coverage IDs follow a naming convention:\n\nEmodnetbio__ prefix indicates EMODnet Biology\nSpecies abbreviation (e.g., cal_fin for Calanus finmarchicus)\nTime period (19582016 = 1958-2016)\nProcessing level (e.g., L1 for the DIVAnd interpolation model)\n_err suffix indicates error bands are included\n\nFor this tutorial, we’ll use four copepod layers that are ecologically relevant for gadoid larvae: Calanus finmarchicus (a key prey species), Temora longicornis (an important coastal copepod), and total large and small copepod relative abundance.\n\n\n\n\n\n\nNoteAbout these data products\n\n\n\nThese copepod layers are from EMODnet’s OOPS products, created by interpolating Continuous Plankton Recorder (CPR) survey data using DIVAnd.\nThe underlying CPR data records organisms per 3 m³ of filtered seawater (from 10 nautical mile tows). However, the DIVAnd interpolation produces dimensionless relative abundance indices rather than absolute counts. Importantly, DIVAnd processes each species independently (univariate analysis), so values are not comparable between species. You can compare spatial patterns within a species (e.g., “Calanus is more abundant here than there”) but not across species (e.g., “Calanus is more abundant than Temora”).\nThe _err suffix indicates coverages include both relative abundance and error bands.\n\n\n\n\nUnderstanding Coverage Properties\nLet’s examine the metadata for our selected copepod layers:\n\ncopepod_ids &lt;- c(\n  \"Emodnetbio__cal_fin_19582016_L1_err\",\n  \"Emodnetbio__tem_lon_19582016_L1_err\",\n  \"Emodnetbio__tot_lar_19582016_L1_err\",\n  \"Emodnetbio__tot_sma_19582016_L1_err\"\n)\n\nThe emdn_get_coverage_info() function provides a full overview of coverage metadata:\n\ncopepod_info &lt;- emdn_get_coverage_info(\n  wcs = bio_wcs,\n  coverage_ids = copepod_ids\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata_source\nservice_name\nservice_url\ncoverage_id\nband_description\nband_uom\nconstraint\nnil_value\ndim_n\ndim_names\ngrid_size\nresolution\nextent\ncrs\nwgs84_extent\ntemporal_extent\nvertical_extent\nsubtype\nfn_seq_rule\nfn_start_point\nfn_axis_order\n\n\n\n\nemodnet_wcs\nhttps://geo.vliz.be/geoserver/Emodnetbio/wcs\nbiology\nEmodnetbio__cal_fin_19582016_L1_err\nRelative abundance, Relative error\nW.m-2.Sr-1\n-3.4028235e+38-3.4028235e+38\n9.96921e+36\n3\nlat(deg):geographic; long(deg):geographic; time(s):temporal\n951x401\n0.1 Deg x 0.1 Deg\n-75.05, 34.95, 20.05, 75.05\nEPSG:4326\n-75.05, 34.95, 20.05, 75.05\n1958-02-16T01:00:00 - 2016-11-16T01:00:00\nNA\nRectifiedGridCoverage\nLinear\n0,0\n+2,+1\n\n\nemodnet_wcs\nhttps://geo.vliz.be/geoserver/Emodnetbio/wcs\nbiology\nEmodnetbio__tem_lon_19582016_L1_err\nRelative abundance, Relative error\nW.m-2.Sr-1\n-3.4028235e+38-3.4028235e+38\n9.96921e+36\n3\nlat(deg):geographic; long(deg):geographic; time(s):temporal\n951x401\n0.1 Deg x 0.1 Deg\n-75.05, 34.95, 20.05, 75.05\nEPSG:4326\n-75.05, 34.95, 20.05, 75.05\n1958-02-16T01:00:00 - 2016-11-16T01:00:00\nNA\nRectifiedGridCoverage\nLinear\n0,0\n+2,+1\n\n\nemodnet_wcs\nhttps://geo.vliz.be/geoserver/Emodnetbio/wcs\nbiology\nEmodnetbio__tot_lar_19582016_L1_err\nRelative abundance, Relative error\nW.m-2.Sr-1\n-3.4028235e+38-3.4028235e+38\n9.96921e+36\n3\nlat(deg):geographic; long(deg):geographic; time(s):temporal\n951x401\n0.1 Deg x 0.1 Deg\n-75.05, 34.95, 20.05, 75.05\nEPSG:4326\n-75.05, 34.95, 20.05, 75.05\n1958-02-16T01:00:00 - 2016-11-16T01:00:00\nNA\nRectifiedGridCoverage\nLinear\n0,0\n+2,+1\n\n\nemodnet_wcs\nhttps://geo.vliz.be/geoserver/Emodnetbio/wcs\nbiology\nEmodnetbio__tot_sma_19582016_L1_err\nRelative abundance, Relative error\nW.m-2.Sr-1\n-3.4028235e+38-3.4028235e+38\n9.96921e+36\n3\nlat(deg):geographic; long(deg):geographic; time(s):temporal\n951x401\n0.1 Deg x 0.1 Deg\n-75.05, 34.95, 20.05, 75.05\nEPSG:4326\n-75.05, 34.95, 20.05, 75.05\n1958-02-16T01:00:00 - 2016-11-16T01:00:00\nNA\nRectifiedGridCoverage\nLinear\n0,0\n+2,+1\n\n\n\n\n\nTo retrieve specific pieces of metadata, we can get a coverage summary object and use accessor functions. For example, let’s examine what dimensions are available for the Calanus coverage:\n\n# Returns a list with one element per coverage ID - extract the first (and only) element\ncalanus_summary &lt;- emdn_get_coverage_summaries(bio_wcs, copepod_ids[1])[[1]]\n\n# What dimensions does this coverage have?\nemdn_get_dimensions_info(calanus_summary, format = \"tibble\")\n\n\n  \n\n\n\nThe coverage has latitude, longitude, and a time dimension. The range column shows the temporal extent, but to see the actual available time steps we use emdn_get_coverage_dim_coefs():\n\n# Returns a named list - extract the vector for our coverage\ntime_steps &lt;- emdn_get_coverage_dim_coefs(bio_wcs, copepod_ids[1])[[1]]\n\n# Temporal extent\nrange(time_steps)\n#&gt; [1] \"1958-02-16T01:00:00\" \"2016-11-16T01:00:00\"\n\n# How many time steps?\nlength(time_steps)\n#&gt; [1] 236\n\n# Show first few to see the pattern\nhead(time_steps, 8)\n#&gt; [1] \"1958-02-16T01:00:00\" \"1958-05-16T01:00:00\" \"1958-08-16T01:00:00\"\n#&gt; [4] \"1958-11-16T01:00:00\" \"1959-02-16T01:00:00\" \"1959-05-16T01:00:00\"\n#&gt; [7] \"1959-08-16T01:00:00\" \"1959-11-16T01:00:00\"\n\nThe 236 timestamps show quarterly data (February, May, August, November) from 1958 to 2016.\nWe can also check spatial properties:\n\n# Spatial resolution (degrees)\nemdn_get_resolution(calanus_summary)\n#&gt;   x   y \n#&gt; 0.1 0.1 \n#&gt; attr(,\"uom\")\n#&gt; [1] \"Deg\" \"Deg\"\n\n# Bounding box in WGS84\nemdn_get_WGS84bbox(calanus_summary)\n#&gt;   xmin   ymin   xmax   ymax \n#&gt; -75.05  34.95  20.05  75.05\n\nThe resolution is 0.1° (approximately 7-11 km depending on latitude). The bounding box spans the North Atlantic, but note that this shows the grid boundaries, not where actual data exists. CPR survey coverage is patchy in some regions, so always check for NA values when working with a specific area.\nAnd band metadata:\n\n# Band descriptions\nemdn_get_band_descriptions(calanus_summary)\n#&gt; [1] \"Relative abundance\" \"Relative error\"    \n#&gt; attr(,\"uom\")\n#&gt; [1] \"W.m-2.Sr-1\" \"W.m-2.Sr-1\"\n\n# Band units of measurement\nemdn_get_band_uom(calanus_summary)\n#&gt; Relative abundance     Relative error \n#&gt;       \"W.m-2.Sr-1\"       \"W.m-2.Sr-1\"\n\nThe band descriptions confirm these coverages contain two bands: the relative abundance estimate and its error. However, the band_uom shows W.m-2.Sr-1, a radiance unit from remote sensing. This is incorrect metadata, likely propagated from satellite-derived environmental inputs used in the DIVAnd interpolation. As noted above, the actual values are dimensionless relative abundance indices.\n\n\nDiscovering Spawning Ground Coverages\nNow let’s find fish spawning ground data that overlaps with our copepod coverage. First, we search for spawning-related coverages:\n\nhabitat_coverage_ids &lt;- emdn_get_coverage_ids(habitat_wcs)\n\n# Filter for spawning ground coverages\nspawning_ids &lt;- habitat_coverage_ids[grepl(\n  \"spawning\",\n  habitat_coverage_ids,\n  ignore.case = TRUE\n)]\nspawning_ids\n#&gt;  [1] \"emodnet_open_maplibrary__DK004008_EFH_Cod_Spawning grounds\"     \n#&gt;  [2] \"emodnet_open_maplibrary__DK004011_EFH_Plaice_Spawning grounds\"  \n#&gt;  [3] \"emodnet_open_maplibrary__DK004017_EFH_Flounder_Spawning grounds\"\n#&gt;  [4] \"emodnet_open_maplibrary__FR005109_EFH_Seabass_SpawningGrounds\"  \n#&gt;  [5] \"emodnet_open_maplibrary__FR005110_EFH_Dragonets_SpawningGrounds\"\n#&gt;  [6] \"emodnet_open_maplibrary__FR005111_EFH_Cod_SpawningGrounds\"      \n#&gt;  [7] \"emodnet_open_maplibrary__FR005112_EFH_Dab_SpawningGrounds\"      \n#&gt;  [8] \"emodnet_open_maplibrary__FR005113_EFH_Rocklings_SpawningGrounds\"\n#&gt;  [9] \"emodnet_open_maplibrary__FR005114_EFH_Whiting_SpawningGrounds\"  \n#&gt; [10] \"emodnet_open_maplibrary__FR005115_EFH_Flounder_SpawningGrounds\" \n#&gt; [11] \"emodnet_open_maplibrary__FR005116_EFH_Plaice_SpawningGrounds\"   \n#&gt; [12] \"emodnet_open_maplibrary__FR005117_EFH_Sole_SpawningGrounds\"     \n#&gt; [13] \"emodnet_open_maplibrary__GB000050_EFH_Whiting_SpawningGrounds\"  \n#&gt; [14] \"emodnet_open_maplibrary__GB000051_EFH_Haddock_SpawningGrounds\"  \n#&gt; [15] \"emodnet_open_maplibrary__PT005001_EFH_Sardine_SpawningGrounds\"  \n#&gt; [16] \"emodnet_open_maplibrary__PT005002_EFH_Sardine_SpawningGrounds\"  \n#&gt; [17] \"emodnet_open_maplibrary__PT005003_EFH_Sardine_SpawningGrounds\"  \n#&gt; [18] \"emodnet_open_maplibrary__PT005004_EFH_Sardine_SpawningGrounds\"  \n#&gt; [19] \"emodnet_open_maplibrary__PT005005_EFH_Sardine_SpawningGrounds\"  \n#&gt; [20] \"emodnet_open_maplibrary__PT005006_EFH_Sardine_SpawningGrounds\"\n\nThere are spawning ground predictions from Denmark (DK), France (FR), Great Britain (GB), and Portugal (PT). Let’s get their full metadata to get a better understanding of what they contain:\n\nspawning_info_all &lt;- emdn_get_coverage_info(\n  wcs = habitat_wcs,\n  coverage_ids = spawning_ids\n)\nspawning_info_all |&gt;\n  dplyr::select(coverage_id, wgs84_extent) |&gt;\n  knitr::kable()\n\n\n\n\n\n\n\n\ncoverage_id\nwgs84_extent\n\n\n\n\nemodnet_open_maplibrary__DK004008_EFH_Cod_Spawning grounds\n9.52, 54.12, 13.57, 57.97\n\n\nemodnet_open_maplibrary__DK004011_EFH_Plaice_Spawning grounds\n9.52, 54.12, 13.57, 57.97\n\n\nemodnet_open_maplibrary__DK004017_EFH_Flounder_Spawning grounds\n9.52, 54.12, 13.57, 57.97\n\n\nemodnet_open_maplibrary__FR005109_EFH_Seabass_SpawningGrounds\n-5.4, 43.5, -1.15, 48\n\n\nemodnet_open_maplibrary__FR005110_EFH_Dragonets_SpawningGrounds\n-0.05, 49.9, 2.54, 51.4\n\n\nemodnet_open_maplibrary__FR005111_EFH_Cod_SpawningGrounds\n0.04, 49.9, 2.55, 51.4\n\n\nemodnet_open_maplibrary__FR005112_EFH_Dab_SpawningGrounds\n0.04, 49.9, 2.55, 51.4\n\n\nemodnet_open_maplibrary__FR005113_EFH_Rocklings_SpawningGrounds\n0.04, 49.9, 2.55, 51.4\n\n\nemodnet_open_maplibrary__FR005114_EFH_Whiting_SpawningGrounds\n0.04, 49.9, 2.55, 51.4\n\n\nemodnet_open_maplibrary__FR005115_EFH_Flounder_SpawningGrounds\n0.04, 49.9, 2.55, 51.4\n\n\nemodnet_open_maplibrary__FR005116_EFH_Plaice_SpawningGrounds\n0.04, 49.9, 2.55, 51.4\n\n\nemodnet_open_maplibrary__FR005117_EFH_Sole_SpawningGrounds\n0.04, 49.9, 2.55, 51.4\n\n\nemodnet_open_maplibrary__GB000050_EFH_Whiting_SpawningGrounds\n-4.21, 49.31, 10.07, 61.99\n\n\nemodnet_open_maplibrary__GB000051_EFH_Haddock_SpawningGrounds\n-4.21, 49.31, 10.07, 61.99\n\n\nemodnet_open_maplibrary__PT005001_EFH_Sardine_SpawningGrounds\n-9.95, 35.8, -5.95, 42.05\n\n\nemodnet_open_maplibrary__PT005002_EFH_Sardine_SpawningGrounds\n-9.95, 35.8, -5.95, 42.05\n\n\nemodnet_open_maplibrary__PT005003_EFH_Sardine_SpawningGrounds\n-9.95, 35.8, -5.95, 42.05\n\n\nemodnet_open_maplibrary__PT005004_EFH_Sardine_SpawningGrounds\n-9.95, 35.8, -5.95, 42.05\n\n\nemodnet_open_maplibrary__PT005005_EFH_Sardine_SpawningGrounds\n-9.95, 35.8, -5.95, 42.05\n\n\nemodnet_open_maplibrary__PT005006_EFH_Sardine_SpawningGrounds\n-9.95, 35.8, -5.95, 42.05\n\n\n\n\n\nChecking the spatial extents helps identify which layers might overlap with our North Sea copepod data. Note that wgs84_extent shows grid boundaries, not actual data coverage. When exploring these layers, we found the UK (GB) spawning grounds work best for this tutorial because they cover the North Sea where copepod data is most complete. Other regions had sparse copepod coverage or limited spatial extent.\nWe’ll use whiting and haddock, both gadoids whose larvae depend on copepods:\n\nspawning_ids &lt;- c(\n  \"emodnet_open_maplibrary__GB000050_EFH_Whiting_SpawningGrounds\",\n  \"emodnet_open_maplibrary__GB000051_EFH_Haddock_SpawningGrounds\"\n)\n\nLet’s subset the overall metadata table for the coverages of interest to take a closer look:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata_source\nservice_name\nservice_url\ncoverage_id\nband_description\nband_uom\nconstraint\nnil_value\ndim_n\ndim_names\ngrid_size\nresolution\nextent\ncrs\nwgs84_extent\ntemporal_extent\nvertical_extent\nsubtype\nfn_seq_rule\nfn_start_point\nfn_axis_order\n\n\n\n\nemodnet_wcs\nhttps://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_open_maplibrary/wcs\nseabed_habitats\nemodnet_open_maplibrary__GB000050_EFH_Whiting_SpawningGrounds\nGRAY_INDEX\nW.m-2.Sr-1\n-3.4028235e+38-3.4028235e+38\nNaN\n2\nx(m):geographic; y(m):geographic\n291x399\n6330.76101732992 m x 5462.12992866693 m\n-468141.27, 6327797.09, 1120879.74, 8856763.25\nEPSG:3857\n-4.21, 49.31, 10.07, 61.99\nNA\nNA\nRectifiedGridCoverage\nLinear\n0,0\n+1,+2\n\n\nemodnet_wcs\nhttps://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_open_maplibrary/wcs\nseabed_habitats\nemodnet_open_maplibrary__GB000051_EFH_Haddock_SpawningGrounds\nGRAY_INDEX\nW.m-2.Sr-1\n-3.4028235e+38-3.4028235e+38\nNaN\n2\nx(m):geographic; y(m):geographic\n291x399\n6330.76101732992 m x 5462.12992866693 m\n-468141.27, 6327797.09, 1120879.74, 8856763.25\nEPSG:3857\n-4.21, 49.31, 10.07, 61.99\nNA\nNA\nRectifiedGridCoverage\nLinear\n0,0\n+1,+2\n\n\n\n\n\nThe full metadata for our selected layers is in the table above. Key points for combining with our copepod data:\n\nResolution: ~6.3 km (finer than the copepod grid at ~10 km)\nTemporal extent: NA, meaning these are static layers with no time dimension, unlike our quarterly copepod data\nDimensions: Only 2 (x, y), so no time slicing needed when downloading\nCRS: Projected coordinate system (meters), which we’ll need to reproject to match the copepod WGS84 grid\n\n\n\n\n\n\n\nNoteAbout these data products\n\n\n\nThese Essential Fish Habitat (EFH) layers are from the Scottish Government EFH mapping project, produced using decision tree models with fish survey data (2010-2020) and environmental predictors. Environmental predictors include physical oceanographic variables (temperature, depth, salinity, currents) rather than biological factors like prey availability. Values represent habitat suitability (0-1 probability scores).\n\n\n\n\n\n\n\n\nWarningMisleading unit metadata\n\n\n\nAgain, band_uom shows W.m-2.Sr-1. As with the copepod layers, this likely propagated from satellite-derived environmental inputs used in the models. The actual values are dimensionless suitability scores."
  },
  {
    "objectID": "tutorials/tutorial-02.html#retrieving-copepod-data",
    "href": "tutorials/tutorial-02.html#retrieving-copepod-data",
    "title": "2: Copepods and Fish Spawning Grounds",
    "section": "Retrieving Copepod Data",
    "text": "Retrieving Copepod Data\nNow, let’s go ahead and start downloading actual data. Let’s start with copepod relative abundance data for the spawning period.\n\nSelecting the Time Period\nThe copepod data uses quarterly timesteps (February, May, August, November). Gadoids in the North Sea typically spawn in late winter to early spring, so we’ll use February timesteps.\nRather than using a single year (which might be anomalous), we’ll download multiple years and calculate the mean. This gives a more representative picture of typical conditions. We’ll use the three most recent February timesteps available in the dataset (2014-2016):\n\n# Most recent February timesteps available\nspawning_times &lt;- c(\n  \"2014-02-16T01:00:00\",\n  \"2015-02-16T01:00:00\",\n  \"2016-02-16T01:00:00\"\n)\n\n\n\nDownloading Copepod Layers\nWe can pass multiple time values to emdn_get_coverage() which will return a multi-layer stack.\nWe’ve seen that these coverages include both relative abundance estimates and associated errors (from the DIVAnd interpolation). In a full analysis, you’d want to consider these errors, as areas with sparse CPR sampling will have higher uncertainty. For simplicity, in this tutorial we’ll focus on the relative abundance values only and use argument rangesubset to request just the “Relative abundance” band from each coverage:\n\n# Download Calanus with all three timepoints, relative abundance band only\ncalanus_stack &lt;- emdn_get_coverage(\n  wcs = bio_wcs,\n  coverage_id = \"Emodnetbio__cal_fin_19582016_L1_err\",\n  bbox = north_sea_bbox,\n  time = spawning_times,\n  rangesubset = \"Relative abundance\"\n)\n#&gt; &lt;GMLEnvelope&gt;\n#&gt; ....|-- lowerCorner: 50 -4 \"1958-02-16T01:00:00\"\n#&gt; ....|-- upperCorner: 62 10 \"2016-11-16T01:00:00\"&lt;GMLEnvelope&gt;\n#&gt; ....|-- lowerCorner: 50 -4 \"1958-02-16T01:00:00\"\n#&gt; ....|-- upperCorner: 62 10 \"2016-11-16T01:00:00\"&lt;GMLEnvelope&gt;\n#&gt; ....|-- lowerCorner: 50 -4 \"1958-02-16T01:00:00\"\n#&gt; ....|-- upperCorner: 62 10 \"2016-11-16T01:00:00\"\n\n# Check the structure - one layer per timepoint\ncalanus_stack\n#&gt; class       : SpatRaster \n#&gt; size        : 120, 140, 3  (nrow, ncol, nlyr)\n#&gt; resolution  : 0.1, 0.1  (x, y)\n#&gt; extent      : -4.05, 9.95, 49.95, 61.95  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#&gt; sources     : Emodnetbio__cal_fin_19582016_L1_err_2014-02-16T01_00_00_50,-4,62,10.tif  \n#&gt;               Emodnetbio__cal_fin_19582016_L1_err_2015-02-16T01_00_00_50,-4,62,10.tif  \n#&gt;               Emodnetbio__cal_fin_19582016_L1_err_2016-02-16T01_00_00_50,-4,62,10.tif  \n#&gt; names       : Emodnetbio~0,-4,62,10, Emodnetbio~0,-4,62,10, Emodnetbio~0,-4,62,10\n\nLet’s download the remaining copepod layers the same way:\n\ntemora_stack &lt;- emdn_get_coverage(\n  wcs = bio_wcs,\n  coverage_id = \"Emodnetbio__tem_lon_19582016_L1_err\",\n  bbox = north_sea_bbox,\n  time = spawning_times,\n  rangesubset = \"Relative abundance\"\n)\n#&gt; &lt;GMLEnvelope&gt;\n#&gt; ....|-- lowerCorner: 50 -4 \"1958-02-16T01:00:00\"\n#&gt; ....|-- upperCorner: 62 10 \"2016-11-16T01:00:00\"&lt;GMLEnvelope&gt;\n#&gt; ....|-- lowerCorner: 50 -4 \"1958-02-16T01:00:00\"\n#&gt; ....|-- upperCorner: 62 10 \"2016-11-16T01:00:00\"&lt;GMLEnvelope&gt;\n#&gt; ....|-- lowerCorner: 50 -4 \"1958-02-16T01:00:00\"\n#&gt; ....|-- upperCorner: 62 10 \"2016-11-16T01:00:00\"\n\ntot_large_stack &lt;- emdn_get_coverage(\n  wcs = bio_wcs,\n  coverage_id = \"Emodnetbio__tot_lar_19582016_L1_err\",\n  bbox = north_sea_bbox,\n  time = spawning_times,\n  rangesubset = \"Relative abundance\"\n)\n#&gt; &lt;GMLEnvelope&gt;\n#&gt; ....|-- lowerCorner: 50 -4 \"1958-02-16T01:00:00\"\n#&gt; ....|-- upperCorner: 62 10 \"2016-11-16T01:00:00\"&lt;GMLEnvelope&gt;\n#&gt; ....|-- lowerCorner: 50 -4 \"1958-02-16T01:00:00\"\n#&gt; ....|-- upperCorner: 62 10 \"2016-11-16T01:00:00\"&lt;GMLEnvelope&gt;\n#&gt; ....|-- lowerCorner: 50 -4 \"1958-02-16T01:00:00\"\n#&gt; ....|-- upperCorner: 62 10 \"2016-11-16T01:00:00\"\n\ntot_small_stack &lt;- emdn_get_coverage(\n  wcs = bio_wcs,\n  coverage_id = \"Emodnetbio__tot_sma_19582016_L1_err\",\n  bbox = north_sea_bbox,\n  time = spawning_times,\n  rangesubset = \"Relative abundance\"\n)\n#&gt; &lt;GMLEnvelope&gt;\n#&gt; ....|-- lowerCorner: 50 -4 \"1958-02-16T01:00:00\"\n#&gt; ....|-- upperCorner: 62 10 \"2016-11-16T01:00:00\"&lt;GMLEnvelope&gt;\n#&gt; ....|-- lowerCorner: 50 -4 \"1958-02-16T01:00:00\"\n#&gt; ....|-- upperCorner: 62 10 \"2016-11-16T01:00:00\"&lt;GMLEnvelope&gt;\n#&gt; ....|-- lowerCorner: 50 -4 \"1958-02-16T01:00:00\"\n#&gt; ....|-- upperCorner: 62 10 \"2016-11-16T01:00:00\"\n\n\n\n\n\n\n\nTipDownloading multiple coverages with map()\n\n\n\n\n\nThe repetitive download code above could be condensed using purrr::map(). This returns a list of rasters:\ncopepod_stacks &lt;- map(copepod_ids, \\(id) {\n  emdn_get_coverage(\n    wcs = bio_wcs,\n    coverage_id = id,\n    bbox = north_sea_bbox,\n    time = spawning_times,\n    rangesubset = \"Relative abundance\"\n  )\n})\nWe use the explicit approach in this tutorial for clarity, but map() is useful when downloading many coverages.\n\n\n\n\n\nAveraging Across Years\nEach stack now contains three rasters, one for each February (2014, 2015, 2016). To create a representative picture of typical spawning-season conditions, we calculate the mean across years using terra::mean(). This operates cell-by-cell across the stack.\nWe can use map() to apply the averaging to all stacks at once, then combine the resulting list of rasters into a single multi-layer raster using rast():\n\n# Average across years for each species, then combine into one raster\ncopepods &lt;- list(\n  calanus_stack,\n  temora_stack,\n  tot_large_stack,\n  tot_small_stack\n) |&gt;\n  map(\\(stack) mean(stack, na.rm = TRUE)) |&gt;\n  rast()\n\n# Name the layers for easy subsetting and plot labels\nnames(copepods) &lt;- c(\"Calanus\", \"Temora\", \"Large\", \"Small\")\n\n# Check result - a 4-layer raster\ncopepods\n#&gt; class       : SpatRaster \n#&gt; size        : 120, 140, 4  (nrow, ncol, nlyr)\n#&gt; resolution  : 0.1, 0.1  (x, y)\n#&gt; extent      : -4.05, 9.95, 49.95, 61.95  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#&gt; source(s)   : memory\n#&gt; names       :    Calanus,     Temora,       Large,      Small \n#&gt; min values  : -0.2106529, -0.1512153, -0.09880921, -0.2196849 \n#&gt; max values  :  2.0994925,  2.4651998,  2.84098649,  5.8262204\n\nThe result is a multi-layer SpatRaster where each layer contains the 3-year February mean relative abundance for one copepod type. Note that combining the rasters only works because all four coverages share the same grid (extent and resolution), which they do here as they were produced together as part of the same data product.\n\n\n\n\n\n\nTipCombining rasters: rast() vs c()\n\n\n\n\n\nBoth rast() and c() can combine SpatRaster objects into a multi-layer raster:\n\nrast(list_of_rasters) - takes a list of rasters (useful after map())\nc(r1, r2, r3) - takes individual raster objects\n\nFor example, if we had individual raster objects instead of a list:\ncopepods &lt;- c(calanus_mean, temora_mean, large_mean, small_mean)\nWe use rast() here because map() returns a list.\n\n\n\nWe can check the number of layers and subset using list-like syntax:\n\n# Number of layers\nnlyr(copepods)\n#&gt; [1] 4\n\n# Subset by name\ncopepods[[\"Calanus\"]]\n#&gt; class       : SpatRaster \n#&gt; size        : 120, 140, 1  (nrow, ncol, nlyr)\n#&gt; resolution  : 0.1, 0.1  (x, y)\n#&gt; extent      : -4.05, 9.95, 49.95, 61.95  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#&gt; source(s)   : memory\n#&gt; name        :    Calanus \n#&gt; min value   : -0.2106529 \n#&gt; max value   :  2.0994925\ncopepods$Calanus # equivalent\n#&gt; class       : SpatRaster \n#&gt; size        : 120, 140, 1  (nrow, ncol, nlyr)\n#&gt; resolution  : 0.1, 0.1  (x, y)\n#&gt; extent      : -4.05, 9.95, 49.95, 61.95  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#&gt; source(s)   : memory\n#&gt; name        :    Calanus \n#&gt; min value   : -0.2106529 \n#&gt; max value   :  2.0994925\n\n# Subset by index\ncopepods[[1]]\n#&gt; class       : SpatRaster \n#&gt; size        : 120, 140, 1  (nrow, ncol, nlyr)\n#&gt; resolution  : 0.1, 0.1  (x, y)\n#&gt; extent      : -4.05, 9.95, 49.95, 61.95  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#&gt; source(s)   : memory\n#&gt; name        :    Calanus \n#&gt; min value   : -0.2106529 \n#&gt; max value   :  2.0994925\n\n# Subset multiple layers\ncopepods[[c(\"Calanus\", \"Temora\")]]\n#&gt; class       : SpatRaster \n#&gt; size        : 120, 140, 2  (nrow, ncol, nlyr)\n#&gt; resolution  : 0.1, 0.1  (x, y)\n#&gt; extent      : -4.05, 9.95, 49.95, 61.95  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#&gt; source(s)   : memory\n#&gt; names       :    Calanus,     Temora \n#&gt; min values  : -0.2106529, -0.1512153 \n#&gt; max values  :  2.0994925,  2.4651998\n\n\n\nQuick Visualization\nLet’s visualize our copepod data. We use tidyterra::geom_spatraster() which integrates terra rasters with ggplot2. Using facet_wrap(~lyr) creates a separate panel for each layer in the stack:\n\nggplot() +\n  geom_spatraster(data = copepods) +\n  facet_wrap(~lyr, ncol = 2) +\n  scale_fill_viridis_c(\n    name = \"Relative\\nabundance\",\n    na.value = \"white\",\n    option = \"plasma\"\n  ) +\n  labs(\n    title = \"Copepod Distributions\",\n    subtitle = \"North Sea, February mean (2014-2016)\",\n    x = NULL,\n    y = NULL\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(size = 8, angle = 45, hjust = 1),\n    axis.text.y = element_text(size = 8),\n    legend.position = \"bottom\",\n    panel.spacing = unit(0.5, \"lines\")\n  )\n\n\n\n\n\n\n\nFigure 2: Mean copepod relative abundance in the North Sea (February 2014-2016)\n\n\n\n\n\nFebruary is relatively early in the seasonal cycle, so values are generally lower than summer months. Each panel shows distinct spatial patterns: total large copepods show higher relative abundance in the northwest, while total small copepods peak in the southeastern North Sea (German Bight) with elevated values extending along the eastern margin. Calanus and Temora both show low values overall, but with contrasting distributions: Calanus peaks in the northwest while Temora is higher in the southeast. Remember that values are not comparable across panels (each species is modelled independently), but the spatial gradients within each layer provide the variation needed for our analysis."
  },
  {
    "objectID": "tutorials/tutorial-02.html#retrieving-spawning-ground-data",
    "href": "tutorials/tutorial-02.html#retrieving-spawning-ground-data",
    "title": "2: Copepods and Fish Spawning Grounds",
    "section": "Retrieving Spawning Ground Data",
    "text": "Retrieving Spawning Ground Data\nNow let’s download spawning ground predictions for whiting and haddock. With only two coverages, we can use map() to download them in a single step:\n\n# Coverage IDs for each species\nspawning_coverage_ids &lt;- c(\n  Whiting = \"emodnet_open_maplibrary__GB000050_EFH_Whiting_SpawningGrounds\",\n  Haddock = \"emodnet_open_maplibrary__GB000051_EFH_Haddock_SpawningGrounds\"\n)\n\n# Download each spawning ground layer and combine into a multi-layer raster\nspawning &lt;- map(spawning_coverage_ids, \\(id) {\n  emdn_get_coverage(wcs = habitat_wcs, coverage_id = id, bbox = north_sea_bbox)\n}) |&gt;\n  rast()\n#&gt; &lt;GMLEnvelope&gt;\n#&gt; ....|-- lowerCorner: -445277.963173094 6446275.84101716\n#&gt; ....|-- upperCorner: 1113194.90793274 8859142.8005657\n#&gt; &lt;GMLEnvelope&gt;\n#&gt; ....|-- lowerCorner: -445277.963173094 6446275.84101716\n#&gt; ....|-- upperCorner: 1113194.90793274 8859142.8005657\n\nspawning\n#&gt; class       : SpatRaster \n#&gt; size        : 441, 246, 2  (nrow, ncol, nlyr)\n#&gt; resolution  : 6330.761, 5462.13  (x, y)\n#&gt; extent      : -442818.2, 1114549, 6447964, 8856763  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : WGS 84 / Pseudo-Mercator (EPSG:3857) \n#&gt; sources     : emodnet_open_maplibrary__GB000050_EFH_Whiting_SpawningGrounds_-445277.963173094,6446275.84101716,1113194.90793274,8859142.8005657.tif  \n#&gt;               emodnet_open_maplibrary__GB000051_EFH_Haddock_SpawningGrounds_-445277.963173094,6446275.84101716,1113194.90793274,8859142.8005657.tif  \n#&gt; names       : Whiting, Haddock\n\n\nDefining a Suitability Threshold\nTo characterize copepod conditions in spawning habitat, we need to classify cells as either suitable or unsuitable spawning grounds. This requires choosing a threshold on the suitability index to divide the data into two zones: areas above the threshold representing functional spawning habitat, and areas below representing marginal or unsuitable habitat.\nHabitat suitability indices range from 0 (unsuitable) to 1 (highly suitable), but interpreting intermediate values requires care. We want to exclude low-suitability cells that likely represent poor or marginal habitat. A threshold of 0.3 is commonly used in habitat suitability studies to separate “unsuitable” from “marginal” habitat (Brooks 1997; Kim et al. 2025), so we adopt this value:\n\nsuitability_threshold &lt;- 0.3\n\n\n\n\n\n\n\nNoteThreshold selection in habitat models\n\n\n\n\n\nIdeally, thresholds for habitat suitability models would be derived from model training data using statistical methods like “minimum training presence” (the lowest suitability at which the species was observed) or “maximum sum of sensitivity and specificity” (Liu et al. 2005). However, these approaches require access to the original occurrence data and model outputs, which we don’t have for these spawning ground predictions.\nWhen such data aren’t available, common practice provides a pragmatic alternative. Values around 0.3 frequently appear as the boundary between “poor/unsuitable” and “marginal” habitat across various systems, from wildlife assessments (Brooks 1997) to recent plant distribution studies (Kim et al. 2025). We adopt this threshold to focus on areas with at least moderate suitability.\n\n\n\n\n\nExploring Spawning Ground Suitability\nLet’s examine the distribution of habitat suitability values. We iterate over each layer using map(), extract cell values as a vector with terra::values(), and calculate summary statistics:\n\n# Calculate summary statistics for each species\nsuitability_summary &lt;- map(names(spawning), \\(sp) {\n  vals &lt;- spawning[[sp]] |&gt; values() |&gt; na.omit()\n  tibble(\n    species = sp,\n    n = length(vals),\n    min = min(vals),\n    max = max(vals),\n    mean = mean(vals),\n    median = median(vals),\n    pct_above_threshold = sum(vals &gt; suitability_threshold) / length(vals) * 100\n  )\n}) |&gt;\n  list_rbind()\n\nsuitability_summary |&gt;\n  mutate(across(where(is.numeric) & !n, ~ round(.x, 3))) |&gt;\n  knitr::kable(\n    col.names = c(\n      \"Species\",\n      \"n\",\n      \"Min\",\n      \"Max\",\n      \"Mean\",\n      \"Median\",\n      paste0(\"% &gt; \", suitability_threshold)\n    ),\n    caption = \"Spawning ground suitability statistics by species\"\n  )\n\n\nSpawning ground suitability statistics by species\n\n\nSpecies\nn\nMin\nMax\nMean\nMedian\n% &gt; 0.3\n\n\n\n\nWhiting\n48700\n0\n1.000\n0.219\n0.143\n20.877\n\n\nHaddock\n48259\n0\n0.939\n0.072\n0.033\n2.518\n\n\n\n\n\nThe two species show markedly different suitability distributions. Whiting spawning grounds have higher mean suitability (0.22 vs 0.07) and a much larger proportion of cells above our threshold (20.9% vs 2.5%). This indicates that the whiting model predicts more extensive suitable habitat, while haddock suitability is concentrated in a smaller area with most cells showing low values.\n\n\nVisualizing Spawning Grounds\nLet’s visualize the spatial distribution of spawning suitability. We use geom_spatraster_contour() to add a contour line at our threshold value, delineating areas of suitable habitat:\n\nggplot() +\n  geom_spatraster(data = spawning) +\n  geom_spatraster_contour(\n    data = spawning,\n    breaks = suitability_threshold,\n    color = \"white\",\n    linewidth = 0.3\n  ) +\n  facet_wrap(~lyr, ncol = 2) +\n  scale_fill_viridis_c(\n    name = \"Habitat\\nsuitability\",\n    na.value = \"white\",\n    option = \"mako\"\n  ) +\n  labs(\n    title = \"Gadoid Spawning Grounds\",\n    subtitle = paste0(\n      \"UK Essential Fish Habitat predictions (threshold = \",\n      suitability_threshold,\n      \")\"\n    )\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text = element_text(size = 7),\n    legend.position = \"bottom\"\n  )\n\n\n\n\n\n\n\nFigure 3: Spawning ground suitability for gadoid fish in the North Sea. White contour marks our suitability threshold.\n\n\n\n\n\nThe maps confirm what the statistics suggested: whiting spawning grounds show distinct hotspots (lighter areas) particularly in the western and southern North Sea, while haddock suitability is more uniformly low across the coverage area with only subtle variation in the northern region."
  },
  {
    "objectID": "tutorials/tutorial-02.html#aligning-rasters-for-analysis",
    "href": "tutorials/tutorial-02.html#aligning-rasters-for-analysis",
    "title": "2: Copepods and Fish Spawning Grounds",
    "section": "Aligning Rasters for Analysis",
    "text": "Aligning Rasters for Analysis\nTo compare copepod and spawning ground data, we need to align them to a common grid. First, let’s check whether alignment is necessary by comparing each raster’s properties. We use terra::res() to check the resolution (cell size), terra::crs() to check the coordinate reference system, and terra::is.lonlat() to check whether the CRS uses geographic coordinates (degrees). By default, crs() returns the full WKT (Well-Known Text) string which is verbose; setting describe = TRUE returns a data frame with parsed CRS details including the name and EPSG code:\n\n# Compare coordinate reference systems (name and EPSG code)\ncrs(copepods, describe = TRUE)[, c(\"name\", \"authority\", \"code\")]\n\n\n  \n\n\ncrs(spawning, describe = TRUE)[, c(\"name\", \"authority\", \"code\")]\n\n\n  \n\n\n\n# Check if using geographic coordinates (degrees)\nis.lonlat(copepods)\n#&gt; [1] TRUE\nis.lonlat(spawning)\n#&gt; [1] FALSE\n\n# Compare resolutions\nres(copepods)\n#&gt; [1] 0.1 0.1\nres(spawning)\n#&gt; [1] 6330.761 5462.130\n\nThe copepods data uses WGS84 (geographic coordinates) while the spawning data uses Web Mercator (EPSG:3857, a projected CRS). The is.lonlat() results confirm that copepods uses degrees while spawning does not - projected CRS typically use meters. This means the resolution values aren’t directly comparable since they’re in different units.\nTo align the rasters, we need to choose a target grid. Two considerations guide this choice:\n\nResolution: Best practice is to resample to the coarser resolution to avoid creating artificial detail (see Pebesma and Bivand 2023, Ch. 5). The copepod grid at 0.1° translates to roughly 6-11 km cells at North Sea latitudes, while the spawning grid is approximately 6 km - similar resolutions.\nCRS suitability: Web Mercator (EPSG:3857) is designed for web mapping, not spatial analysis - it severely distorts areas at higher latitudes like the North Sea. WGS84, while not ideal for area calculations, avoids this distortion.\n\nSince the resolutions are similar and the copepod data drives our analysis question, we resample spawning to match the copepod grid.\nWe use terra::project() to reproject the spawning data onto the copepod grid. The first argument is the raster to transform, the second is the target raster (whose CRS, extent, and resolution will be matched), and method specifies the resampling algorithm - \"bilinear\" interpolates values from the four nearest cells, which is appropriate for continuous data like suitability scores.\n\nspawning_aligned &lt;- project(spawning, copepods, method = \"bilinear\")\n\n# Verify alignment\nres(spawning_aligned)\n#&gt; [1] 0.1 0.1\ncrs(spawning_aligned, describe = TRUE)$name\n#&gt; [1] \"WGS 84\"\nall(res(copepods) == res(spawning_aligned))\n#&gt; [1] TRUE\n\n\n\n\n\n\n\nNoteWhy WGS84 is acceptable here\n\n\n\nIn Tutorial 1, we emphasized that vector spatial operations requiring accurate area or distance calculations should use an appropriate projected CRS. For raster analysis, the situation is different.\nWhen we calculate zonal statistics (e.g., mean copepod abundance within spawning areas), we’re averaging cell values - each cell contributes equally regardless of its geographic area. This is appropriate when the underlying data was modeled on the same grid, as the values already represent conditions at that cell’s location.\nThere is a subtlety: in WGS84, cells don’t represent equal areas - a 0.1° cell near Scotland covers less area than one near the English Channel. For area-weighted analyses or when comparing total quantities across latitudes, this matters. But for our analysis - characterizing typical copepod conditions within spawning grounds - treating cells equally is reasonable, especially within the relatively narrow latitude range of the North Sea (~50-62°N)."
  },
  {
    "objectID": "tutorials/tutorial-02.html#characterizing-copepod-conditions",
    "href": "tutorials/tutorial-02.html#characterizing-copepod-conditions",
    "title": "2: Copepods and Fish Spawning Grounds",
    "section": "Characterizing Copepod Conditions",
    "text": "Characterizing Copepod Conditions\nNow we can extract copepod statistics within each species’ spawning grounds.\n\nBuilding a Tidy Data Frame\nTo analyze the relationship between spawning suitability and copepod abundance, we first extract all raster values into a tidy data frame. We combine the aligned spawning and copepod rasters using c(), then use tidyterra::as_tibble() to extract cell values as a tibble with one column per layer:\n\n# Combine all layers and extract values as a tibble\ncell_values &lt;- c(spawning_aligned, copepods) |&gt;\n  tidyterra::as_tibble()\n\ncell_values\n\n\n  \n\n\n\nNow we reshape this wide data frame into tidy (long) format. We use two pivot_longer() calls to create fish and copepod columns, classify cells as above or below our suitability threshold, and finally drop any rows with missing values using drop_na():\n\ncell_data &lt;- cell_values |&gt;\n  pivot_longer(\n    cols = c(Whiting, Haddock),\n    names_to = \"fish\",\n    values_to = \"suitability\"\n  ) |&gt;\n  pivot_longer(\n    cols = c(Calanus, Temora, Large, Small),\n    names_to = \"copepod\",\n    values_to = \"abundance\"\n  ) |&gt;\n  mutate(suitable = suitability &gt;= suitability_threshold) |&gt;\n  drop_na()\n\ncell_data\n\n\n  \n\n\n\nEach row now represents one cell-fish-copepod combination, with the suitability value, copepod abundance, and whether the cell exceeds our suitability threshold. The drop_na() removes cells where either the spawning suitability or copepod abundance is missing (NA values in the copepod data indicate areas outside CPR survey coverage).\n\n\nSummary Statistics\nWith our tidy data frame, calculating summary statistics by group is straightforward using group_by() and summarise(). We group by fish species, habitat suitability, and copepod type, then calculate the mean and standard deviation of copepod abundance for each combination. The result is reshaped to a wider format for easier reading:\n\ncell_data |&gt;\n  # Group by all classification variables\n  group_by(fish, suitable, copepod) |&gt;\n  # Calculate summary statistics for each group\n  summarise(\n    mean = mean(abundance),\n    sd = sd(abundance),\n    n = n(),\n    .groups = \"drop\"\n  ) |&gt;\n  # Convert logical to readable labels\n  mutate(suitable = if_else(suitable, \"Suitable\", \"Unsuitable\")) |&gt;\n  # Reshape to wide format for display\n  select(fish, suitable, copepod, mean) |&gt;\n  pivot_wider(names_from = copepod, values_from = mean) |&gt;\n  mutate(across(where(is.numeric), ~ round(.x, 3))) |&gt;\n  knitr::kable(\n    col.names = c(\"Fish\", \"Habitat\", \"Calanus\", \"Temora\", \"Large\", \"Small\")\n  )\n\n\n\nTable 1: Copepod relative abundance in suitable vs unsuitable spawning habitat\n\n\n\n\n\n\nFish\nHabitat\nCalanus\nTemora\nLarge\nSmall\n\n\n\n\nHaddock\nUnsuitable\n0.392\n0.894\n2.416\n0.855\n\n\nHaddock\nSuitable\n0.146\n0.442\n1.036\n0.036\n\n\nWhiting\nUnsuitable\n0.435\n0.939\n2.459\n0.825\n\n\nWhiting\nSuitable\n0.230\n0.700\n2.174\n0.897\n\n\n\n\n\n\n\n\n\n\nComparing Suitable vs Unsuitable Habitat\nNow that we have our tidy data frame with habitat classifications, we can compare copepod conditions between suitable and unsuitable spawning areas. We reuse the same group_by() and summarise() pattern from the table above, but this time pipe the results directly into ggplot2 for visualization. The bar chart uses geom_col() with position = \"dodge\" to place bars side-by-side, and geom_errorbar() to show standard deviations. We facet by fish species to compare patterns:\n\ncell_data |&gt;\n  group_by(fish, suitable, copepod) |&gt;\n  summarise(\n    mean = mean(abundance),\n    sd = sd(abundance),\n    .groups = \"drop\"\n  ) |&gt;\n  mutate(suitable = if_else(suitable, \"Suitable\", \"Unsuitable\")) |&gt;\n  ggplot(aes(x = copepod, y = mean, fill = suitable)) +\n  geom_col(position = \"dodge\") +\n  geom_errorbar(\n    aes(ymin = mean - sd, ymax = mean + sd),\n    position = position_dodge(width = 0.9),\n    width = 0.25\n  ) +\n  facet_wrap(~fish) +\n  scale_fill_manual(\n    values = c(\"Suitable\" = \"#228B22\", \"Unsuitable\" = \"grey60\"),\n    name = \"Habitat\"\n  ) +\n  labs(\n    title = \"Copepod Conditions by Habitat Suitability\",\n    subtitle = paste0(\n      \"Mean ± SD relative abundance (threshold = \",\n      suitability_threshold,\n      \")\"\n    ),\n    x = \"Copepod type\",\n    y = \"Mean relative abundance\"\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    legend.position = \"bottom\"\n  )\n\n\n\n\n\n\n\nFigure 4: Copepod relative abundance in suitable vs unsuitable spawning habitat\n\n\n\n\n\nAn interesting pattern emerges: unsuitable spawning habitat tends to have higher copepod abundance than suitable habitat. This trend is particularly striking for haddock, where unsuitable areas show substantially higher mean abundance across all copepod types. For whiting, the pattern is similar but less pronounced, with the exception of Temora where suitable habitat actually shows slightly higher abundance. We’ll explore what might explain this in the Discussion.\n\n\nExploring the Full Suitability Gradient\nThe bar chart shows averages, but the relationship between suitability and copepod abundance may be more nuanced. Let’s examine how copepod abundance varies across the full range of suitability values:\n\nggplot(cell_data, aes(x = suitability, y = abundance, color = fish)) +\n  geom_point(alpha = 0.15, size = 0.8) +\n  geom_vline(\n    xintercept = suitability_threshold,\n    linetype = \"dashed\",\n    color = \"black\",\n    linewidth = 0.6\n  ) +\n  geom_smooth(\n    method = \"loess\",\n    se = TRUE,\n    color = \"grey40\",\n    fill = \"grey80\",\n    linewidth = 0.8\n  ) +\n  facet_grid(copepod ~ fish, scales = \"free_y\") +\n  scale_color_manual(values = c(\"Haddock\" = \"#E69F00\", \"Whiting\" = \"#56B4E9\")) +\n  labs(\n    title = \"Spawning Habitat Suitability vs Copepod Abundance\",\n    x = \"Habitat suitability\",\n    y = \"Copepod relative abundance\"\n  ) +\n  theme_minimal() +\n  theme(\n    strip.text = element_text(size = 9, face = \"bold\"),\n    axis.text = element_text(size = 7),\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\n\nFigure 5: Spawning habitat suitability vs copepod relative abundance across all grid cells\n\n\n\n\n\nThe scatter plots show the full range of variation in the data. The vertical dashed line marks our suitability threshold (0.3). Various patterns are visible - declining trends, flat regions, and even upticks at higher suitability values for some fish-copepod combinations. We interpret these patterns in the Discussion."
  },
  {
    "objectID": "tutorials/tutorial-02.html#spatial-overlays",
    "href": "tutorials/tutorial-02.html#spatial-overlays",
    "title": "2: Copepods and Fish Spawning Grounds",
    "section": "Spatial Overlays",
    "text": "Spatial Overlays\nFinally, let’s create an interactive map to explore the spatial relationship between copepod abundance and spawning grounds visually. This allows us to see how the copepod distributions align geographically with the predicted spawning areas.\n\nPreparing Spawning Ground Boundaries\nFirst, we need to convert our continuous suitability rasters into polygon boundaries showing “suitable” areas. We create binary masks by applying our threshold, then convert to polygons using terra::as.polygons(). This function creates vector polygons from raster cells, grouping adjacent cells with the same value. We then convert to sf objects and filter to keep only the suitable areas (value = 1):\n\n# Create binary masks: TRUE where suitability &gt;= threshold\nwhiting_suitable &lt;- spawning_aligned$Whiting &gt;= suitability_threshold\nhaddock_suitable &lt;- spawning_aligned$Haddock &gt;= suitability_threshold\n\n# Convert raster masks to polygon boundaries\n# as.polygons() groups adjacent cells with the same value into polygons\nwhiting_poly &lt;- as.polygons(whiting_suitable) |&gt;\n  st_as_sf() |&gt;\n  filter(Whiting == 1)  # Keep only suitable areas\n\nhaddock_poly &lt;- as.polygons(haddock_suitable) |&gt;\n  st_as_sf() |&gt;\n  filter(Haddock == 1)\n\n\n\nBuilding the Interactive Map\nWe use the tmap package in “view” mode to create an interactive Leaflet map. Maps in tmap are built by combining a tm_shape() call (which specifies the spatial data) with one or more layer functions like tm_raster() or tm_borders() (which specify how to display it). Multiple shapes and layers are combined with +.\nThe key feature here is layer group controls: by setting group.control = \"radio\" on each copepod layer, we create mutually exclusive radio buttons that let users switch between copepod types. This avoids visual clutter from overlapping semi-transparent rasters.\nThe map components are:\n\ntm_basemap(): A neutral grey basemap that won’t distract from our data. We set group.control = \"none\" so it doesn’t appear in the layer controls.\ntm_raster(): Each copepod layer with consistent color scaling. The group parameter sets the label shown in the radio button control. The legend title includes both the copepod name and “(relative abundance)” so users always know what they’re viewing.\ntm_borders(): Spawning ground boundaries as polygon outlines. Grey for whiting, cyan for haddock, both always visible (group.control = \"none\").\ntm_add_legend(): A manual legend for the spawning ground boundaries, since tm_borders() with a fixed color doesn’t automatically generate one.\n\n\n# Switch tmap to interactive (Leaflet) mode\ntmap_mode(\"view\")\n\n# Build the map layer by layer\ntm_basemap(\"Esri.WorldGrayCanvas\", group.control = \"none\") +\n  # Copepod raster layers with radio button controls\n  tm_shape(copepods$Calanus) +\n  tm_raster(\n    col.scale = tm_scale_continuous(values = \"plasma\"),\n    col.legend = tm_legend(title = \"Calanus\\n(relative abundance)\"),\n    group.control = \"radio\"\n  ) +\n  tm_shape(copepods$Temora) +\n  tm_raster(\n    col.scale = tm_scale_continuous(values = \"plasma\"),\n    col.legend = tm_legend(title = \"Temora\\n(relative abundance)\"),\n    group.control = \"radio\"\n  ) +\n  tm_shape(copepods$Large) +\n  tm_raster(\n    col.scale = tm_scale_continuous(values = \"plasma\"),\n    col.legend = tm_legend(title = \"Large copepods\\n(relative abundance)\"),\n    group = \"Large copepods\",  # Override default \"Large\" for clearer label\n    group.control = \"radio\"\n  ) +\n  tm_shape(copepods$Small) +\n  tm_raster(\n    col.scale = tm_scale_continuous(values = \"plasma\"),\n    col.legend = tm_legend(title = \"Small copepods\\n(relative abundance)\"),\n    group = \"Small copepods\",  # Override default \"Small\" for clearer label\n    group.control = \"radio\"\n  ) +\n  # Spawning ground boundaries (always visible)\n  tm_shape(whiting_poly) +\n  tm_borders(col = \"grey\", lwd = 2, group.control = \"none\") +\n  tm_shape(haddock_poly) +\n  tm_borders(col = \"cyan\", lwd = 2, group.control = \"none\") +\n  # Manual legend for spawning ground boundaries\n  tm_add_legend(\n    type = \"lines\",\n    labels = c(\"Whiting spawning\", \"Haddock spawning\"),\n    col = c(\"grey\", \"cyan\"),\n    lwd = 2,\n    title = \"Spawning grounds\"\n  )\n\n\n\n\n\n\n\nTipPlotting multi-layer rasters\n\n\n\n\n\nYou can pass a multi-layer raster directly to tm_raster():\ntm_shape(copepods) +\n  tm_raster()\nThis creates facets (separate panels for each layer), similar to using facet_wrap() with ggplot2. Here we use separate tm_shape() calls because we want a single map with switchable layers.\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipInteracting with the map\n\n\n\nClick the layer control icon (stacked squares) in the top right corner to reveal the radio buttons. Select different copepod types to see how their spatial distributions compare to the spawning ground boundaries. You can also zoom and pan to explore specific areas in detail."
  },
  {
    "objectID": "tutorials/tutorial-02.html#discussion",
    "href": "tutorials/tutorial-02.html#discussion",
    "title": "2: Copepods and Fish Spawning Grounds",
    "section": "Discussion",
    "text": "Discussion\nThe clearest pattern from our analysis is that predicted spawning grounds tend to have lower copepod relative abundance compared to unsuitable areas (Figure 4). This pattern is most consistent for Calanus and large copepods across both fish species. Small copepods show weaker differences, and Temora shows a reversed pattern for whiting (slightly higher in suitable areas). The scatter plots (Figure 5) show more varied patterns at finer scales, but these should not be over-interpreted as we performed exploratory analysis only (summaries and visualizations, not formal statistical testing).\nBoth copepod distributions and spawning suitability show distinct spatial structure in the North Sea. Copepods vary with oceanographic gradients (Calanus higher offshore, Temora and small copepods higher in coastal areas), while spawning suitability reflects physical habitat factors. When two spatially structured variables are overlaid, apparent patterns can emerge from geographic coincidence alone.\nThis lack of a clear ecological relationship actually makes sense. Adult fish select spawning sites based on physical factors such as temperature, depth, substrate type, and hydrography (González-Irusta and Wright 2016), not prey availability. Copepod abundance matters more for larvae after hatching than for spawning adults. The ecologically relevant question is whether larvae encounter sufficient prey during early development (the “match-mismatch” hypothesis, Endo et al. (2022)), which depends on nursery ground conditions and timing, not spawning site characteristics.\nMore ecologically relevant analyses (e.g., copepod conditions on nursery grounds) were limited by spatial coverage gaps between available EMODnet datasets.\nDespite the limited ecological conclusions, this tutorial successfully demonstrates the technical workflow for combining EMODnet WCS raster layers: accessing multi-dimensional coverages, aligning different resolutions and coordinate systems, building tidy data frames from raster values, and visualizing spatial relationships. These skills transfer directly to analyses where the ecological question and available data are better matched."
  },
  {
    "objectID": "tutorials/tutorial-02.html#what-youve-learned",
    "href": "tutorials/tutorial-02.html#what-youve-learned",
    "title": "2: Copepods and Fish Spawning Grounds",
    "section": "What You’ve Learned",
    "text": "What You’ve Learned\nThis tutorial demonstrated key skills for working with EMODnet raster data:\n\nExploring WCS services: Using emdn_get_coverage_info() to understand available data\nTemporal subsetting: Selecting specific time slices from multi-dimensional coverages\nMulti-source integration: Combining rasters from different EMODnet services\nResolution handling: Aligning data with different spatial resolutions using project()\nZonal statistics: Extracting environmental conditions within habitat areas\nVisualization: Creating informative maps with raster data and contour overlays\n\nThese skills transfer to many marine spatial analyses where you need to characterize environmental conditions across habitats or species distributions."
  },
  {
    "objectID": "tutorials/tutorial-02.html#further-resources",
    "href": "tutorials/tutorial-02.html#further-resources",
    "title": "2: Copepods and Fish Spawning Grounds",
    "section": "Further Resources",
    "text": "Further Resources\n\nContinuous Plankton Recorder Survey: www.cprsurvey.org for long-term plankton monitoring with raw data access\nICES: ices.dk for stock assessments and biological data for North Sea fish\nEMODnet Biology Portal: emodnet.ec.europa.eu/en/biology for additional species distribution products\n\nReady for more? Continue to Tutorial 3 to learn how to combine WFS vector data with WCS raster data for integrated analyses."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "",
    "text": "Learn how to access and analyze marine biological and environmental data from EMODnet using R. These hands-on tutorials guide you through real-world marine spatial analysis workflows, from accessing data via web services to creating publication-ready visualizations.\nWhether you’re investigating marine protected areas, exploring species distributions, or analyzing biodiversity change, these tutorials provide reproducible code and practical examples you can adapt to your own research questions.\n\n\n\n\n\n\nTipNew to geospatial analysis?\n\n\n\nIf you’re unfamiliar with spatial data concepts, coordinate systems, or the difference between vector and raster data, start with our Geospatial Concepts page."
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "",
    "text": "Learn how to access and analyze marine biological and environmental data from EMODnet using R. These hands-on tutorials guide you through real-world marine spatial analysis workflows, from accessing data via web services to creating publication-ready visualizations.\nWhether you’re investigating marine protected areas, exploring species distributions, or analyzing biodiversity change, these tutorials provide reproducible code and practical examples you can adapt to your own research questions.\n\n\n\n\n\n\nTipNew to geospatial analysis?\n\n\n\nIf you’re unfamiliar with spatial data concepts, coordinate systems, or the difference between vector and raster data, start with our Geospatial Concepts page."
  },
  {
    "objectID": "index.html#what-youll-learn",
    "href": "index.html#what-youll-learn",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "What You’ll Learn",
    "text": "What You’ll Learn\nThese tutorials demonstrate how to:\n\nAccess marine data programmatically using EMODnet’s web services (WFS and WCS)\nWork with vector data representing species occurrences, habitat boundaries, and human activities\nAnalyze raster data including bathymetry, species distributions, and environmental variables\nIntegrate multiple data sources from EMODnet, Copernicus Marine Service, and trait databases\nApply spatial operations such as intersection, masking, and point extraction\nVisualize spatial patterns relevant to marine conservation and management\n\nBy the end of these tutorials, you’ll be able to independently access, analyze, and visualize EMODnet data for your own marine research questions."
  },
  {
    "objectID": "index.html#tutorial-series",
    "href": "index.html#tutorial-series",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "Tutorial Series",
    "text": "Tutorial Series\n\n\n\n\n\n1 Protected Areas and Subsea Infrastructure\nIdentifying Protected Areas Affected by Subsea Infrastructure in the North Sea\nDifficulty: Beginner | Time: ~45 minutes | Data: WFS (vector)\n\nLearn the fundamentals of accessing EMODnet WFS data by identifying marine protected areas that overlap with subsea infrastructure like pipelines and cables. This tutorial introduces spatial intersection operations and provides a foundation for marine spatial planning analyses.\nYou’ll work with: Marine protected area boundaries, pipeline locations, subsea cable networks, platform locations\n\n\n\nStart Tutorial 1\n\n\n\n\n\n\n2 Copepods and Fish Spawning Grounds\nCharacterizing Zooplankton Conditions Across Gadoid Spawning Grounds in the North Sea\nDifficulty: Beginner | Time: ~45 minutes | Data: WCS (raster)\n\nDiscover how to access and analyze gridded environmental data using EMODnet WCS services. Characterize copepod distributions across whiting and haddock spawning grounds, learning raster alignment, tidy data extraction, and interactive map visualization.\nYou’ll work with: Copepod relative abundance grids, fish spawning ground predictions\n\n\n\nStart Tutorial 2\n\n\n\n\n\n\n3 Biodiversity Change and Depth\nRelating Marine Biodiversity Change to Depth in the North Sea\nDifficulty: Intermediate | Time: ~60 minutes | Data: WFS + WCS (vector + raster)\n\nCombine vector and raster data to investigate environmental drivers of biodiversity change. Extract bathymetric values at biodiversity sampling points and explore relationships between depth and species turnover across the North Sea.\nYou’ll work with: Biodiversity change metrics, bathymetric depth models, vector-raster integration\n\n\n\nStart Tutorial 3\n\n\n\n\n\n\n4 Functional Traits Across Seabed Habitats\nExploring Functional Traits Across Seabed Habitats in the Aegean Sea\nDifficulty: Advanced | Time: ~90 minutes | Data: WFS + WCS + External sources\n\nIntegrate EMODnet data with external trait databases and Copernicus Marine Service environmental data. Investigate how benthic species body size varies across habitat types and environmental gradients in the Aegean Sea.\nYou’ll work with: Benthic species occurrences, seabed habitat maps, trait databases, temperature reanalysis data\n\n\n\nStart Tutorial 4"
  },
  {
    "objectID": "index.html#who-these-tutorials-are-for",
    "href": "index.html#who-these-tutorials-are-for",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "Who These Tutorials Are For",
    "text": "Who These Tutorials Are For\nThese tutorials are designed for:\n\nMarine researchers working with spatial data on species distributions, habitats, or human activities\nConservation practitioners conducting marine spatial planning, MPA assessments, or environmental impact analyses\nData scientists interested in applying geospatial methods to marine applications\nGraduate students learning marine ecology, spatial analysis, or data science\nPolicy analysts requiring evidence-based spatial information for marine management"
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "Prerequisites",
    "text": "Prerequisites\nTo get the most from these tutorials, you should have:\nR Programming:\n\nBasic to intermediate R skills (working with data frames, installing packages, running functions)\nFamiliarity with the tidyverse is helpful but not required\nExperience with RStudio or similar R development environment\n\nGeospatial Background:\n\nUnderstanding of basic spatial concepts (coordinates, projections, spatial data types)\nAwareness of vector vs. raster data\nFamiliarity with common spatial operations\n\n\n\n\n\n\n\nNote\n\n\n\nIf you’re new to geospatial analysis, visit our Geospatial Concepts page for an introduction to key concepts before starting the tutorials."
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "Getting Started",
    "text": "Getting Started\n\nInstallation\nInstall the required packages using the following code:\n\n# Install packages from CRAN\ninstall.packages(c(\n    \"emodnet.wfs\",\n    \"sf\",\n    \"terra\",\n    \"dplyr\",\n    \"ggplot2\",\n    \"tmap\"\n))\n\n# Install emodnet.wcs' latest version (not yet on CRAN)\ninstall.packages('emodnet.wcs', repos = c('https://emodnet.r-universe.dev', 'https://cloud.r-project.org'))\n\n\n\nQuick Start\n\nNew to geospatial analysis? → Start with Geospatial Concepts\nReady to dive in? → Begin with Tutorial 1 to learn WFS basics\nInterested in raster analysis? → Jump to Tutorial 2 for WCS workflows\nWant to combine data sources? → Try Tutorial 3 or Tutorial 4"
  },
  {
    "objectID": "index.html#resources-and-links",
    "href": "index.html#resources-and-links",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "Resources and Links",
    "text": "Resources and Links\n\nEMODnet Resources\n\nEMODnet Biology Portal - Access marine biological data\nEMODnet Seabed Habitats - Habitat maps and classifications\nEMODnet Bathymetry - Depth data and terrain models\nEMODnet Human Activities - Infrastructure and activity data\n\n\n\nR Package Documentation\n\nemodnet.wfs on GitHub - Access WFS vector data\nemodnet.wcs on GitHub - Access WCS raster data\nsf package - Spatial vector data in R\nterra package - Spatial raster data in R\n\n\n\nLearning Resources\n\nGeocomputation with R - Comprehensive guide to spatial analysis in R\nSpatial Data Science - Spatial data methods and applications\nsf package vignettes - Detailed sf documentation"
  },
  {
    "objectID": "index.html#about-this-project",
    "href": "index.html#about-this-project",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "About This Project",
    "text": "About This Project\nThese tutorials are part of the EMODnet Biology initiative. Learn more about the project, contributors, and funding on the About page."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "EMODnet Biology is the biological data portal of the European Marine Observation and Data Network (EMODnet). EMODnet is a network of European organisations working together to assemble marine data, data products, and metadata from diverse sources in a standardized way.\nEMODnet Biology provides free and open access to marine biological observations, species distributions, and biodiversity data from European seas. The portal aggregates data from diverse sources including research institutions, monitoring programmes, and citizen science initiatives, making it easily accessible for marine research, policy-making, and conservation efforts."
  },
  {
    "objectID": "about.html#about-emodnet-biology",
    "href": "about.html#about-emodnet-biology",
    "title": "About",
    "section": "",
    "text": "EMODnet Biology is the biological data portal of the European Marine Observation and Data Network (EMODnet). EMODnet is a network of European organisations working together to assemble marine data, data products, and metadata from diverse sources in a standardized way.\nEMODnet Biology provides free and open access to marine biological observations, species distributions, and biodiversity data from European seas. The portal aggregates data from diverse sources including research institutions, monitoring programmes, and citizen science initiatives, making it easily accessible for marine research, policy-making, and conservation efforts."
  },
  {
    "objectID": "about.html#about-this-tutorial-initiative",
    "href": "about.html#about-this-tutorial-initiative",
    "title": "About",
    "section": "About This Tutorial Initiative",
    "text": "About This Tutorial Initiative\nThese tutorials were developed as part of the EMODnet Biology initiative to demonstrate how researchers, students, and practitioners can access and analyze EMODnet data programmatically using R. By providing practical, reproducible workflows using real marine data, we aim to:\n\nLower barriers to accessing and using EMODnet biological and environmental data\nDemonstrate the value of web services (WFS and WCS) for programmatic data access\nShowcase real-world applications relevant to marine conservation and spatial planning\nBuild capacity in marine spatial data science across the research community\n\nThe tutorials highlight how EMODnet data can be integrated with other European marine data infrastructures, such as Copernicus Marine Service, to support evidence-based marine management and research."
  },
  {
    "objectID": "about.html#emodnet-web-services",
    "href": "about.html#emodnet-web-services",
    "title": "About",
    "section": "EMODnet Web Services",
    "text": "EMODnet Web Services\nEMODnet provides standardized geospatial web services following Open Geospatial Consortium (OGC) specifications. These services are maintained by the EMODnet thematic portals (Biology, Bathymetry, Seabed Habitats, Human Activities, etc.), each operated by a consortium of European marine research institutions.\nEach thematic portal is responsible for:\n\nAggregating data from multiple sources across Europe\nStandardizing and quality-controlling the data\nHosting and maintaining the web service infrastructure\nEnsuring long-term data preservation and access\n\nThis infrastructure enables researchers and practitioners to programmatically access marine data without needing to manage large file downloads or navigate multiple data repositories."
  },
  {
    "objectID": "about.html#the-r-packages",
    "href": "about.html#the-r-packages",
    "title": "About",
    "section": "The R Packages",
    "text": "The R Packages\nThese tutorials demonstrate two R packages developed specifically for accessing EMODnet data services:\nemodnet.wfs provides programmatic access to EMODnet’s Web Feature Service (WFS) endpoints, enabling users to retrieve vector data such as species occurrences, habitat boundaries, and infrastructure locations directly into R.\nemodnet.wcs enables access to EMODnet’s Web Coverage Service (WCS) endpoints, allowing users to download raster data such as depth models, species distributions, and environmental variables.\nBoth packages simplify data discovery, querying, and retrieval, making EMODnet’s extensive data holdings readily available for spatial analysis in R."
  },
  {
    "objectID": "about.html#acknowledgments-and-funding",
    "href": "about.html#acknowledgments-and-funding",
    "title": "About",
    "section": "Acknowledgments and Funding",
    "text": "Acknowledgments and Funding\nThese tutorials were developed as part of the EMODnet Biology initiative, funded by the European Commission’s Directorate-General for Maritime Affairs and Fisheries (DG MARE) under the European Maritime and Fisheries Fund (EMFF).\nThe tutorial materials are made available under open licenses to support the broader marine science and data science communities."
  },
  {
    "objectID": "about.html#contributing",
    "href": "about.html#contributing",
    "title": "About",
    "section": "Contributing",
    "text": "Contributing\nWe welcome contributions, suggestions, and feedback! Please visit our GitHub repository to:\n\nReport issues or bugs\nSuggest improvements or new tutorial topics\nSubmit pull requests with corrections or enhancements\n\nFor detailed contribution guidelines, see CONTRIBUTING.md."
  },
  {
    "objectID": "about.html#links-and-resources",
    "href": "about.html#links-and-resources",
    "title": "About",
    "section": "Links and Resources",
    "text": "Links and Resources\n\nEMODnet Biology Portal\nEMODnet Main Portal\nemodnet.wfs Package\nemodnet.wcs Package"
  },
  {
    "objectID": "concepts.html",
    "href": "concepts.html",
    "title": "Geospatial Concepts & Glossary",
    "section": "",
    "text": "This page provides foundational knowledge for working with geospatial marine data. If you’re new to spatial analysis or need a refresher, start here before diving into the tutorials."
  },
  {
    "objectID": "concepts.html#introduction",
    "href": "concepts.html#introduction",
    "title": "Geospatial Concepts & Glossary",
    "section": "",
    "text": "This page provides foundational knowledge for working with geospatial marine data. If you’re new to spatial analysis or need a refresher, start here before diving into the tutorials."
  },
  {
    "objectID": "concepts.html#spatial-data-types",
    "href": "concepts.html#spatial-data-types",
    "title": "Geospatial Concepts & Glossary",
    "section": "Spatial Data Types",
    "text": "Spatial Data Types\nGeospatial data comes in two fundamental forms: vector and raster (Figure 1). Understanding the difference is crucial for choosing the right analysis methods.\n\n\n\n\n\n\n\n\nFigure 1: Comparison of vector (left) and raster (right) representations of the same geographic area\n\n\n\n\n\n\nVector Data\nVector data represents discrete geographic features as points, lines, or polygons. Each feature has a precise location and can carry associated attributes (metadata).\nCommon vector data types:\n\nPoints - Specific locations (e.g., species observation sites, sampling stations, platform locations)\nLines - Linear features (e.g., ship tracks, transects, pipelines)\nPolygons - Enclosed areas (e.g., marine protected areas, habitat boundaries, survey regions)\n\nExamples in EMODnet:\n\nMarine protected area boundaries\nSpecies occurrence records\nSubsea infrastructure (pipelines, cables)\nHabitat classification polygons\nSurvey locations\n\nVector data is ideal when you need exact boundaries, discrete locations, or want to perform operations like counting features or measuring precise distances.\n\n\nRaster Data\nRaster data represents continuous spatial phenomena as a grid of cells (pixels), where each cell contains a value representing a measurement or category.\nCommon raster characteristics:\n\nOrganized as rows and columns of cells\nEach cell has a specific resolution (size)\nValues can be continuous (e.g., depth, temperature) or categorical (e.g., habitat types)\nOften used for environmental variables\n\nExamples in EMODnet:\n\nBathymetric depth models\nSpecies abundance grids\nHabitat suitability indices\nEnvironmental variables (temperature, salinity)\nDerived biodiversity metrics\n\nRaster data excels at representing continuous surfaces, enabling analyses like extracting values at points, calculating zonal statistics, or modeling spatial patterns."
  },
  {
    "objectID": "concepts.html#web-services-for-spatial-data",
    "href": "concepts.html#web-services-for-spatial-data",
    "title": "Geospatial Concepts & Glossary",
    "section": "Web Services for Spatial Data",
    "text": "Web Services for Spatial Data\n\nWhat is a Web Service?\nA web service is a standardized protocol that allows software applications to communicate with databases over the internet. In the context of spatial data, web services provide programmatic access to spatial databases - you send a request (e.g., “give me species observations in this bounding box”) and the service queries its database and returns the data.\nEssentially, web services are spatial databases + standardized communication protocols that let you query and retrieve data through HTTP requests instead of needing direct database access.\nKey benefits:\n\nProgrammatic access - Query data directly from R without manual downloads\nSelective retrieval - Request only specific regions, time periods, or attributes\nAlways current - Access the latest data without managing file versions\nReproducible - Your code documents exactly what data was retrieved\nEfficient - Download only what you need, reducing bandwidth and storage\n\n\n\nHow Web Services Work\nFigure 2 illustrates the typical workflow when accessing EMODnet data through web services.\n\n\n\n\n\n\nflowchart LR\n    A[Your R Script] --&gt;|HTTP Request&lt;br/&gt;bbox, layer, filters| B[EMODnet WFS/WCS Server]\n    B --&gt;|Query| C[(Spatial Database)]\n    C --&gt;|Matching Data| B\n    B --&gt;|Response&lt;br/&gt;GeoJSON/GeoTIFF| A\n    A --&gt;|Load into| D[R Object&lt;br/&gt;sf or terra]\n\n    style A fill:#e1f5ff\n    style B fill:#fff4e1\n    style C fill:#f0f0f0\n    style D fill:#e1f5ff\n\n\n\n\nFigure 2: Web service request flow from R to EMODnet data services\n\n\n\n\n\n\n\nOGC Standards and Spatial Data Types\nThe Open Geospatial Consortium (OGC) has developed different standard protocols optimized for different types of spatial data. The protocols, underlying database technologies, and data formats all differ based on whether you’re working with vector or raster data.\nEMODnet provides two primary types of OGC-compliant geospatial web services, each designed for a specific spatial data type:\n\n\nWFS (Web Feature Service)\nWFS delivers vector data: discrete geographic features with attributes.\nKey characteristics:\n\nReturns features in formats like GeoJSON or GML\nSupports spatial and attribute filtering\nAllows querying specific areas or feature properties\nIdeal for points, lines, and polygons\n\nIn R: Use the emodnet.wfs package to access WFS services. The package simplifies discovering available layers, filtering by extent or attributes, and retrieving data as sf objects.\nWhat information can you access?\nBefore downloading data, WFS services let you discover which feature types (layers) exist and what attributes each layer contains. Once you retrieve data, you receive discrete geographic features (points, lines, polygons) with associated attributes describing those features (e.g., species observations with taxonomic details, protected area boundaries with designation information, infrastructure with operational attributes).\nExample WFS data from EMODnet:\n\nSpecies occurrences and distributions\nMarine protected area boundaries\nInfrastructure features (platforms, pipelines, cables)\nHabitat polygons\n\n\n\nWCS (Web Coverage Service)\nWCS delivers raster data: gridded coverage representing continuous variables.\nKey characteristics:\n\nReturns coverage in formats like GeoTIFF\nSupports spatial and temporal subsetting\nCan extract specific bands from multi-band datasets\nIdeal for environmental layers and modeled surfaces\n\nIn R: Use the emodnet.wcs package to access WCS services. The package handles coverage discovery, spatial/temporal subsetting, and returns data as terra raster objects.\nWhat information can you access?\nBefore downloading data, WCS services provide metadata about available coverages: which datasets exist, their spatial and temporal extent, resolution, coordinate reference systems, and what bands/variables each coverage contains. When you retrieve data, you receive gridded rasters where each cell contains measurements or modeled values for continuous variables (e.g., bathymetric depth, species abundance predictions, habitat suitability indices, environmental measurements).\nExample WCS data from EMODnet:\n\nBathymetric depth models\nSpecies abundance and diversity grids\nHabitat suitability models\nGridded biodiversity metrics\n\n\n\nAdvantages of Web Services\nCompared to direct file downloads, web services offer:\n\nOn-demand access - Get only the data you need, when you need it\nSpatial filtering - Request data for specific regions using bounding boxes\nTemporal subsetting - Extract data for particular time periods\nAlways current - Access the latest data without managing downloads\nReproducibility - Script your data access for transparent, repeatable workflows"
  },
  {
    "objectID": "concepts.html#coordinate-reference-systems-crs",
    "href": "concepts.html#coordinate-reference-systems-crs",
    "title": "Geospatial Concepts & Glossary",
    "section": "Coordinate Reference Systems (CRS)",
    "text": "Coordinate Reference Systems (CRS)\nA Coordinate Reference System defines how coordinates relate to locations on Earth’s surface. Understanding CRS is essential for accurate spatial analysis.\n\nThe Challenge: From 3D Earth to 2D Maps\nEarth is a three-dimensional sphere, but maps and computer screens are two-dimensional. Think of trying to peel an orange and flatten the peel completely - you can’t do it without distorting, stretching, tearing, or overlapping parts of it. This is the fundamental challenge of cartography.\nProjections are different methods of “peeling and flattening” Earth’s surface. Just as there are many ways you could cut and flatten an orange peel (peel it in strips, cut it into wedges, try to keep it in one piece), there are many different projection methods, each making different choices about:\n\nWhere to cut (what regions to split)\nWhat to stretch (which areas get distorted)\nWhat to preserve (angles, areas, distances, or shapes)\n\nThere is no perfect solution - every projection sacrifices something. This is why dozens of projections exist: each is optimized for different purposes and geographic regions.\n\n\n\n\n\n\nNoteSpecifying CRS: EPSG Codes and WKT\n\n\n\nThroughout this page, you’ll see CRS referenced by EPSG codes (e.g., EPSG:4326, EPSG:3857). EPSG stands for the European Petroleum Survey Group (now maintained by the International Association of Oil & Gas Producers), which created a standardized registry assigning unique numeric codes to coordinate reference systems. These codes provide a concise, unambiguous way to specify which CRS you’re using.\nUnder the hood, CRS definitions are stored as WKT (Well-Known Text) strings - a verbose text format that fully describes the coordinate system, datum, units, and other parameters. You’ll occasionally encounter WKT when inspecting spatial objects, but in practice you’ll usually work with EPSG codes which are simpler and map to the full WKT definitions.\n\n\n\n\nGeographic vs Projected CRS\nGeographic Coordinate Systems (Unprojected)\nGeographic CRS don’t actually “flatten” Earth - they describe locations on the 3D spheroid surface using angles (latitude and longitude in degrees). Think of this as leaving the orange intact and describing locations by their angular position from the center.\n\nExample: WGS84 (EPSG:4326) (Figure 3 (a)) - Most common for global marine data and default for EMODnet services\nUnits in degrees, not meters\nGood for storing and sharing data globally\nNot suitable for measurements - a degree of longitude represents different distances at different latitudes (degrees get closer together near the poles)\n\nProjected Coordinate Systems\nProjected CRS actually perform the “flattening” using mathematical transformations. Each projection is a different flattening method with different trade-offs:\n\nWeb Mercator (EPSG:3857) (Figure 3 (b)) - “Peels the orange” by stretching areas increasingly toward the poles. Preserves angles (conformal projection), which historically made it invaluable for maritime navigation - sailors could plot a straight line between two points and maintain a constant compass bearing throughout their journey. However, this comes at the cost of severely distorting areas at high latitudes. Used by most web maps because it makes the whole world fit in a square.\nUTM zones (e.g., EPSG:32631 for UTM 31N) - “Cuts the orange” into 60 vertical strips (zones), each 6° of longitude wide. Each strip is flattened with minimal distortion within that zone. Excellent for regional analysis.\nLambert Azimuthal Equal Area (EPSG:3035) (Figure 3 (c)) - “Flattens the orange” while preserving area relationships. A 100 km² habitat appears as 100 km² on the map, regardless of location. Essential for statistical analyses involving area.\nLocal projections - Optimized flattening methods for specific countries or regions, minimizing distortion in areas of interest.\n\nFigure 3 compares these three coordinate reference systems using Europe and Greenland to illustrate the dramatic differences in how projections distort geographic features.\n\n\n\n\n\n\n\n\n\n\n\n\n(a) WGS84 (EPSG:4326) - Unprojected geographic CRS\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Web Mercator (EPSG:3857) - Projected CRS with severe distortion at high latitudes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) Lambert Azimuthal Equal Area (EPSG:3035) - Projected CRS preserving area\n\n\n\n\n\n\n\n\nFigure 3: Comparison of Europe and Greenland in three different coordinate reference systems. Notice how Greenland’s size changes dramatically across projections - Mercator makes it appear huge through vertical stretching, while LAEA shows its true relative size.\n\n\n\n\n\nWhy This Matters for Marine Spatial Analysis\n\nMeasurements require projected CRS - You can’t accurately calculate distances or areas in degrees (geographic CRS). You need a projection that converts to meters.\nChoose projections for your region - A projection optimized for Europe will distort tropical regions. Use UTM zones for your study area or regional equal-area projections.\nMatch your analysis goal - Use equal-area projections for habitat area calculations, equidistant projections for dispersal distance analyses, or conformal projections for angular relationships.\nAlignment is critical - All datasets in an analysis must use the same CRS, or features won’t align correctly.\n\n\n\nWorking with CRS in R\nBoth major R spatial packages provide CRS transformation functions:\n\nVector data (sf) - Use st_transform() to convert between coordinate systems\nRaster data (terra) - Use project() to reproject raster layers\n\nThe tutorials demonstrate when and how to transform between CRS for different types of spatial analyses."
  },
  {
    "objectID": "concepts.html#bounding-boxes-and-spatial-queries",
    "href": "concepts.html#bounding-boxes-and-spatial-queries",
    "title": "Geospatial Concepts & Glossary",
    "section": "Bounding Boxes and Spatial Queries",
    "text": "Bounding Boxes and Spatial Queries\nA bounding box defines a rectangular area of interest using minimum and maximum coordinates (xmin, ymin, xmax, ymax). Bounding boxes are fundamental to spatial queries, allowing you to request only the data you need from web services rather than downloading entire datasets. Figure 4 shows a bounding box for the North Sea region.\n\n\n\n\n\n\n\n\nFigure 4: Example bounding box for the North Sea region. The blue rectangle shows the spatial extent that would be requested from a web service.\n\n\n\n\n\n\nWhy Use Bounding Boxes?\nBounding boxes enable efficient spatial data retrieval by:\n\nReducing data transfer: Download only features or coverage within your study area\nImproving performance: Smaller data volumes mean faster processing and lower memory requirements\nFocusing analyses: Limit results to relevant geographic regions from the start\nReproducible workflows: Explicit spatial extent definitions make analyses transparent and repeatable\n\n\n\nBounding Boxes in EMODnet Services\nBoth WFS (vector) and WCS (raster) services accept bounding box parameters to spatially filter results. When querying EMODnet data through the emodnet.wfs and emodnet.wcs packages, you specify bounding boxes as numeric vectors with minimum and maximum coordinates. The coordinate reference system for bounding boxes should match the CRS of the data you’re requesting, which varies by layer.\nThe tutorials demonstrate practical bounding box usage for retrieving EMODnet data in specific regions, from local study sites to broader management areas."
  },
  {
    "objectID": "concepts.html#the-geospatial-software-stack",
    "href": "concepts.html#the-geospatial-software-stack",
    "title": "Geospatial Concepts & Glossary",
    "section": "The Geospatial Software Stack",
    "text": "The Geospatial Software Stack\nBefore diving into R packages, it helps to understand the foundational libraries that power geospatial computing. These open-source C/C++ libraries do the heavy lifting. R packages like sf and terra are interfaces that make them accessible from R.\n\nCore Libraries\nGDAL (Geospatial Data Abstraction Library)\nGDAL handles reading and writing spatial data formats. When you load a GeoTIFF, GeoJSON, or Shapefile in R, GDAL is doing the work behind the scenes. It supports over 200 raster and vector formats, making it the universal translator for geospatial data.\n\nWebsite: gdal.org\n\nPROJ\nPROJ handles coordinate transformations and projections. When you convert data from WGS84 (latitude/longitude) to a projected coordinate system like UTM, PROJ performs the mathematical transformation. It maintains an extensive database of coordinate reference system definitions.\n\nWebsite: proj.org\n\nGEOS (Geometry Engine - Open Source)\nGEOS performs geometric operations on vector data: intersections, buffers, unions, validity checks, and more. It works with planar coordinates, treating geometries as flat 2D shapes and using Euclidean geometry. This is fast and works well with projected coordinate systems.\n\nWebsite: libgeos.org\n\ns2 (S2 Geometry Library)\ns2 is Google’s library for spherical geometry. Unlike GEOS, it treats the Earth as a sphere and performs calculations on the curved surface. This is appropriate for geographic CRS like WGS84 (EPSG:4326), where coordinates are in degrees. s2 is geometrically correct for unprojected data but slower than GEOS, stricter about geometry validity, and doesn’t support all operations (e.g., st_simplify() requires GEOS).\n\nWebsite: s2geometry.io\n\n\n\nWhy This Matters\nUnderstanding this stack helps explain behaviours you’ll encounter:\n\nGEOS vs s2: The sf package uses s2 by default for geographic CRS and GEOS for projected CRS. Some operations only work with GEOS, which is why you sometimes see sf_use_s2(FALSE) in code to temporarily switch engines.\nCRS transformations: When you call st_transform(), PROJ does the coordinate conversion.\nFormat support: If R can read a spatial format, it’s because GDAL supports it.\n\n\n\nThe Stack in Practice\nWhen you run a typical spatial workflow in R:\n\nLoading data: GDAL reads the file format\nReprojecting: PROJ transforms coordinates\nSpatial operations: GEOS or s2 performs intersections, buffers, etc.\nSaving results: GDAL writes the output format\n\nThe R packages coordinate these libraries and provide a consistent interface, but the underlying work happens in optimised C/C++ code."
  },
  {
    "objectID": "concepts.html#key-r-packages",
    "href": "concepts.html#key-r-packages",
    "title": "Geospatial Concepts & Glossary",
    "section": "Key R Packages",
    "text": "Key R Packages\n\nsf - Simple Features for R\nThe sf package is the modern standard for vector spatial data in R. It provides an R interface to GDAL (for data I/O), PROJ (for CRS transformations), and GEOS/s2 (for geometric operations).\nKey features:\n\nRepresents spatial data as data frames with geometry columns\nIntegrates with tidyverse workflows\nProvides spatial operations (intersections, buffers, joins, etc.)\nHandles CRS transformations\nReads/writes common spatial formats\n\nWhen to use: Working with points, lines, polygons, or any vector data.\n\n\nterra - Spatial Data Analysis\nThe terra package is the modern replacement for raster, designed for raster spatial data.\nKey features:\n\nHandles single and multi-layer rasters\nPerforms raster algebra and focal operations\nExtracts values at points or within polygons\nManages large datasets efficiently\nSupports raster-vector operations\n\nWhen to use: Working with gridded data, environmental layers, or continuous surfaces."
  },
  {
    "objectID": "concepts.html#understanding-spatial-data-objects-in-r",
    "href": "concepts.html#understanding-spatial-data-objects-in-r",
    "title": "Geospatial Concepts & Glossary",
    "section": "Understanding Spatial Data Objects in R",
    "text": "Understanding Spatial Data Objects in R\nUnderstanding how R represents spatial data internally helps you work more effectively with these packages and troubleshoot issues when they arise.\n\nStructure of sf Objects\nAn sf object is fundamentally a data frame with a special geometry column. This elegant design means you can use familiar data manipulation tools (like dplyr) while preserving spatial information.\nEach row in an sf data frame represents one feature: a discrete geographic entity (point, line, or polygon) with associated descriptive information. Each feature consists of:\n\nGeometry: The spatial component stored in a special list-column (typically named geometry)\nAttributes: Regular data frame columns containing information about that feature\n\nThe key concept: attributes describe the entire spatial object defined in the geometry column. For a point, attributes describe that location. For a polygon, attributes describe the entire enclosed area. For a line, attributes describe the entire linear feature.\nExample with point features (species observations):\n# sf object with benthic species observations\n#   scientificname      datecollected  depth_m              geometry\n# 1 Abra alba           2018-05-12        35   POINT (4.2 52.1)\n# 2 Nephtys hombergii   2018-05-12        35   POINT (4.2 52.1)\n# 3 Lanice conchilega   2018-05-15        42   POINT (4.5 52.3)\nEach feature is one species observation. The attributes (scientificname, datecollected, depth_m) describe what was observed at that specific point location. Row 1 tells us Abra alba was found at coordinates (4.2, 52.1) on 2018-05-12 at 35m depth.\nExample with polygon features (protected areas):\n# sf object with marine protected areas\n#   area_name          designation  year_designated  area_km2   geometry\n# 1 Dogger Bank SAC    Natura 2000       2010         12,331   POLYGON (...)\n# 2 Klaverbank         OSPAR MPA          2016          2,576   POLYGON (...)\n# 3 Cleaver Bank       OSPAR MPA          2016          2,362   POLYGON (...)\nEach feature is one marine protected area. The attributes describe characteristics of the entire polygon area. The Dogger Bank SAC attributes (Natura 2000 designation, 2010 designation year, 12,331 km² area) apply to every point within that polygon boundary.\nTypes of attributes you’ll encounter:\n\nIdentifiers: Names, codes, or IDs (site_code, scientificname, area_name)\nCategorical variables: Classifications or types (habitat_type, designation, infrastructure_type)\nContinuous variables: Measured quantities (sp_lost_beta_repl, sp_gained_beta_repl, beta_total, area_km2)\nTemporal information: Dates or time periods (datecollected, year_designated, period)\n\nWhen retrieving vector data from WFS services using the emodnet.wfs package, you get both geometries and attributes. You can filter and analyze attributes like any data frame while spatial operations work on geometries.\n\n\nStructure of terra Objects\nA terra raster object (SpatRaster) represents gridded spatial data organized as a rectangular array of cells, like a spatial spreadsheet where each cell has a location and one or more values.\nCore components:\n\nDimensions: Number of rows (nrow), columns (ncol), and total cells (ncell). Rasters may also include a temporal dimension when data represents time series or seasonal measurements.\nExtent: The geographic area covered (xmin, xmax, ymin, ymax)\nResolution: The size of each cell (usually in meters or degrees)\nCoordinate Reference System: Defines the spatial reference\nBands: One or more data layers, each containing values for every cell\nCell values: The actual measurements or categories stored in the raster\n\nWhat are Bands?\nBands (also called layers) are individual data grids within a raster dataset. Each band covers the same geographic extent with the same grid structure but contains different information. Rasters can be:\n\nSingle-band: One variable per raster (e.g., bathymetric depth)\nMulti-band: Multiple related variables in one dataset (e.g., abundances for different species, habitat suitability for different life stages, measurements across time periods)\n\nMulti-band rasters are common in marine datasets. EMODnet Biology WCS services may provide copepod abundance grids where each band represents a different species or time period. EMODnet Seabed Habitats provides Essential Fish Habitat models where bands represent spawning grounds, nursery areas, and feeding habitats.\nExample: Single-band raster (bathymetry)\n# class       : SpatRaster\n# dimensions  : 500, 750, 1  (nrow, ncol, nlyr)\n# resolution  : 250, 250  (x, y)\n# extent      : 200000, 387500, 5650000, 5775000  (xmin, xmax, ymin, ymax)\n# crs         : EPSG:3857\n# source      : emodnet_bathymetry.tif\n# name        : depth_m\nThis raster has one band (nlyr = 1) containing bathymetric depth measurements for the North Sea. Each of the 375,000 cells (500 rows × 750 columns) holds a depth value in meters.\nExample: Multi-band raster (copepod relative abundances)\n# class       : SpatRaster\n# dimensions  : 200, 300, 3  (nrow, ncol, nlyr)\n# resolution  : 0.1, 0.1  (x, y)\n# extent      : 0.0, 30.0, 49.0, 69.0  (xmin, xmax, ymin, ymax)\n# crs         : EPSG:4326\n# source      : copepod_abundances.tif\n# names       : Acartia_spp, Temora_longicornis, Calanus_finmarchicus\nThis raster has three bands (nlyr = 3), each representing relative abundance of a different copepod species. All bands share the same extent and resolution but contain different values for each cell. When working with multi-band WCS data, you can extract individual bands, compare patterns across bands, or perform calculations combining multiple bands."
  },
  {
    "objectID": "concepts.html#common-spatial-operations",
    "href": "concepts.html#common-spatial-operations",
    "title": "Geospatial Concepts & Glossary",
    "section": "Common Spatial Operations",
    "text": "Common Spatial Operations\n\nVector Operations (sf)\n\nSpatial intersection - Identifies features that overlap spatially, returning the geometric intersection and combined attributes from both input layers. Useful for finding which features from different datasets occupy the same locations (e.g., protected areas intersecting with infrastructure).\nBuffering - Creates zones of specified distance around features, generating polygons that represent areas within a given radius. Essential for proximity analyses, such as identifying areas within a certain distance of sampling stations or evaluating buffer zones around sensitive habitats.\nSpatial joins - Combines features from two layers based on their spatial relationship (e.g., contains, intersects, within). Allows you to transfer attributes from one layer to another based on location, such as assigning habitat types to species occurrence points or aggregating observations within management zones.\nDistance calculations - Measures distances between features, either point-to-point or between features and geometries. Critical for analyses involving dispersal distances, connectivity assessments, or identifying nearest neighbors.\nArea and length measurements - Calculates geometric properties of features, providing area measurements for polygons and length measurements for lines. Required for quantifying habitat extent, assessing patch sizes, or measuring transect lengths.\n\n\n\nRaster Operations (terra)\n\nExtraction - Retrieves raster cell values at specified point locations or within polygon boundaries. Commonly used to extract environmental variables (depth, temperature, salinity) at species occurrence locations or calculate zonal statistics within habitat polygons.\nMasking - Restricts raster data to areas defined by a polygon or another raster, setting values outside the mask to NA. Useful for limiting analyses to specific regions such as marine protected areas, exclusive economic zones, or specific depth ranges.\nRaster algebra - Performs mathematical operations on raster layers, either within a single layer (e.g., unit conversions, transformations) or across multiple layers (e.g., calculating change between time periods, combining variables). Enables creation of derived metrics like biodiversity change or habitat suitability indices.\nAggregation and resampling - Changes raster resolution by combining or subdividing cells. Aggregation reduces resolution for computational efficiency or matching other datasets, while resampling adjusts resolution or aligns grids from different sources.\nFocal operations - Applies functions to neighborhoods of cells, such as calculating moving window statistics (mean, standard deviation) or smoothing. Used for identifying spatial patterns, creating terrain derivatives, or reducing noise in environmental data."
  },
  {
    "objectID": "concepts.html#data-formats",
    "href": "concepts.html#data-formats",
    "title": "Geospatial Concepts & Glossary",
    "section": "Data Formats",
    "text": "Data Formats\nUnderstanding spatial data formats is important when working with web services, even through R packages. While the emodnet.wfs and emodnet.wcs packages handle data retrieval and automatically load results as R objects (sf for vector, terra for raster), the underlying format requested from the service can have significant practical implications:\nDownload speed and data size - Different formats have different compression and encoding schemes, affecting transfer time and bandwidth usage.\nGeometry types and plotting compatibility - Format choice affects what feature geometries are returned. For example, WFS services may return complex geometry types like MULTISURFACE in GML format, which cannot be easily plotted and require conversion to standard POLYGONs. Requesting GeoJSON format instead often returns simpler geometry types that integrate directly with plotting workflows.\nSaving data locally - After retrieving data from EMODnet, you may want to save it for archival, sharing with collaborators, or use in other software. Understanding format characteristics helps you choose the best option for your needs.\nThe tutorials demonstrate when and how to specify output formats to optimize your workflow.\n\nVector Formats\nGeoJSON (.geojson)\n\nText-based, human-readable\nWidely supported across platforms\nGood for web applications and data sharing\nDefault output from many WFS services\n\nShapefiles (.shp + supporting files)\n\nTraditional GIS format\nRequires multiple files (.shp, .shx, .dbf, .prj)\nWell-supported but has limitations (field name length, size limits)\n\nGeoPackage (.gpkg)\n\nModern, single-file format\nSupports multiple layers\nNo size limits\nRecommended for new projects\n\n\n\nRaster Formats\nGeoTIFF (.tif)\n\nIndustry standard for raster data\nEmbeds spatial reference information\nSupports multiple bands\nEfficient for large datasets\nDefault output from many WCS services\n\nNetCDF (.nc)\n\nMulti-dimensional arrays\nCommon for oceanographic and climate data\nHandles time series and multiple variables\nUsed by Copernicus Marine Service"
  },
  {
    "objectID": "concepts.html#glossary-of-common-terms",
    "href": "concepts.html#glossary-of-common-terms",
    "title": "Geospatial Concepts & Glossary",
    "section": "Glossary of Common Terms",
    "text": "Glossary of Common Terms\n\n\n\n\nTable 1\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nAttribute\nNon-spatial data associated with a feature, stored in data frame columns. Attributes describe characteristics of the entire spatial object (e.g., species name, designation type, measurement values).\n\n\nBand\nAn individual data layer within a raster dataset. Single-band rasters contain one variable; multi-band rasters contain multiple related variables (e.g., different species, time periods, or measurements) sharing the same grid structure.\n\n\nBathymetry\nThe measurement of ocean depth; underwater topography.\n\n\nBenthic\nRelating to organisms living on or in the seafloor.\n\n\nBiodiversity metrics\nQuantitative measures of biological diversity (e.g., species richness, evenness, β-diversity).\n\n\nβ-diversity (Beta diversity)\nTurnover in species composition between locations or time periods.\n\n\nBounding box\nA rectangular area defined by minimum and maximum coordinates, used to specify a region of interest.\n\n\nBuffer\nAn area of specified distance around a geographic feature.\n\n\nCoverage\nA raster dataset served by WCS, representing spatial data as a grid of cells with associated values. Term used in WCS terminology for what is more generally called a raster or gridded dataset.\n\n\nCRS (Coordinate Reference System)\nDefines how coordinates correspond to locations on Earth.\n\n\nEPSG code\nA unique numeric identifier for a coordinate reference system from the EPSG registry (e.g., EPSG:4326 for WGS84). Named after the European Petroleum Survey Group, now maintained by the International Association of Oil & Gas Producers.\n\n\nExtent\nThe geographic area covered by a spatial dataset.\n\n\nFeature\nA discrete geographic entity in vector data (point, line, or polygon) with associated attributes.\n\n\nGeometry\nThe spatial component of a feature (its shape and location).\n\n\nGridded data\nRaster data organized as a regular grid of cells.\n\n\nIntersection\nThe spatial overlap between geographic features.\n\n\nLayer\nA collection of geographic features or a raster dataset representing a theme.\n\n\nMasking\nRestricting raster data to areas defined by a polygon.\n\n\nMPA (Marine Protected Area)\nDesignated ocean area where human activities are restricted for conservation.\n\n\nProjection\nA mathematical transformation converting Earth's curved surface to a flat map.\n\n\nRaster\nGridded spatial data where each cell contains a value.\n\n\nResolution\nThe size of raster cells (e.g., 100m × 100m); smaller cells = finer detail.\n\n\nSpatial join\nCombining features from different layers based on spatial relationships.\n\n\nVector\nSpatial data representing discrete features as points, lines, or polygons.\n\n\nWCS (Web Coverage Service)\nA standard protocol for serving raster data.\n\n\nWFS (Web Feature Service)\nA standard protocol for serving vector data."
  },
  {
    "objectID": "concepts.html#external-resources",
    "href": "concepts.html#external-resources",
    "title": "Geospatial Concepts & Glossary",
    "section": "External Resources",
    "text": "External Resources\n\nBooks and Guides\n\nGeocomputation with R - Comprehensive guide to spatial analysis in R by Robin Lovelace, Jakub Nowosad, and Jannes Muenchow\nSpatial Data Science - Modern approaches to spatial data analysis with R\nterra Documentation - Official terra package manual and tutorials\n\n\n\nPackage Documentation\n\nsf Package Vignettes - Detailed guides for working with vector data\nterra Package Reference - Complete function reference for raster operations\nemodnet.wfs Documentation - Guide to accessing EMODnet WFS services\nemodnet.wcs Documentation - Guide to accessing EMODnet WCS services\n\n\n\nAdditional Resources\n\nrspatial.org Tutorials - Free tutorials on spatial analysis with R\nCRAN Spatial Task View - Comprehensive overview of spatial packages in R\n\n\nReady to get started? Head to the tutorials to apply these concepts with real EMODnet data!"
  },
  {
    "objectID": "tutorials/tutorial-01.html",
    "href": "tutorials/tutorial-01.html",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "",
    "text": "The North Sea is one of Europe’s most heavily industrialised marine regions. Beneath its waters lies a dense network of energy infrastructure, including oil and gas platforms, pipelines, and offshore wind installations, alongside a growing network of marine protected areas (MPAs) established under EU directives such as the Marine Strategy Framework Directive and the Habitats Directive.\nUnderstanding where these features intersect is crucial for:\n\nMarine spatial planning: balancing conservation with economic activities\nEnvironmental impact assessments: evaluating potential effects of infrastructure on protected habitats\nPolicy compliance: ensuring activities align with conservation objectives\n\nIn this tutorial, we’ll focus on the energy sector’s footprint on marine protected areas, using open-access EMODnet data to identify and quantify overlaps between protected areas and energy infrastructure. This demonstrates how the emodnet.wfs package enables data-driven environmental analysis entirely within R.\n\n\nBy the end of this tutorial, you will be able to:\n\nExplore and discover available WFS layers using emodnet.wfs functions\nRetrieve multiple vector datasets representing MPAs and subsea infrastructure\nHarmonise coordinate reference systems across layers\nApply spatial intersection techniques to detect overlaps\nSummarise and visualise the extent of intersection between protected areas and human activities\n\n\n\n\nAll data comes from the EMODnet Human Activities portal:\nProtected Areas:\n\n\n\n\n\n\n\nLayer\nDescription\n\n\n\n\ncddaareas\nCDDA (Common Database on Designated Areas), the European inventory of nationally designated protected areas including nature reserves, national parks, and other site types\n\n\nnatura2000areas\nNatura 2000 network, the EU-wide network of protected areas established under the Birds and Habitats Directives to protect Europe’s most valuable species and habitats\n\n\nmarineprotectedareas\nOther marine protected areas, sites designated under regional sea conventions (OSPAR, HELCOM, Barcelona Convention) and other international frameworks\n\n\n\nEnergy Infrastructure:\n\n\n\n\n\n\n\nLayer\nDescription\n\n\n\n\nplatforms\nOffshore platforms, including oil, gas, and wind energy installations such as production platforms, substations, and support structures\n\n\npipelines\nSubsea pipelines for oil, gas, and chemical transport on the seabed\n\n\npcablesbshcontis\nPower cables from BSH (German Federal Maritime and Hydrographic Agency) and CONTIS database\n\n\npcablesshom\nPower cables from SHOM (French Naval Hydrographic and Oceanographic Service)\n\n\npcablesrijks\nPower cables from Rijkswaterstaat (Dutch Directorate-General for Public Works and Water Management)\n\n\npcablesnve\nPower cables from Norwegian sources\n\n\n\nNote: EMODnet also provides telecommunication cable datasets (e.g., sigcables, ukfibrecables), but we focus on energy infrastructure in this tutorial."
  },
  {
    "objectID": "tutorials/tutorial-01.html#introduction",
    "href": "tutorials/tutorial-01.html#introduction",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "",
    "text": "The North Sea is one of Europe’s most heavily industrialised marine regions. Beneath its waters lies a dense network of energy infrastructure, including oil and gas platforms, pipelines, and offshore wind installations, alongside a growing network of marine protected areas (MPAs) established under EU directives such as the Marine Strategy Framework Directive and the Habitats Directive.\nUnderstanding where these features intersect is crucial for:\n\nMarine spatial planning: balancing conservation with economic activities\nEnvironmental impact assessments: evaluating potential effects of infrastructure on protected habitats\nPolicy compliance: ensuring activities align with conservation objectives\n\nIn this tutorial, we’ll focus on the energy sector’s footprint on marine protected areas, using open-access EMODnet data to identify and quantify overlaps between protected areas and energy infrastructure. This demonstrates how the emodnet.wfs package enables data-driven environmental analysis entirely within R.\n\n\nBy the end of this tutorial, you will be able to:\n\nExplore and discover available WFS layers using emodnet.wfs functions\nRetrieve multiple vector datasets representing MPAs and subsea infrastructure\nHarmonise coordinate reference systems across layers\nApply spatial intersection techniques to detect overlaps\nSummarise and visualise the extent of intersection between protected areas and human activities\n\n\n\n\nAll data comes from the EMODnet Human Activities portal:\nProtected Areas:\n\n\n\n\n\n\n\nLayer\nDescription\n\n\n\n\ncddaareas\nCDDA (Common Database on Designated Areas), the European inventory of nationally designated protected areas including nature reserves, national parks, and other site types\n\n\nnatura2000areas\nNatura 2000 network, the EU-wide network of protected areas established under the Birds and Habitats Directives to protect Europe’s most valuable species and habitats\n\n\nmarineprotectedareas\nOther marine protected areas, sites designated under regional sea conventions (OSPAR, HELCOM, Barcelona Convention) and other international frameworks\n\n\n\nEnergy Infrastructure:\n\n\n\n\n\n\n\nLayer\nDescription\n\n\n\n\nplatforms\nOffshore platforms, including oil, gas, and wind energy installations such as production platforms, substations, and support structures\n\n\npipelines\nSubsea pipelines for oil, gas, and chemical transport on the seabed\n\n\npcablesbshcontis\nPower cables from BSH (German Federal Maritime and Hydrographic Agency) and CONTIS database\n\n\npcablesshom\nPower cables from SHOM (French Naval Hydrographic and Oceanographic Service)\n\n\npcablesrijks\nPower cables from Rijkswaterstaat (Dutch Directorate-General for Public Works and Water Management)\n\n\npcablesnve\nPower cables from Norwegian sources\n\n\n\nNote: EMODnet also provides telecommunication cable datasets (e.g., sigcables, ukfibrecables), but we focus on energy infrastructure in this tutorial."
  },
  {
    "objectID": "tutorials/tutorial-01.html#setup",
    "href": "tutorials/tutorial-01.html#setup",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Setup",
    "text": "Setup\n\nPackages\nWe’ll use emodnet.wfs to access EMODnet WFS services, sf for spatial data handling, rnaturalearth to get European coastlines, dplyr and purrr for data manipulation, and ggplot2 and tmap for visualisation.\n\nlibrary(emodnet.wfs)\nlibrary(sf)\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(ggplot2)\nlibrary(tmap)\n\n\n\n\n\n\n\nTipPackage installation\n\n\n\n\n\nIf you haven’t installed these packages, run:\ninstall.packages(c(\n  \"emodnet.wfs\", \"sf\", \"dplyr\", \"purrr\", \"ggplot2\", \"tmap\",\n  \"rnaturalearth\", \"skimr\"\n))\nFor the latest development version:\n# install.packages(\"pak\")\npak::pak(\"EMODnet/emodnet.wfs\")\n\n\n\n\n\nStudy Area\nWe’ll focus on the North Sea, defined by the following bounding box. We’ll use EPSG:3035 (ETRS89-LAEA) as our working CRS, a projected coordinate system with metric units that’s well-suited for European marine analysis.\n\n# Geographic bbox for WFS queries (EPSG:4326)\nnorth_sea_bbox &lt;- c(xmin = -4, ymin = 51, xmax = 9, ymax = 62)\n\n# Create bbox polygon and transform to ETRS89-LAEA (EPSG:3035) for analysis\nbbox_polygon &lt;- sf::st_as_sfc(sf::st_bbox(north_sea_bbox, crs = 4326))\nbbox_3035 &lt;- sf::st_transform(bbox_polygon, 3035)\n\n\n\nCode\n# Get European coastlines, transform to EPSG:3035, and crop to study area\neurope &lt;- rnaturalearth::ne_countries(\n  scale = \"medium\",\n  continent = \"Europe\",\n  returnclass = \"sf\"\n) |&gt;\n  sf::st_transform(3035) |&gt;\n  sf::st_crop(bbox_3035)\n\nggplot() +\n  geom_sf(data = europe, fill = \"gray90\", color = \"gray60\", linewidth = 0.3) +\n  geom_sf(data = bbox_3035, fill = NA, color = \"#004494\", linewidth = 1.5) +\n  labs(x = NULL, y = NULL) +\n  theme_minimal() +\n  theme(panel.grid = element_line(color = \"gray85\", linewidth = 0.2))\n\n\n\n\n\n\n\n\nFigure 1: Study area: North Sea region"
  },
  {
    "objectID": "tutorials/tutorial-01.html#exploring-emodnet-wfs-services",
    "href": "tutorials/tutorial-01.html#exploring-emodnet-wfs-services",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Exploring EMODnet WFS Services",
    "text": "Exploring EMODnet WFS Services\nBefore downloading data, it’s good practice to explore what’s available. The emodnet.wfs package provides several functions to discover services, layers, and their attributes, helping you understand the data before committing to a download.\n\nDiscovering Available Services\nEMODnet provides data through several thematic portals. Let’s see what WFS services are available:\n\nemodnet_wfs()\n\n\n\n\n\n\n\n\n\n\n\nemodnet_thematic_lot\nservice_name\nservice_url\n\n\n\n\nEMODnet Bathymetry\nbathymetry\nhttps://ows.emodnet-bathymetry.eu/wfs\n\n\nEMODnet Biology\nbiology\nhttps://geo.vliz.be/geoserver/Emodnetbio/wfs\n\n\nEMODnet Biology\nbiology_occurrence_data\nhttps://geo.vliz.be/geoserver/Dataportal/wfs\n\n\nEMODnet Chemistry\nchemistry_cdi_data_discovery_and_access_service\nhttps://geo-service.maris.nl/emodnet_chemistry/wfs\n\n\nEMODnet Chemistry\nchemistry_cdi_distribution_observations_per_category_and_region\nhttps://geo-service.maris.nl/emodnet_chemistry_p36/wfs\n\n\nEMODnet Chemistry\nchemistry_contaminants\nhttps://geoserver.hcmr.gr/geoserver/EMODNET_SHARED/wfs\n\n\nEMODnet Chemistry\nchemistry_marine_litter\nhttps://www.ifremer.fr/services/wfs/emodnet_chemistry2\n\n\nEMODnet Geology\ngeology_coastal_behavior\nhttps://drive.emodnet-geology.eu/geoserver/tno/wfs\n\n\nEMODnet Geology\ngeology_events_and_probabilities\nhttps://drive.emodnet-geology.eu/geoserver/ispra/wfs\n\n\nEMODnet Geology\ngeology_marine_minerals\nhttps://drive.emodnet-geology.eu/geoserver/gsi/wfs\n\n\nEMODnet Geology\ngeology_sea_floor_bedrock\nhttps://drive.emodnet-geology.eu/geoserver/bgr/wfs\n\n\nEMODnet Geology\ngeology_seabed_substrate_maps\nhttps://drive.emodnet-geology.eu/geoserver/gtk/wfs\n\n\nEMODnet Geology\ngeology_submerged_landscapes\nhttps://drive.emodnet-geology.eu/geoserver/bgs/wfs\n\n\nEMODnet Human Activities\nhuman_activities\nhttps://ows.emodnet-humanactivities.eu/wfs\n\n\nEMODnet Physics\nphysics\nhttps://prod-geoserver.emodnet-physics.eu/geoserver/ows\n\n\nEMODnet Seabed Habitats\nseabed_habitats_general_datasets_and_products\nhttps://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_open/wfs\n\n\nEMODnet Seabed Habitats\nseabed_habitats_individual_habitat_map_and_model_datasets\nhttps://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_open_maplibrary/wfs\n\n\n\n\n\nFor this tutorial, we’ll use the human_activities service, which contains both protected area boundaries and infrastructure data.\n\n\nConnecting to a Service\nTo query a service, we first create a WFS client connection:\n\nwfs &lt;- emodnet_init_wfs_client(service = \"human_activities\")\n\n\n\nDiscovering Available Layers\nEach service contains multiple layers. Let’s explore what’s available:\n\navailable_layers &lt;- emodnet_get_wfs_info(wfs)\navailable_layers |&gt;\n  select(layer_name, title, abstract)\n\n\n\n\n\n\n\nThe full output also includes service_name, service_url, class (the WFS feature type), format (the R object class returned, typically sf), and layer_namespace.\nWith many layers available, we can filter to find those relevant to our analysis.\n\nProtected Area Layers\nLet’s search for layers related to protected areas:\n\navailable_layers |&gt;\n  filter(grepl(\"protected|natura|cdda\", layer_name, ignore.case = TRUE)) |&gt;\n  select(layer_name, title)\n\n\n  \n\n\n\nWe’ll use three complementary datasets to get comprehensive coverage of marine protected areas:\n\ncddaareas: the CDDA database captures nationally designated sites, giving us country-level protected areas\nnatura2000areas: the EU’s flagship conservation network, essential for any European marine analysis\nmarineprotectedareas: includes sites designated under regional conventions (OSPAR, HELCOM) that may not appear in the other datasets\n\nNote that cddalocations also appears in the filter results. This layer contains point geometries representing the same protected areas, but we need the polygon boundaries from cddaareas for spatial intersection analysis.\n\nmpa_layers &lt;- c(\n  \"cddaareas\",\n  \"natura2000areas\",\n  \"marineprotectedareas\"\n)\n\n\n\nEnergy Infrastructure Layers\nNow let’s find layers related to energy infrastructure. The service includes both power cables (pcables*) and telecommunication cables, but we’ll focus on energy sector infrastructure:\n\navailable_layers |&gt;\n  filter(grepl(\"platform|pipeline|cable\", layer_name, ignore.case = TRUE)) |&gt;\n  select(layer_name, title)\n\n\n  \n\n\n\nFor our energy sector focus, we’ll use:\n\nplatforms: offshore installations (oil, gas, wind) as point locations\npipelines: subsea pipelines for oil and gas transport as line features\npcables*: power cables from multiple national sources (BSH, SHOM, Rijkswaterstaat, Norwegian) for offshore wind and interconnector coverage\n\n\ninfrastructure_layers &lt;- c(\n  \"platforms\",\n  \"pipelines\",\n  \"pcablesbshcontis\",\n  \"pcablesshom\",\n  \"pcablesrijks\",\n  \"pcablesnve\"\n)\n\n\n\n\nUnderstanding Layer Structure\nWFS layers can contain thousands of features with dozens of attributes. Downloading everything and filtering afterwards wastes bandwidth and time. Before committing to a download, we should:\n\nDiscover available attributes: what columns exist and what types are they?\nIdentify filter candidates: which attributes contain categorical values we can filter on?\nCheck actual values: what values exist so we can write accurate filter expressions?\n\nThe emodnet.wfs package provides lightweight metadata functions that answer these questions without downloading full datasets. This “look before you leap” approach helps us write efficient, targeted queries.\n\nInspecting Attribute Metadata\nThe layer_attribute_descriptions() function returns metadata about each attribute in a layer: name, type, and whether it’s the geometry column. It takes a WFS client connection (wfs) and a layer name (layer).\nSince we have three layers to inspect, we use map() to apply the function to each layer name in mpa_layers:\n\nmpa_descriptions &lt;- map(\n  set_names(mpa_layers),\n  \\(x) layer_attribute_descriptions(wfs = wfs, layer = x)\n)\n\nbind_rows(mpa_descriptions, .id = \"layer\")\n\n\n  \n\n\n\n\n\nIdentifying Geometry Columns\nThe geometry column in the output flags which attribute holds the spatial data. We extract these for use when downloading:\n\nget_geom_cols &lt;- function(descriptions) {\n  map_chr(descriptions, \\(x) x$name[x$geometry])\n}\n\nmpa_geom_cols &lt;- get_geom_cols(mpa_descriptions)\nmpa_geom_cols\n#&gt;            cddaareas      natura2000areas marineprotectedareas \n#&gt;           \"the_geom\"           \"the_geom\"           \"the_geom\"\n\n\n\nIdentifying Filter Candidates\nLooking at these descriptions, we can identify attributes useful for filtering:\nCategorical attributes (character type): useful for selecting specific categories\n\ncddaareas: majorecosy (ecosystem type) and designated (designation status) look promising\nmarineprotectedareas: status likely indicates whether sites are designated or proposed\n\nNumeric attributes: useful for threshold-based filtering\n\nnatura2000areas: mar_perc (marine percentage) could help us select predominantly marine sites\n\n\n\nExploring Categorical Values\nFor categorical attributes, we can use layer_attribute_inspect() to fetch unique values. This is much cheaper than downloading the full dataset:\n\n# Check ecosystem types in CDDA - we'll want to exclude terrestrial\nlayer_attribute_inspect(\n  wfs = wfs,\n  layer = \"cddaareas\",\n  attribute = \"majorecosy\"\n)\n\n\n  \n\n\n\n# Check designation status in CDDA\nlayer_attribute_inspect(\n  wfs = wfs,\n  layer = \"cddaareas\",\n  attribute = \"designated\"\n)\n\n\n  \n\n\n\n# Check status values in marine protected areas\nlayer_attribute_inspect(\n  wfs = wfs,\n  layer = \"marineprotectedareas\",\n  attribute = \"status\"\n)\n\n\n  \n\n\n\nThis tells us:\n\ncddaareas: exclude majorecosy = 'Terrestrial' and keep only designated = 'Designated Site'\nmarineprotectedareas: keep status IN ('Designated', 'Designated and managed')\n\n\n\nExploring Numeric Values\nFor numeric attributes like mar_perc, we need to understand the distribution of values to choose an appropriate threshold. The same layer_attribute_inspect() function works here too, but returns summary statistics instead of unique values:\n\nlayer_attribute_inspect(\n  wfs = wfs,\n  layer = \"natura2000areas\",\n  attribute = \"mar_perc\"\n)\n#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#&gt;    0.00    0.00   14.76   39.10   89.89  100.00\n\nThe mar_perc attribute represents the percentage of each Natura 2000 site that is marine (0-100). The summary shows sites span the full range from fully terrestrial (0%) to fully marine (100%), with a median of 15% and mean of 39%.\nFor our analysis, we want sites that are predominantly marine. A threshold of 50% ensures we include sites that are more marine than terrestrial, while excluding coastal sites that are primarily land-based. This gives us:\n\nnatura2000areas: filter to mar_perc &gt; 50 for predominantly marine sites\n\n\n\n\n\n\n\nNoteFetching complete attribute tables\n\n\n\n\n\nFor more comprehensive exploration, layer_attributes_tbl() fetches all attribute data (without geometry) as a tibble. The related layer_attributes_summarise() provides summary statistics.\nmpa_attr_tbls &lt;- map(\n set_names(mpa_layers),\n \\(x) layer_attributes_tbl(wfs = wfs, layer = x)\n)\nBoth functions are more expensive than layer_attribute_inspect() since they fetch the complete dataset. Use them when you need to explore relationships between multiple attributes or perform detailed data quality checks.\nWe’ve included pre-fetched attribute tables as package data. Use the tabs below to browse:\n\nCDDA AreasNatura 2000Marine Protected Areas\n\n\n\nmpa_attr_tbls$cddaareas\n\n\n  \n\n\nskimr::skim(mpa_attr_tbls$cddaareas)\n\n\nData summary\n\n\nName\nmpa_attr_tbls$cddaareas\n\n\nNumber of rows\n13128\n\n\nNumber of columns\n35\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n26\n\n\nDate\n1\n\n\nnumeric\n8\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ngml_id\n0\n1.00\n11\n15\n0\n13128\n0\n\n\ncddacountr\n0\n1.00\n2\n2\n0\n26\n0\n\n\ncountry\n0\n1.00\n5\n11\n0\n26\n0\n\n\ncddaregion\n0\n1.00\n2\n2\n0\n36\n0\n\n\nsitename\n0\n1.00\n1\n147\n0\n12720\n0\n\n\nlocalid\n0\n1.00\n1\n36\n0\n13127\n0\n\n\nnamespace\n0\n1.00\n2\n116\n0\n44\n0\n\n\nversionid\n10186\n0.22\n1\n14\n0\n618\n0\n\n\nmetadata_v\n0\n1.00\n54\n92\n0\n26\n0\n\n\nmetadata_s\n0\n1.00\n5\n5\n0\n1\n0\n\n\nmetadata_f\n0\n1.00\n1\n1\n0\n1\n0\n\n\nmetadata_1\n13128\n0.00\nNA\nNA\n0\n0\n0\n\n\ngeomtype\n0\n1.00\n7\n7\n0\n1\n0\n\n\nnationalid\n10\n1.00\n1\n30\n0\n12632\n0\n\n\ndesignated\n0\n1.00\n15\n19\n0\n2\n0\n\n\ndesignatio\n0\n1.00\n4\n4\n0\n251\n0\n\n\niucncatego\n0\n1.00\n1\n13\n0\n10\n0\n\n\niucndesc\n0\n1.00\n12\n56\n0\n10\n0\n\n\niucnlink\n13128\n0.00\nNA\nNA\n0\n0\n0\n\n\nmajorecosy\n0\n1.00\n6\n22\n0\n3\n0\n\n\nspatialdat\n0\n1.00\n6\n6\n0\n1\n0\n\n\nspatialres\n0\n1.00\n7\n17\n0\n3\n0\n\n\npslocalid\n0\n1.00\n1\n36\n0\n13127\n0\n\n\npsnamespac\n0\n1.00\n2\n116\n0\n44\n0\n\n\npsversioni\n10186\n0.22\n1\n14\n0\n618\n0\n\n\nremark\n6309\n0.52\n3\n254\n0\n625\n0\n\n\n\nVariable type: Date\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\nmetadata_b\n0\n1\n2020-03-29\n2025-07-08\n2025-04-15\n22\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\ncddaid\n0\n1\n217326210.30\n271026192.66\n650\n175486.25\n387833.00\n555632146.75\n555774576.00\n▇▁▁▁▅\n\n\nlegalfound\n0\n1\n2000.29\n16.99\n1800\n1993.00\n2003.00\n2010.00\n2025.00\n▁▁▁▁▇\n\n\nid\n0\n1\n996824.78\n100897.59\n395195\n977769.50\n1012624.50\n1049099.50\n1077448.00\n▁▁▁▁▇\n\n\ncoast_mar\n0\n1\n1.00\n0.00\n1\n1.00\n1.00\n1.00\n1.00\n▁▁▇▁▁\n\n\nsitearea\n0\n1\n27573.80\n1689510.52\n0\n3.21\n20.28\n207.43\n166200000.00\n▇▁▁▁▁\n\n\nmarinearea\n0\n1\n19.17\n33.39\n0\n0.00\n0.00\n26.00\n100.00\n▇▁▁▁▁\n\n\nshape_leng\n0\n1\n0.51\n8.32\n0\n0.01\n0.04\n0.14\n843.75\n▇▁▁▁▁\n\n\nshape_area\n0\n1\n0.05\n3.73\n0\n0.00\n0.00\n0.00\n380.60\n▇▁▁▁▁\n\n\n\n\n\n\n\n\nmpa_attr_tbls$natura2000areas\n\n\n  \n\n\nskimr::skim(mpa_attr_tbls$natura2000areas)\n\n\nData summary\n\n\nName\nmpa_attr_tbls$natura2000a…\n\n\nNumber of rows\n4402\n\n\nNumber of columns\n17\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n8\n\n\nDate\n4\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ngml_id\n0\n1\n17\n20\n0\n4402\n0\n\n\nsitecode\n0\n1\n9\n9\n0\n4402\n0\n\n\nsitename\n0\n1\n2\n203\n0\n4300\n0\n\n\nms\n0\n1\n2\n2\n0\n22\n0\n\n\ncountry\n0\n1\n5\n11\n0\n22\n0\n\n\nsitetype\n0\n1\n1\n1\n0\n3\n0\n\n\nsitedesc\n0\n1\n16\n35\n0\n3\n0\n\n\ndirective\n0\n1\n68\n81\n0\n3\n0\n\n\n\nVariable type: Date\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\nrelease_da\n156\n0.96\n1998-04-30\n2024-02-01\n2018-12-01\n147\n\n\ndate_spa\n3083\n0.30\n1900-01-01\n2023-12-01\n2004-02-01\n173\n\n\ndate_sci\n2010\n0.54\n2001-12-01\n2023-01-01\n2006-06-30\n37\n\n\ndate_sac\n1381\n0.69\n1900-01-01\n2023-12-01\n2014-04-30\n163\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\narea_ha\n0\n1\n18553.07\n172261.85\n0.02\n107.11\n716.40\n5046.09\n7186094.00\n▇▁▁▁▁\n\n\nmar_perc\n0\n1\n39.10\n42.67\n0.00\n0.00\n14.76\n89.89\n100.00\n▇▁▁▁▅\n\n\ncoast_mar\n0\n1\n1.00\n0.00\n1.00\n1.00\n1.00\n1.00\n1.00\n▁▁▇▁▁\n\n\nshape_leng\n0\n1\n1.10\n13.39\n0.00\n0.09\n0.27\n0.78\n841.51\n▇▁▁▁▁\n\n\nshape_area\n0\n1\n0.02\n0.20\n0.00\n0.00\n0.00\n0.01\n8.53\n▇▁▁▁▁\n\n\n\n\n\n\n\n\nmpa_attr_tbls$marineprotectedareas\n\n\n  \n\n\nskimr::skim(mpa_attr_tbls$marineprotectedareas)\n\n\nData summary\n\n\nName\nmpa_attr_tbls$marineprote…\n\n\nNumber of rows\n826\n\n\nNumber of columns\n18\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n10\n\n\nnumeric\n8\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ngml_id\n0\n1.00\n22\n24\n0\n826\n0\n\n\nname\n0\n1.00\n3\n141\n0\n803\n0\n\n\nrsc\n0\n1.00\n5\n9\n0\n3\n0\n\n\norig_name\n188\n0.77\n3\n81\n0\n614\n0\n\n\ncountry\n0\n1.00\n5\n34\n0\n28\n0\n\n\ndesignatio\n188\n0.77\n29\n52\n0\n2\n0\n\n\niucn_cat\n224\n0.73\n1\n14\n0\n8\n0\n\n\nstatus\n0\n1.00\n7\n29\n0\n5\n0\n\n\nmang_auth\n298\n0.64\n3\n244\n0\n112\n0\n\n\nlink\n481\n0.42\n10\n165\n0\n269\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\ncode\n0\n1.00\n2348.53\n2397.33\n11.00\n599.25\n1705.00\n2323.50\n8669.00\n▇▅▁▁▂\n\n\nrep_m_area\n218\n0.74\n2848.90\n26867.43\n0.07\n16.60\n78.57\n410.02\n595156.00\n▇▁▁▁▁\n\n\ngis_m_area\n194\n0.77\n2819.55\n26397.30\n0.01\n15.78\n85.17\n425.80\n595158.13\n▇▁▁▁▁\n\n\nrep_area\n369\n0.55\n3653.83\n30940.67\n0.07\n17.24\n115.53\n594.36\n595156.00\n▇▁▁▁▁\n\n\ngis_area\n188\n0.77\n2803.07\n26283.21\n0.04\n16.32\n85.70\n439.98\n595158.13\n▇▁▁▁▁\n\n\nstatus_yr\n0\n1.00\n2011.79\n5.28\n1991.00\n2008.00\n2011.00\n2016.00\n2023.00\n▁▁▇▇▅\n\n\nshape_leng\n0\n1.00\n2.51\n8.93\n0.01\n0.47\n1.07\n2.26\n199.29\n▇▁▁▁▁\n\n\nshape_area\n0\n1.00\n0.32\n2.97\n0.00\n0.00\n0.01\n0.05\n72.30\n▇▁▁▁▁\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlanning Our Data Schema\nNow that we’ve explored the available attributes and identified our filter criteria, we can plan exactly what to request. Defining a schema upfront has several benefits:\n\nReduces download size: we only request the columns we actually need\nDocuments our decisions: the schema captures which filters we’re applying and why\nEnables standardisation: different layers use different names for similar concepts (sitename vs name), which we’ll need to reconcile when combining data later\nSupports automation: we can programmatically extract property names and filters from the schema\n\nOur schema structure has two components per layer:\n\ncols: a named list defining the columns for our final combined dataset. The names are what we want our output columns to be called. Each element is either:\n\nNULL: the WFS layer already uses this column name and no type casting is needed\nA list with from and/or type:\n\nfrom: the actual attribute name in the WFS layer (when it differs from our desired output name)\ntype: type shorthand for casting: \"d\" (double), \"i\" (integer), \"c\" (character), etc.\n\n\nfilter: a CQL/ECQL filter expression to apply server-side\n\nFor example, sitename = list(from = \"name\") means: “download the name attribute from the WFS, but rename it to sitename in our output”. This lets us harmonise column names across layers that use different conventions.\n\n\n\n\n\n\nNote\n\n\n\nRenaming and type casting happen later when we combine the layers, not at download time.\n\n\n\nmpa_schemas &lt;- list(\n  cddaareas = list(\n    cols = list(\n      sitename = NULL,\n      country = NULL,\n      majorecosy = NULL,\n      designated = NULL\n    ),\n    filter = \"majorecosy &lt;&gt; 'Terrestrial' AND designated = 'Designated Site'\"\n  ),\n  natura2000areas = list(\n    cols = list(\n      sitename = NULL,\n      country = NULL,\n      sitedesc = NULL,\n      directive = NULL,\n      mar_perc = list(type = \"d\")\n    ),\n    filter = \"mar_perc &gt; 50\"\n  ),\n  marineprotectedareas = list(\n    cols = list(\n      sitename = list(from = \"name\"),\n      country = NULL,\n      designatio = NULL,\n      rsc = NULL,\n      status = NULL\n    ),\n    filter = \"status IN ('Designated', 'Designated and managed')\"\n  )\n)\n\n\n\nDefining the Spatial Filter\nTo avoid downloading entire datasets and filtering afterwards, we’ll use an ECQL BBOX filter to request only features within our study area.\nThe BBOX filter requires the geometry column name. We extracted these in Identifying Geometry Columns. Let’s verify all layers use the same name so we can use a single filter:\n\nunique(mpa_geom_cols)\n#&gt; [1] \"the_geom\"\n\nAll layers use the_geom, so we can use a shared bbox filter. If layers had different geometry column names, we’d need to construct per-layer filters.\n\n# Create ECQL BBOX filter string\n# Format: BBOX(geometry_column, minx, miny, maxx, maxy, 'CRS')\nbbox_filter &lt;- sprintf(\n  \"BBOX(%s, %s, %s, %s, %s, 'EPSG:4326')\",\n  unique(mpa_geom_cols),\n  north_sea_bbox[\"xmin\"],\n  north_sea_bbox[\"ymin\"],\n  north_sea_bbox[\"xmax\"],\n  north_sea_bbox[\"ymax\"]\n)\n\nbbox_filter\n#&gt; [1] \"BBOX(the_geom, -4, 51, 9, 62, 'EPSG:4326')\"\n\n\n\nExtracting Property Names\nTo limit which attributes are downloaded, we pass a propertyName argument to the WFS request. This expects a comma-separated string of attribute names (WFS calls these “properties”, hence the parameter name). We can extract these from our schema: for each column, we use the from value if specified, otherwise the column name itself. We also include the geometry column so we get spatial data back:\n\n# Helper to build propertyName string from schema\nget_property_names &lt;- function(schema, geom_col) {\n  cols &lt;- schema$cols\n  attrs &lt;- imap_chr(cols, \\(x, y) x$from %||% y)\n  paste(c(geom_col, attrs), collapse = \",\")\n}\n\n# Build propertyName strings for each layer\nmpa_property_names &lt;- map2_chr(\n  mpa_schemas,\n  mpa_geom_cols,\n  \\(x, y) get_property_names(schema = x, geom_col = y)\n)\nmpa_property_names\n#&gt;                                               cddaareas \n#&gt;       \"the_geom,sitename,country,majorecosy,designated\" \n#&gt;                                         natura2000areas \n#&gt; \"the_geom,sitename,country,sitedesc,directive,mar_perc\" \n#&gt;                                    marineprotectedareas \n#&gt;           \"the_geom,name,country,designatio,rsc,status\""
  },
  {
    "objectID": "tutorials/tutorial-01.html#retrieving-protected-area-data",
    "href": "tutorials/tutorial-01.html#retrieving-protected-area-data",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Retrieving Protected Area Data",
    "text": "Retrieving Protected Area Data\nNow that we’ve defined our schema, filters, and property names, let’s download the protected area boundaries.\n\nDownloading Multiple Layers\nThe emodnet_get_layers() function downloads one or more layers. Each argument helps keep downloads lean and processing efficient by pushing work to the server (the WFS service) rather than doing it client-side (locally in R after downloading):\n\ncrs = 3035: requests data pre-transformed to our target coordinate reference system, avoiding a local st_transform() call\ncql_filter: filters features on the server so we only download what matches our spatial and attribute criteria\npropertyName: limits which attributes are returned, reducing payload size for layers with many columns\noutputFormat = \"application/json\": requests GeoJSON format for faster downloads and simpler geometry types\nsimplify = TRUE: returns an sf object directly instead of a list (convenient for single-layer requests)\n\nSince each layer has different attribute names and filters, we loop through them using our pre-defined schemas:\n\nmpa_sf_list &lt;- map(mpa_layers, \\(layer) {\n  # Combine bbox filter with layer-specific attribute filter\n  layer_filter &lt;- mpa_schemas[[layer]]$filter\n  combined_filter &lt;- paste(bbox_filter, layer_filter, sep = \" AND \")\n\n  emodnet_get_layers(\n    wfs = wfs,\n    layers = layer,\n    crs = 3035,\n    cql_filter = combined_filter,\n    propertyName = mpa_property_names[[layer]],\n    outputFormat = \"application/json\",\n    simplify = TRUE\n  )\n}) |&gt;\n  set_names(mpa_layers)\n\n\n\n\n\n\n\nNoteWhy use GeoJSON format?\n\n\n\n\n\nWe specify outputFormat = \"application/json\" (GeoJSON) rather than the default GML format for two reasons:\n\nFaster downloads: GeoJSON is typically more compact and efficient to transfer over the network\nSimpler geometries: GeoJSON returns standard geometry types like POLYGON and MULTIPOLYGON, while GML may return complex types like MULTISURFACE or CURVE that can cause issues with spatial operations and plotting functions\n\nThis is recommended practice for most emodnet_get_layers() calls.\n\n\n\nThis returns a named list of sf objects, one per layer:\n\nnames(mpa_sf_list)\n#&gt; [1] \"cddaareas\"            \"natura2000areas\"      \"marineprotectedareas\"\n\n\nmap_int(mpa_sf_list, nrow)\n#&gt;            cddaareas      natura2000areas marineprotectedareas \n#&gt;                  358                   56                  183\n\nLet’s examine the downloaded layers:\n\nCDDA AreasNatura 2000Marine Protected Areas\n\n\n\nmpa_sf_list$cddaareas\n\n\n  \n\n\n\n\n\n\nmpa_sf_list$natura2000areas\n\n\n  \n\n\n\n\n\n\nmpa_sf_list$marineprotectedareas\n\n\n  \n\n\n\n\n\n\n\n\nFiltering by Location (Post-download)\nOur rectangular bounding box captures some protected areas in the Irish Sea that aren’t part of our North Sea study area. We can apply a more precise spatial filter locally to remove these while keeping Scottish MPAs further north.\nThe sf package provides st_filter() for filtering spatial data based on geometric relationships. We’ll use it with st_disjoint as the predicate, which keeps features that have no points in common with our exclusion zone.\nFirst, we define the Irish Sea exclusion zone as a bounding box polygon. We create it in geographic coordinates (EPSG:4326) and then transform it to our working CRS (EPSG:3035) to match our MPA data:\n\n# Define Irish Sea exclusion zone as a polygon\nirish_sea_bbox &lt;- st_bbox(\n  c(xmin = -7, ymin = 51, xmax = -2.5, ymax = 55.5),\n  crs = 4326\n) |&gt;\n  st_as_sfc() |&gt;\n  st_transform(3035)\n\nNow we apply st_filter() with st_disjoint to keep only features that don’t touch the Irish Sea:\n\n# Keep features that are disjoint from (don't touch) the Irish Sea\nmpa_sf_list &lt;- map(mpa_sf_list, \\(x) {\n  st_filter(x, irish_sea_bbox, .predicate = st_disjoint)\n})\n\n# Check the filtered counts\nmap_int(mpa_sf_list, nrow)\n#&gt;            cddaareas      natura2000areas marineprotectedareas \n#&gt;                  358                   56                  156\n\n\n\n\n\n\n\nTipAlternative: Server-side spatial filtering\n\n\n\n\n\nWhen working with web services like WFS, filtering can happen in two places:\n\nServer-side: The WFS server applies filters before sending data. You receive only the features that match your criteria. This is what our CQL BBOX and attribute filters do.\nClient-side: You download the data first, then filter it locally in R using functions like st_filter(). This is what we did above with the Irish Sea exclusion.\n\nThe Irish Sea filter could also be applied server-side using CQL’s DISJOINT function, which selects features that don’t intersect with a geometry:\n# Define exclusion zone as WKT (in EPSG:4326 to match the bbox filter)\nirish_sea_wkt &lt;- \"POLYGON((-7 51, -2.5 51, -2.5 55.5, -7 55.5, -7 51))\"\n\n# Add to the CQL filter\ncombined_filter &lt;- paste(\n  bbox_filter,\n  layer_filter,\n  sprintf(\"DISJOINT(the_geom, %s)\", irish_sea_wkt),\n  sep = \" AND \"\n)\nServer-side filtering reduces download size, which matters for large datasets. Client-side filtering with sf functions like st_filter() is more flexible and works with any spatial data, not just WFS, making it a valuable skill for spatial analysis in R.\n\n\n\n\n\nQuick Visualisation\nLet’s do a quick visual check with ggplot2, showing all three protected area types. First, we prepare the data for plotting:\n\nExtract the bounding box extent for consistent map limits across plots\nSelect only the geometry column, dropping attributes we don’t need for plotting\nAdd a type column for colour-coding, then combine all layers into a single sf object\nSimplify geometries to speed up rendering (500m tolerance is imperceptible at this scale)\n\n\n# Get bbox extent for coord_sf (used by multiple plots)\nbbox_ext &lt;- st_bbox(bbox_3035)\n\n# Combine all protected areas with type labels (simplify for faster rendering)\nmpa_preview &lt;- imap(\n  mpa_sf_list,\n  \\(x, y) {\n    select(x, geometry) |&gt;\n      mutate(type = y) |&gt;\n      st_simplify(dTolerance = 500, preserveTopology = TRUE)\n  }\n) |&gt;\n  bind_rows()\n\n\nggplot() +\n  geom_sf(data = europe, fill = \"gray90\", colour = \"gray70\") +\n  geom_sf(\n    data = mpa_preview,\n    aes(fill = type, colour = type),\n    alpha = 0.4\n  ) +\n  scale_fill_brewer(palette = \"Set2\", name = \"Type\") +\n  scale_colour_brewer(palette = \"Set2\", guide = \"none\") +\n  coord_sf(\n    xlim = c(bbox_ext[\"xmin\"], bbox_ext[\"xmax\"]),\n    ylim = c(bbox_ext[\"ymin\"], bbox_ext[\"ymax\"])\n  ) +\n  labs(title = \"Protected Areas by Type\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\nFigure 2: Protected areas in the North Sea by type"
  },
  {
    "objectID": "tutorials/tutorial-01.html#retrieving-infrastructure-data",
    "href": "tutorials/tutorial-01.html#retrieving-infrastructure-data",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Retrieving Infrastructure Data",
    "text": "Retrieving Infrastructure Data\nNext, let’s download the subsea infrastructure data. First, let’s check the layer attributes:\n\ninfra_descriptions &lt;- map(\n  set_names(infrastructure_layers),\n  \\(x) layer_attribute_descriptions(wfs = wfs, layer = x)\n)\n\nimap(infra_descriptions, \\(x, y) x$name)\n#&gt; $platforms\n#&gt;  [1] \"country\"            \"platformid\"         \"current_status\"    \n#&gt;  [4] \"category\"           \"function\"           \"operator\"          \n#&gt;  [7] \"location_blocks\"    \"primary_production\" \"weight_sub\"        \n#&gt; [10] \"weight_top\"         \"production_start\"   \"valid_from\"        \n#&gt; [13] \"valid_to\"           \"water_depth\"        \"coast_dist\"        \n#&gt; [16] \"remarks\"            \"the_geom\"          \n#&gt; \n#&gt; $pipelines\n#&gt;  [1] \"id\"         \"status\"     \"medium\"     \"operator\"   \"size_in\"   \n#&gt;  [6] \"length_m\"   \"year\"       \"from_loc\"   \"to_loc\"     \"country_co\"\n#&gt; [11] \"country\"    \"notes\"      \"the_geom\"  \n#&gt; \n#&gt; $pcablesbshcontis\n#&gt; [1] \"featureid\"  \"featurespe\" \"status\"     \"featuretyp\" \"name_\"     \n#&gt; [6] \"uuid\"       \"shape_leng\" \"the_geom\"  \n#&gt; \n#&gt; $pcablesshom\n#&gt; [1] \"catcbl\"    \"status\"    \"inspireid\" \"the_geom\" \n#&gt; \n#&gt; $pcablesrijks\n#&gt;  [1] \"kabel_nr\"   \"naam\"       \"eigenaar\"   \"kabel_type\" \"kabelsoort\"\n#&gt;  [6] \"legmethode\" \"rpl_status\" \"omschrijvi\" \"trace_van\"  \"trace_tot\" \n#&gt; [11] \"status\"     \"aanleg_dd\"  \"geldig_van\" \"geldig_tot\" \"aanmaak_dd\"\n#&gt; [16] \"mutatie_dd\" \"comcode\"    \"comoms\"     \"the_geom\"  \n#&gt; \n#&gt; $pcablesnve\n#&gt;  [1] \"objekttype\" \"komponentk\" \"komponen_1\" \"nvenettniv\" \"nettnivaa\" \n#&gt;  [6] \"eier\"       \"eierorgnr\"  \"navn\"       \"spenning_k\" \"driftsatta\"\n#&gt; [11] \"nveopprett\" \"nveendretd\" \"kildeendre\" \"malemetode\" \"noyaktighe\"\n#&gt; [16] \"lokalid\"    \"datauttaks\" \"eksporttyp\" \"the_geom\"\n\nThe layers have different attributes, reflecting different data sources and national reporting conventions. Unlike our protected area layers (which share common concepts like sitename and country), infrastructure attributes are specific to each layer type and source.\nWe’ll keep infrastructure layers separate rather than combining them. Mixing different geometry types (points and lines) in a single sf object is awkward. Plotting requires filtering by type to apply appropriate aesthetics (size for points, linewidth for lines), and some spatial operations behave unexpectedly with mixed geometries. We’ll download all attributes for each layer and reorganise them by infrastructure type later.\nLet’s verify these layers use the_geom so our bbox filter works:\n\ninfra_geom_cols &lt;- get_geom_cols(infra_descriptions)\nunique(infra_geom_cols)\n#&gt; [1] \"the_geom\"\n\nGood, they match. Since all layers share the same geometry column and we’re applying the same bbox filter to each (no attribute filters or property name restrictions), we can pass all layer names directly to emodnet_get_layers() without mapping.\n\nDownloading Infrastructure Layers\nWe omit simplify = TRUE because we’re downloading multiple layers and want the result as a named list:\n\ninfra_sf_list &lt;- emodnet_get_layers(\n  wfs = wfs,\n  layers = infrastructure_layers,\n  crs = 3035,\n  cql_filter = bbox_filter,\n  outputFormat = \"application/json\"\n)\n\n\nnames(infra_sf_list)\n#&gt; [1] \"platforms\"        \"pipelines\"        \"pcablesbshcontis\" \"pcablesshom\"     \n#&gt; [5] \"pcablesrijks\"     \"pcablesnve\"\n\n\nmap_int(infra_sf_list, nrow)\n#&gt;        platforms        pipelines pcablesbshcontis      pcablesshom \n#&gt;             1212             3258               69                4 \n#&gt;     pcablesrijks       pcablesnve \n#&gt;               37              317\n\nAs with the protected areas, we apply the Irish Sea exclusion filter to keep our visualisations focused on the North Sea:\n\ninfra_sf_list &lt;- map(infra_sf_list, \\(x) {\n  st_filter(x, irish_sea_bbox, .predicate = st_disjoint)\n})\n\nmap_int(infra_sf_list, nrow)\n#&gt;        platforms        pipelines pcablesbshcontis      pcablesshom \n#&gt;             1177             3187               69                4 \n#&gt;     pcablesrijks       pcablesnve \n#&gt;               37              317\n\n\n\nUnderstanding Geometry Types\nUnlike protected areas (polygons), infrastructure features have different geometry types:\n\nmap(infra_sf_list, \\(x) unique(st_geometry_type(x)))\n#&gt; $platforms\n#&gt; [1] POINT\n#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n#&gt; \n#&gt; $pipelines\n#&gt; [1] MULTILINESTRING\n#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n#&gt; \n#&gt; $pcablesbshcontis\n#&gt; [1] MULTILINESTRING\n#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n#&gt; \n#&gt; $pcablesshom\n#&gt; [1] MULTILINESTRING\n#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n#&gt; \n#&gt; $pcablesrijks\n#&gt; [1] MULTILINESTRING\n#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n#&gt; \n#&gt; $pcablesnve\n#&gt; [1] MULTILINESTRING\n#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n\nThe output shows MULTILINESTRING and MULTIPOINT rather than simple LINESTRING and POINT. The “MULTI” variants can store multiple disconnected parts in a single feature. For example, a pipeline route that has a gap, or a platform complex with several separate structures recorded as one feature.\nIn practice, sf spatial operations handle both variants identically: st_intersects() works the same whether you have LINESTRING or MULTILINESTRING geometries. The distinction matters mainly when you need to count or iterate over individual line segments.\nFor our analysis:\n\nPlatforms are points (locations of oil, gas, or wind installations)\nPipelines are lines (connecting infrastructure)\nCables are lines (power transmission and interconnectors)\n\nThis matters because spatial operations behave differently with different geometry types. Intersecting a polygon with a line returns different results than intersecting two polygons.\n\n\nQuick Visualisation\nLet’s preview the infrastructure with ggplot2:\n\n# Combine all cable layers\ncables_preview &lt;- bind_rows(\n  infra_sf_list$pcablesbshcontis,\n  infra_sf_list$pcablesshom,\n  infra_sf_list$pcablesrijks,\n  infra_sf_list$pcablesnve\n)\n\nggplot() +\n  geom_sf(data = europe, fill = \"gray90\", colour = \"gray70\") +\n  geom_sf(\n    data = cables_preview,\n    aes(colour = \"Cables\"),\n    linewidth = 0.3,\n    alpha = 0.5,\n    key_glyph = \"path\"\n  ) +\n  geom_sf(\n    data = infra_sf_list$pipelines,\n    aes(colour = \"Pipelines\"),\n    linewidth = 0.5,\n    key_glyph = \"path\"\n  ) +\n  geom_sf(\n    data = infra_sf_list$platforms,\n    aes(colour = \"Platforms\"),\n    size = 0.5,\n    key_glyph = \"point\"\n  ) +\n  scale_colour_manual(\n    values = c(\n      \"Cables\" = \"purple\",\n      \"Pipelines\" = \"orange\",\n      \"Platforms\" = \"red\"\n    ),\n    name = NULL\n  ) +\n  coord_sf(\n    xlim = c(bbox_ext[\"xmin\"], bbox_ext[\"xmax\"]),\n    ylim = c(bbox_ext[\"ymin\"], bbox_ext[\"ymax\"])\n  ) +\n  labs(title = \"Energy Infrastructure\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\nFigure 3: Energy infrastructure in the North Sea"
  },
  {
    "objectID": "tutorials/tutorial-01.html#preparing-for-spatial-analysis",
    "href": "tutorials/tutorial-01.html#preparing-for-spatial-analysis",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Preparing for Spatial Analysis",
    "text": "Preparing for Spatial Analysis\nBefore we can test for intersections between protected areas and infrastructure, we need to prepare both datasets. This involves three steps:\n\nVerify CRS alignment: all layers must share the same coordinate reference system\nValidate geometries: fix any invalid geometries that could cause errors\nOrganise data structures: combine MPA layers into a single dataset; group infrastructure by type\n\n\nChecking CRS Alignment\nAll layers should share the same coordinate reference system. Let’s verify both protected areas and infrastructure:\n\n# Check CRS of protected areas\npurrr::map_chr(mpa_sf_list, \\(x) st_crs(x)[[\"input\"]])\n#&gt;            cddaareas      natura2000areas marineprotectedareas \n#&gt;          \"EPSG:3035\"          \"EPSG:3035\"          \"EPSG:3035\"\n\n# Check CRS of infrastructure\npurrr::map_chr(infra_sf_list, \\(x) st_crs(x)[[\"input\"]])\n#&gt;        platforms        pipelines pcablesbshcontis      pcablesshom \n#&gt;      \"EPSG:3035\"      \"EPSG:3035\"      \"EPSG:3035\"      \"EPSG:3035\" \n#&gt;     pcablesrijks       pcablesnve \n#&gt;      \"EPSG:3035\"      \"EPSG:3035\"\n\nSince we specified crs = 3035 when downloading, all layers are in ETRS89-LAEA with metric units. This projected CRS is ideal for spatial analysis as it avoids the complexities of spherical geometry calculations.\n\n\nValidating Geometries\nSpatial data from web services occasionally contains invalid geometries (self-intersections, duplicate points, etc.) that can cause errors in spatial operations. Let’s check and fix both datasets:\n\nProtected areas\n\n# Check for invalid geometries\nmap_int(mpa_sf_list, \\(x) sum(!st_is_valid(x)))\n#&gt;            cddaareas      natura2000areas marineprotectedareas \n#&gt;                    1                    1                    1\n\n\n# Fix any invalid geometries\nmpa_sf_list &lt;- map(mpa_sf_list, st_make_valid)\n\n\n\nInfrastructure\n\nmap_int(infra_sf_list, \\(x) sum(!st_is_valid(x)))\n#&gt;        platforms        pipelines pcablesbshcontis      pcablesshom \n#&gt;                0                0                0                0 \n#&gt;     pcablesrijks       pcablesnve \n#&gt;                0                0\n\n\ninfra_sf_list &lt;- map(infra_sf_list, st_make_valid)\n\n\n\n\nOrganising Data Structures\nNow we need to organise our data for analysis. The protected areas and infrastructure require different approaches:\n\nProtected areas: We’ll combine the three MPA layers into a single dataset. Our analysis question is “which protected areas intersect with infrastructure?” We want to test all MPAs together, while preserving a type column to distinguish their source. This requires standardising column names across layers.\nInfrastructure: We’ll keep pipelines, cables, and platforms as separate objects. Mixing different geometry types (points and lines) in a single sf object is awkward for both analysis and plotting, so it’s more practical to keep them separate.\n\n\nCombining protected area layers\nThe three MPA layers have different column names. For example, site names are stored as sitename in two layers but name in the third:\n\nmap(mpa_sf_list, names)\n#&gt; $cddaareas\n#&gt; [1] \"id\"         \"country\"    \"sitename\"   \"designated\" \"majorecosy\"\n#&gt; [6] \"geometry\"  \n#&gt; \n#&gt; $natura2000areas\n#&gt; [1] \"id\"        \"sitename\"  \"country\"   \"sitedesc\"  \"directive\" \"mar_perc\" \n#&gt; [7] \"geometry\" \n#&gt; \n#&gt; $marineprotectedareas\n#&gt; [1] \"id\"         \"rsc\"        \"name\"       \"country\"    \"designatio\"\n#&gt; [6] \"status\"     \"geometry\"\n\nTo combine them with bind_rows(), we need to standardise these first. We’ll use the schema we defined in Planning Our Data Schema, where the from field maps source column names to our target names (e.g., name → sitename).\nHere’s a helper function that applies these transformations:\n\nstandardise_sf &lt;- function(data, schema = NULL) {\n  if (is.null(schema)) {\n    return(data)\n  }\n\n  # Type conversion map using readr-style shorthand\n  type_map &lt;- list(\n    c = as.character,\n    i = as.integer,\n    d = as.double,\n    l = as.logical,\n    D = as.Date,\n    T = as.POSIXct\n  )\n\n  # Build rename vector: target_name = source_name\n  # If 'from' not specified, use the target name (no rename)\n  rename_vec &lt;- map_chr(names(schema), ~ schema[[.x]]$from %||% .x)\n  names(rename_vec) &lt;- names(schema)\n\n  # Get type for each column, defaulting to \"c\" (character)\n  get_type &lt;- function(col) type_map[[schema[[col]]$type %||% \"c\"]]\n\n  data |&gt;\n    select(any_of(rename_vec)) |&gt;\n    mutate(across(any_of(names(schema)), \\(x) get_type(cur_column())(x)))\n}\n\nNow we apply the schema to each layer, add a type label to track the source, and combine:\n\n# Standardise each layer and combine with type labels\ntype_labels &lt;- c(\n  cddaareas = \"CDDA\",\n  natura2000areas = \"Natura 2000\",\n  marineprotectedareas = \"MPA\"\n)\n\nmpa_combined &lt;- imap(\n  mpa_sf_list,\n  \\(x, y) {\n    standardise_sf(x, mpa_schemas[[y]]$cols) |&gt;\n      mutate(type = type_labels[[y]])\n  }\n) |&gt;\n  bind_rows()\nrownames(mpa_combined) &lt;- NULL\n\nmpa_combined\n\n\n  \n\n\n\n\n\nOrganising infrastructure layers\nWe reorganise infra_sf_list (named by WFS layer) into a new list organised by infrastructure type, consolidating the four cable sources:\n\ninfra_by_type &lt;- list(\n  pipelines = infra_sf_list$pipelines,\n  cables = bind_rows(infra_sf_list[startsWith(\n    names(infra_sf_list),\n    \"pcables\"\n  )]),\n  platforms = infra_sf_list$platforms\n)\n\nmap_int(infra_by_type, nrow)\n#&gt; pipelines    cables platforms \n#&gt;      3187       427      1177"
  },
  {
    "objectID": "tutorials/tutorial-01.html#spatial-intersection-analysis",
    "href": "tutorials/tutorial-01.html#spatial-intersection-analysis",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Spatial Intersection Analysis",
    "text": "Spatial Intersection Analysis\nNow we’re ready for the core analysis: identifying which protected areas are affected by subsea infrastructure.\n\nUnderstanding Spatial Predicates\nThe sf package provides several functions for testing spatial relationships:\n\n\n\n\n\n\n\n\nFunction\nReturns\nUse case\n\n\n\n\nst_intersects()\nSparse index list\nWhich features touch or overlap?\n\n\nst_intersection()\nNew geometries\nWhat is the actual overlapping area?\n\n\nst_within()\nSparse index list\nWhich features are completely inside?\n\n\nst_contains()\nSparse index list\nWhich features completely contain others?\n\n\n\nFor our analysis, we’ll use st_intersects() to find protected areas that have any spatial overlap with infrastructure, even if a pipeline just crosses through.\n\n\n\n\n\n\nNotest_intersects() vs st_intersection()\n\n\n\n\n\n\nst_intersects() is a predicate: it tests whether geometries touch/overlap and returns a logical result. It’s fast because it doesn’t compute new geometries.\nst_intersection() is an operation: it computes and returns the actual overlapping geometry. It’s slower but gives you the precise overlap area.\n\nFor identifying which features are affected, use st_intersects(). For calculating how much area is affected, use st_intersection().\n\n\n\n\n\n\n\n\n\nTipBenefits of using a projected CRS\n\n\n\nBy requesting data in EPSG:3035, we avoid the complexities of spherical geometry. The sf package uses planar geometry operations (via GEOS) for projected coordinate systems, which are faster and more tolerant of minor geometry issues than the s2 spherical geometry library used for geographic CRS like WGS84.\n\n\n\n\nUnderstanding st_intersects() Output\nst_intersects(x, y) returns a sparse geometry binary predicate list (sgbp). Each list element corresponds to a feature in x and contains the row indices of features in y that it intersects:\n\n# Create 3 circular polygons at different positions\n# st_point() creates a point, st_buffer() expands it into a circle\ndemo_features &lt;- st_sfc(\n  st_buffer(st_point(c(0, 0)), 1),\n  st_buffer(st_point(c(3, 0)), 1),\n  st_buffer(st_point(c(5, 0)), 1)\n)\n\n# Create a region to check for intersection (overlaps features 2 and 3)\ndemo_check_area &lt;- st_buffer(st_point(c(4, 0)), 2) |&gt; st_sfc()\n\n# Which features intersect the check area?\nresult &lt;- st_intersects(demo_features, demo_check_area)\nresult\n#&gt; Sparse geometry binary predicate list of length 3, where the predicate\n#&gt; was `intersects'\n#&gt;  1: (empty)\n#&gt;  2: 1\n#&gt;  3: 1\n\n\n\n\n\n\n\nTipVisualise intersections\n\n\n\n\n\n\n\nCode\nggplot() +\n  geom_sf(\n    data = st_sf(geometry = demo_check_area),\n    fill = \"red\", alpha = 0.2, color = \"red\", linetype = \"dashed\", linewidth = 1\n  ) +\n  geom_sf(\n    data = st_sf(\n      id = factor(1:3),\n      intersects = lengths(st_intersects(demo_features, demo_check_area)) &gt; 0,\n      geometry = demo_features\n    ),\n    aes(fill = intersects), alpha = 0.5, color = \"black\"\n  ) +\n  geom_sf_text(\n    data = st_sf(id = 1:3, geometry = demo_features),\n    aes(label = id), size = 5\n  ) +\n  scale_fill_manual(\n    values = c(\"TRUE\" = \"green\", \"FALSE\" = \"grey70\"),\n    labels = c(\"TRUE\" = \"Yes\", \"FALSE\" = \"No\"),\n    name = \"Intersects?\"\n  ) +\n  theme_minimal() +\n  theme(axis.text = element_blank(), axis.title = element_blank())\n\n\n\n\n\n\n\n\nFigure 4: Features 2 and 3 (green) intersect the check area (dashed red), while feature 1 does not.\n\n\n\n\n\n\n\n\nTo use this for filtering or flagging, we convert to a logical vector using lengths() &gt; 0, which is TRUE for features that intersect with at least one feature in the other dataset:\n\n# Convert to counts, then to logical\nlengths(result)\n#&gt; [1] 0 1 1\nlengths(result) &gt; 0\n#&gt; [1] FALSE  TRUE  TRUE\n\nThis lengths(st_intersects(...)) &gt; 0 pattern is the standard way to create logical flags from spatial intersection tests.\n\n\nComputing Intersections\nRather than testing each infrastructure type separately, we map st_intersects() over infra_by_type. For each infrastructure type, st_intersects() returns a sparse list with one entry per MPA (in the same row order as mpa_combined), and lengths() &gt; 0 converts this to a logical vector. Since the row order is preserved, we can use bind_cols() to combine these into a data frame of intersection flags. We also add an any column that’s TRUE if a protected area intersects with any infrastructure type:\n\n# Compute intersection flags for each infrastructure type\nintersections &lt;- map(\n  infra_by_type,\n  \\(x) lengths(st_intersects(mpa_combined, x)) &gt; 0\n) |&gt;\n  bind_cols() |&gt;\n  mutate(any = pipelines | cables | platforms)\n\n# Combine with MPA attributes (without geometry for efficient summaries)\nmpa_analysis &lt;- mpa_combined |&gt;\n  st_drop_geometry() |&gt;\n  bind_cols(intersections)\n\nmpa_analysis\n\n\n  \n\n\n\nThis gives us a tidy data frame where each row is a protected area and each column indicates whether it intersects with that infrastructure type. Now we can use standard dplyr operations to summarise."
  },
  {
    "objectID": "tutorials/tutorial-01.html#summary-and-visualisation",
    "href": "tutorials/tutorial-01.html#summary-and-visualisation",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Summary and Visualisation",
    "text": "Summary and Visualisation\n\nSummary Table\nLet’s create a summary table breaking down the results by protected area type:\n\nsummary_table &lt;- mpa_analysis |&gt;\n  group_by(type) |&gt;\n  summarise(\n    `Total MPAs` = n(),\n    `With Pipelines` = sum(pipelines),\n    `With Cables` = sum(cables),\n    `With Platforms` = sum(platforms),\n    `With Any Infrastructure` = sum(any),\n    .groups = \"drop\"\n  ) |&gt;\n  mutate(\n    `% Affected` = round(100 * `With Any Infrastructure` / `Total MPAs`, 1)\n  )\n\nknitr::kable(summary_table)\n\n\n\nTable 1: Protected areas intersecting with subsea infrastructure in the North Sea\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntype\nTotal MPAs\nWith Pipelines\nWith Cables\nWith Platforms\nWith Any Infrastructure\n% Affected\n\n\n\n\nCDDA\n358\n20\n35\n12\n41\n11.5\n\n\nMPA\n156\n33\n20\n20\n50\n32.1\n\n\nNatura 2000\n56\n17\n19\n11\n26\n46.4\n\n\n\n\n\n\n\n\n\n\nPreparing Geometries for Visualisation\nTo visualise the results, we need to combine the intersection flags with the MPA geometries. We also simplify the geometries because marine protected area boundaries often contain highly detailed coastlines with thousands of vertices, which slows down plotting.\nWe temporarily disable s2 (spherical geometry) because st_simplify() uses the GEOS library, which expects planar coordinates. Since our data is already in a projected CRS (EPSG:3035), this is safe:\n\n# Add intersection flags to MPA geometries and simplify\nsf_use_s2(FALSE)\n\nmpa_simple &lt;- mpa_combined |&gt;\n  bind_cols(intersections) |&gt;\n  st_simplify(dTolerance = 2000, preserveTopology = TRUE)\n\nsf_use_s2(TRUE)\n\nThe dTolerance parameter specifies the simplification tolerance in CRS units. Since we’re using EPSG:3035 (metric), dTolerance = 2000 means 2 km, imperceptible at our map scale but dramatically faster to render.\n\n# Compare object sizes as proxy for complexity reduction\noriginal_size &lt;- object.size(mpa_combined)\nsimplified_size &lt;- object.size(mpa_simple)\n\nsprintf(\n  \"Object size reduced from %s to %s (%.0f%% reduction)\",\n  format(original_size, units = \"MB\"),\n  format(simplified_size, units = \"MB\"),\n  100 * (1 - as.numeric(simplified_size) / as.numeric(original_size))\n)\n#&gt; [1] \"Object size reduced from 73.9 Mb to 5.2 Mb (93% reduction)\"\n\n\n\n\n\n\n\nNote\n\n\n\nAlways perform spatial analysis on the original geometries, then simplify for visualisation. Simplifying before analysis can introduce errors in intersection tests.\n\n\n\n\nVisualising the Results\n\nMap of All Protected Areas\nFirst, let’s create a base map showing all protected areas, coloured by whether they intersect with infrastructure. Compare with Figure 2 which showed the three MPA types before analysis:\n\nggplot() +\n  geom_sf(data = europe, fill = \"gray95\", colour = \"gray70\") +\n  geom_sf(\n    data = mpa_simple,\n    aes(fill = any, colour = any),\n    linewidth = 0.1,\n    alpha = 0.3\n  ) +\n  scale_fill_manual(\n    values = c(\"FALSE\" = \"lightgreen\", \"TRUE\" = \"coral\"),\n    labels = c(\"No intersection\", \"Intersects infrastructure\"),\n    name = NULL\n  ) +\n  scale_colour_manual(\n    values = c(\"FALSE\" = \"lightgreen\", \"TRUE\" = \"coral\"),\n    guide = \"none\"\n  ) +\n  coord_sf(\n    xlim = c(bbox_ext[\"xmin\"], bbox_ext[\"xmax\"]),\n    ylim = c(bbox_ext[\"ymin\"], bbox_ext[\"ymax\"])\n  ) +\n  labs(\n    title = \"Protected Areas and Infrastructure Overlap\",\n    subtitle = \"North Sea region\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\nFigure 5: Protected areas in the North Sea coloured by infrastructure intersection status\n\n\n\n\n\n\n\nMap with Infrastructure Overlay\nNow let’s add the infrastructure layers to see the spatial pattern:\n\nggplot() +\n  # Basemap\n  geom_sf(data = europe, fill = \"gray95\", colour = \"gray70\") +\n  # Protected areas\n  geom_sf(\n    data = mpa_simple,\n    aes(fill = any),\n    colour = \"gray50\",\n    linewidth = 0.1,\n    alpha = 0.3\n  ) +\n  # Cables\n  geom_sf(\n    data = infra_by_type$cables,\n    aes(colour = \"Cables\"),\n    linewidth = 0.3,\n    alpha = 0.5,\n    key_glyph = \"path\"\n  ) +\n  # Pipelines\n  geom_sf(\n    data = infra_by_type$pipelines,\n    aes(colour = \"Pipelines\"),\n    linewidth = 0.5,\n    key_glyph = \"path\"\n  ) +\n  # Platforms\n  geom_sf(\n    data = infra_by_type$platforms,\n    aes(colour = \"Platforms\"),\n    size = 2,\n    key_glyph = \"point\"\n  ) +\n  scale_fill_manual(\n    values = c(\"FALSE\" = \"lightgreen\", \"TRUE\" = \"coral\"),\n    labels = c(\"No intersection\", \"Intersects infrastructure\"),\n    name = \"Protected Area Status\"\n  ) +\n  scale_colour_manual(\n    values = c(\n      \"Cables\" = \"purple\",\n      \"Pipelines\" = \"orange\",\n      \"Platforms\" = \"red\"\n    ),\n    name = \"Infrastructure\"\n  ) +\n  coord_sf(\n    xlim = c(bbox_ext[\"xmin\"], bbox_ext[\"xmax\"]),\n    ylim = c(bbox_ext[\"ymin\"], bbox_ext[\"ymax\"])\n  ) +\n  labs(\n    title = \"Marine Protected Areas and Subsea Infrastructure\",\n    subtitle = \"North Sea region\",\n    caption = \"Data: EMODnet Human Activities\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\") +\n  guides(\n    fill = guide_legend(order = 1),\n    colour = guide_legend(order = 2)\n  )\n\n\n\n\n\n\n\nFigure 6: Protected areas with subsea infrastructure overlay\n\n\n\n\n\n\n\nInteractive Exploration\nFor a more detailed exploration, let’s create an interactive map with tmap. Setting tmap_mode(\"view\") switches from static plots to interactive Leaflet maps:\n\ntmap_mode(\"view\")\n\ntm_shape(mpa_simple) +\n  tm_polygons(\n    fill = \"any\",\n    fill.scale = tm_scale_categorical(values = c(\"lightgreen\", \"coral\")),\n    fill.legend = tm_legend(title = \"Intersects Infrastructure\"),\n    fill_alpha = 0.3,\n    col = \"any\",\n    col.scale = tm_scale_categorical(values = c(\"lightgreen\", \"coral\")),\n    col.legend = tm_legend(show = FALSE),\n    lwd = 0.5,\n    popup.vars = c(\n      \"sitename\",\n      \"type\",\n      \"pipelines\",\n      \"cables\",\n      \"platforms\"\n    )\n  ) +\n  tm_shape(infra_by_type$pipelines) +\n  tm_lines(col = \"orange\", lwd = 2, popup.vars = TRUE) +\n  tm_add_legend(type = \"lines\", col = \"orange\", lwd = 2, labels = \"Pipelines\") +\n  tm_shape(infra_by_type$cables) +\n  tm_lines(col = \"purple\", lwd = 1, col_alpha = 0.5) +\n  tm_add_legend(type = \"lines\", col = \"purple\", lwd = 1, labels = \"Cables\") +\n  tm_shape(infra_by_type$platforms) +\n  tm_symbols(fill = \"red\", size = 0.05, popup.vars = TRUE) +\n  tm_add_legend(\n    type = \"symbols\",\n    fill = \"red\",\n    size = 0.3,\n    labels = \"Platforms\"\n  )"
  },
  {
    "objectID": "tutorials/tutorial-01.html#interpretation-and-conclusion",
    "href": "tutorials/tutorial-01.html#interpretation-and-conclusion",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Interpretation and Conclusion",
    "text": "Interpretation and Conclusion\n\nKey Findings\nThis analysis identified protected areas in the North Sea that spatially overlap with subsea infrastructure. Of the 570 protected areas examined:\n\n117 (21%) intersect with at least one type of energy infrastructure\nNatura 2000 sites are most affected: 46% intersect with infrastructure, compared to 32% of other MPAs and 12% of CDDA sites\nCables are the most common intersection: 74 protected areas intersect with power cables, compared to 70 with pipelines and 43 with platforms\n\n\n\nInterpreting the Patterns\nThe higher intersection rate for Natura 2000 sites likely reflects their typically larger size and offshore extent. These sites often cover broad areas of seabed habitat like sandbanks (e.g., Dogger Bank), which are also attractive corridors for infrastructure routing. CDDA sites, with the lowest intersection rate, include many smaller coastal reserves where infrastructure is less prevalent.\nThe prominence of cable intersections reflects the rapid expansion of offshore wind and cross-border power interconnectors in the North Sea. Unlike legacy oil and gas infrastructure (pipelines, platforms), cable networks are actively growing as part of Europe’s energy transition.\nThese patterns raise questions for further investigation:\n\nSize effects: Do larger MPAs have higher intersection rates simply due to their greater spatial extent?\nCoastal vs offshore: Are offshore MPAs disproportionately affected compared to coastal sites?\nGeographic clustering: Are intersections concentrated in particular areas (e.g., the southern North Sea wind development zone)?\nTemporal trends: How has infrastructure-MPA overlap changed over time, and what does planned infrastructure imply for future conflicts?\n\n\n\nEcological and Policy Implications\nThese findings are relevant for:\n\nMarine spatial planning: Understanding existing infrastructure-conservation conflicts helps inform future planning decisions\nEnvironmental impact assessment: Identifying where infrastructure crosses protected areas can prioritise monitoring efforts\nPolicy compliance: Supports assessment of whether activities within protected areas align with conservation objectives under the Habitats Directive and Marine Strategy Framework Directive\n\n\n\nLimitations and Caveats\nThis analysis has several limitations to consider:\n\nSpatial intersection ≠ impact: A pipeline crossing a protected area doesn’t necessarily cause ecological harm. Actual impacts depend on factors including burial depth, operational status, and habitat sensitivity\nData currency: EMODnet data is regularly updated but may not reflect the most recent infrastructure installations or MPA designations\nGeometric simplification: We tested only for intersection; a more detailed analysis might calculate the length of pipeline within each MPA or buffer distances around platforms\nMissing infrastructure: Some infrastructure (e.g., certain cable routes) may not be fully represented in the available datasets\n\n\n\nNext Steps\nTo extend this analysis, you could:\n\nCalculate the length of pipelines/cables within each protected area using st_intersection()\nAdd buffer zones around platforms to assess potential impact areas\nJoin with habitat classification data to identify which habitat types are most affected\nIncorporate temporal data to track how overlap has changed over time\n\n\n\nWhat You’ve Learned\nIn this tutorial, you learned how to:\n\nExplore EMODnet WFS services to discover available data\nDownload vector data with spatial filters for efficient queries\nPrepare and validate spatial data for analysis\nApply spatial intersection techniques to identify overlapping features\nVisualise results using both static (ggplot2) and interactive (tmap) maps\n\nThese skills form the foundation for marine spatial analysis and can be applied to many other research questions involving EMODnet data."
  },
  {
    "objectID": "tutorials/tutorial-01.html#further-resources",
    "href": "tutorials/tutorial-01.html#further-resources",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Further Resources",
    "text": "Further Resources\n\nEMODnet Seabed Habitats Portal: Explore more protected area and habitat data\nEMODnet Human Activities Portal: Access additional infrastructure datasets\nemodnet.wfs package documentation: Full function reference\nsf package vignettes: Deep dive into spatial operations\nGeocomputation with R: Comprehensive spatial analysis guide\n\nReady for more? Continue to Tutorial 2 to learn about accessing raster data with EMODnet WCS services."
  },
  {
    "objectID": "tutorials/tutorial-03.html",
    "href": "tutorials/tutorial-03.html",
    "title": "3: Biodiversity Change and Depth",
    "section": "",
    "text": "This tutorial is currently under development.\n\n\n\nUsing emdn_get_features() to access spatiotemporal diversity metrics from EMODnet Biology (WFS)\nUsing emdn_get_coverage() to retrieve raster bathymetry from EMODnet Bathymetry (WCS)\nPerforming spatial joins and point-based extraction from raster datasets\nVisualising and summarising patterns of species gain/loss across depth gradients\n\n\n\n\nWFS (vector): - Layer ID: all_diversity_measures - Source: EMODnet Biology - Key variables: Species loss, species gain, β-diversity, time periods\nWCS (raster): - Layer ID: emodnet__mean_2020 - Source: EMODnet Bathymetry - Description: Mean depth (m), regularly gridded\n\n\n\nNorth Sea\nBounding box (WGS84): xmin = 1.5, ymin = 53, xmax = 6.5, ymax = 58\nCheck back soon for the complete tutorial!"
  },
  {
    "objectID": "tutorials/tutorial-03.html#tutorial-content",
    "href": "tutorials/tutorial-03.html#tutorial-content",
    "title": "3: Biodiversity Change and Depth",
    "section": "",
    "text": "This tutorial is currently under development.\n\n\n\nUsing emdn_get_features() to access spatiotemporal diversity metrics from EMODnet Biology (WFS)\nUsing emdn_get_coverage() to retrieve raster bathymetry from EMODnet Bathymetry (WCS)\nPerforming spatial joins and point-based extraction from raster datasets\nVisualising and summarising patterns of species gain/loss across depth gradients\n\n\n\n\nWFS (vector): - Layer ID: all_diversity_measures - Source: EMODnet Biology - Key variables: Species loss, species gain, β-diversity, time periods\nWCS (raster): - Layer ID: emodnet__mean_2020 - Source: EMODnet Bathymetry - Description: Mean depth (m), regularly gridded\n\n\n\nNorth Sea\nBounding box (WGS84): xmin = 1.5, ymin = 53, xmax = 6.5, ymax = 58\nCheck back soon for the complete tutorial!"
  }
]