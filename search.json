[
  {
    "objectID": "tutorials/tutorial-04.html",
    "href": "tutorials/tutorial-04.html",
    "title": "4: Functional Traits Across Seabed Habitats",
    "section": "",
    "text": "This tutorial is currently under development.\n\n\n\nDemonstrating combined use of emodnet.wfs, emodnet.wcs, and CopernicusMarine packages\nRetrieving and visualising body size traits for benthic species using trait databases\nExploring trait–environment relationships across habitat types\nPractical geospatial workflows including raster extraction and spatial joins\n\n\n\n\n\nEMODnet WFS:\n\neb185_benthos_full_matched: Benthic species records in the Aegean\neu_seabed_habitats_2019: Seabed habitat polygons\n\nEMODnet WCS:\n\nemodnet__mean_2020: Bathymetry raster (mean depth of seafloor)\n\nCopernicus Marine Service:\n\nGLOBAL_MULTIYEAR_PHY_001_030: Bottom temperature and/or salinity reanalysis data\n\nExternal Resources:\n\nMOBS (Marine Organism Body Size) database: github.com/crmcclain/MOBS_OPEN\n\n\n\n\n\nAegean Sea\nCheck back soon for the complete tutorial!"
  },
  {
    "objectID": "tutorials/tutorial-04.html#tutorial-content",
    "href": "tutorials/tutorial-04.html#tutorial-content",
    "title": "4: Functional Traits Across Seabed Habitats",
    "section": "",
    "text": "This tutorial is currently under development.\n\n\n\nDemonstrating combined use of emodnet.wfs, emodnet.wcs, and CopernicusMarine packages\nRetrieving and visualising body size traits for benthic species using trait databases\nExploring trait–environment relationships across habitat types\nPractical geospatial workflows including raster extraction and spatial joins\n\n\n\n\n\nEMODnet WFS:\n\neb185_benthos_full_matched: Benthic species records in the Aegean\neu_seabed_habitats_2019: Seabed habitat polygons\n\nEMODnet WCS:\n\nemodnet__mean_2020: Bathymetry raster (mean depth of seafloor)\n\nCopernicus Marine Service:\n\nGLOBAL_MULTIYEAR_PHY_001_030: Bottom temperature and/or salinity reanalysis data\n\nExternal Resources:\n\nMOBS (Marine Organism Body Size) database: github.com/crmcclain/MOBS_OPEN\n\n\n\n\n\nAegean Sea\nCheck back soon for the complete tutorial!"
  },
  {
    "objectID": "tutorials/tutorial-02.html",
    "href": "tutorials/tutorial-02.html",
    "title": "2: Zooplankton and Plaice Nursery Grounds",
    "section": "",
    "text": "This tutorial is currently under development.\n\n\n\nUnderstanding how to identify and retrieve relevant raster layers using describe_coverages()\nUsing emdn_get_coverage() to download WCS data for a specific area and time\nApplying raster alignment, masking, and standardisation for comparative analysis\nInterpreting spatial patterns in relative abundance and their ecological relevance\n\n\n\n\n\nEMODnet Biology WCS: Copepod relative abundance layers (Acartia spp., Temora longicornis, Calanus finmarchicus)\nEMODnet Seabed Habitats WCS: Plaice Essential Fish Habitat (nursery grounds) predictions (GRAY_INDEX band)\n\n\n\n\nEastern English Channel\nBounding box: xmin = 0.0, ymin = 49.5, xmax = 2.5, ymax = 51.0\nCheck back soon for the complete tutorial!"
  },
  {
    "objectID": "tutorials/tutorial-02.html#tutorial-content",
    "href": "tutorials/tutorial-02.html#tutorial-content",
    "title": "2: Zooplankton and Plaice Nursery Grounds",
    "section": "",
    "text": "This tutorial is currently under development.\n\n\n\nUnderstanding how to identify and retrieve relevant raster layers using describe_coverages()\nUsing emdn_get_coverage() to download WCS data for a specific area and time\nApplying raster alignment, masking, and standardisation for comparative analysis\nInterpreting spatial patterns in relative abundance and their ecological relevance\n\n\n\n\n\nEMODnet Biology WCS: Copepod relative abundance layers (Acartia spp., Temora longicornis, Calanus finmarchicus)\nEMODnet Seabed Habitats WCS: Plaice Essential Fish Habitat (nursery grounds) predictions (GRAY_INDEX band)\n\n\n\n\nEastern English Channel\nBounding box: xmin = 0.0, ymin = 49.5, xmax = 2.5, ymax = 51.0\nCheck back soon for the complete tutorial!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "",
    "text": "Learn how to access and analyze marine biological and environmental data from EMODnet using R. These hands-on tutorials guide you through real-world marine spatial analysis workflows, from accessing data via web services to creating publication-ready visualizations.\nWhether you’re investigating marine protected areas, exploring species distributions, or analyzing biodiversity change, these tutorials provide reproducible code and practical examples you can adapt to your own research questions.\n\n\n\n\n\n\nTipNew to geospatial analysis?\n\n\n\nIf you’re unfamiliar with spatial data concepts, coordinate systems, or the difference between vector and raster data, start with our Geospatial Concepts page."
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "",
    "text": "Learn how to access and analyze marine biological and environmental data from EMODnet using R. These hands-on tutorials guide you through real-world marine spatial analysis workflows, from accessing data via web services to creating publication-ready visualizations.\nWhether you’re investigating marine protected areas, exploring species distributions, or analyzing biodiversity change, these tutorials provide reproducible code and practical examples you can adapt to your own research questions.\n\n\n\n\n\n\nTipNew to geospatial analysis?\n\n\n\nIf you’re unfamiliar with spatial data concepts, coordinate systems, or the difference between vector and raster data, start with our Geospatial Concepts page."
  },
  {
    "objectID": "index.html#what-youll-learn",
    "href": "index.html#what-youll-learn",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "What You’ll Learn",
    "text": "What You’ll Learn\nThese tutorials demonstrate how to:\n\nAccess marine data programmatically using EMODnet’s web services (WFS and WCS)\nWork with vector data representing species occurrences, habitat boundaries, and human activities\nAnalyze raster data including bathymetry, species distributions, and environmental variables\nIntegrate multiple data sources from EMODnet, Copernicus Marine Service, and trait databases\nApply spatial operations such as intersection, masking, and point extraction\nVisualize spatial patterns relevant to marine conservation and management\n\nBy the end of these tutorials, you’ll be able to independently access, analyze, and visualize EMODnet data for your own marine research questions."
  },
  {
    "objectID": "index.html#tutorial-series",
    "href": "index.html#tutorial-series",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "Tutorial Series",
    "text": "Tutorial Series\n\n\n\n\n\n1 Protected Areas and Subsea Infrastructure\nIdentifying Protected Areas Affected by Subsea Infrastructure in the North Sea\nDifficulty: Beginner | Time: ~45 minutes | Data: WFS (vector)\n\nLearn the fundamentals of accessing EMODnet WFS data by identifying marine protected areas that overlap with subsea infrastructure like pipelines and cables. This tutorial introduces spatial intersection operations and provides a foundation for marine spatial planning analyses.\nYou’ll work with: Marine protected area boundaries, pipeline locations, subsea cable networks, platform locations\n\n\n\nStart Tutorial 1\n\n\n\n\n\n\n2 Zooplankton and Plaice Nursery Grounds\nExploring the Overlap Between Zooplankton Distributions and Predicted Plaice Nursery Grounds\nDifficulty: Beginner | Time: ~60 minutes | Data: WCS (raster)\n\nDiscover how to access and analyze gridded environmental data using EMODnet WCS services. Explore the spatial relationship between zooplankton abundance and fish nursery habitats in the Eastern English Channel using raster analysis techniques.\nYou’ll work with: Copepod abundance grids, fish habitat suitability models, multi-band raster data\n\n\n\nStart Tutorial 2\n\n\n\n\n\n\n3 Biodiversity Change and Depth\nRelating Marine Biodiversity Change to Depth in the North Sea\nDifficulty: Intermediate | Time: ~60 minutes | Data: WFS + WCS (vector + raster)\n\nCombine vector and raster data to investigate environmental drivers of biodiversity change. Extract bathymetric values at biodiversity sampling points and explore relationships between depth and species turnover across the North Sea.\nYou’ll work with: Biodiversity change metrics, bathymetric depth models, vector-raster integration\n\n\n\nStart Tutorial 3\n\n\n\n\n\n\n4 Functional Traits Across Seabed Habitats\nExploring Functional Traits Across Seabed Habitats in the Aegean Sea\nDifficulty: Advanced | Time: ~90 minutes | Data: WFS + WCS + External sources\n\nIntegrate EMODnet data with external trait databases and Copernicus Marine Service environmental data. Investigate how benthic species body size varies across habitat types and environmental gradients in the Aegean Sea.\nYou’ll work with: Benthic species occurrences, seabed habitat maps, trait databases, temperature reanalysis data\n\n\n\nStart Tutorial 4"
  },
  {
    "objectID": "index.html#who-these-tutorials-are-for",
    "href": "index.html#who-these-tutorials-are-for",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "Who These Tutorials Are For",
    "text": "Who These Tutorials Are For\nThese tutorials are designed for:\n\nMarine researchers working with spatial data on species distributions, habitats, or human activities\nConservation practitioners conducting marine spatial planning, MPA assessments, or environmental impact analyses\nData scientists interested in applying geospatial methods to marine applications\nGraduate students learning marine ecology, spatial analysis, or data science\nPolicy analysts requiring evidence-based spatial information for marine management"
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "Prerequisites",
    "text": "Prerequisites\nTo get the most from these tutorials, you should have:\nR Programming:\n\nBasic to intermediate R skills (working with data frames, installing packages, running functions)\nFamiliarity with the tidyverse is helpful but not required\nExperience with RStudio or similar R development environment\n\nGeospatial Background:\n\nUnderstanding of basic spatial concepts (coordinates, projections, spatial data types)\nAwareness of vector vs. raster data\nFamiliarity with common spatial operations\n\n\n\n\n\n\n\nNote\n\n\n\nIf you’re new to geospatial analysis, visit our Geospatial Concepts page for an introduction to key concepts before starting the tutorials."
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "Getting Started",
    "text": "Getting Started\n\nInstallation\nInstall the required packages using the following code:\n\n# Install packages from CRAN\ninstall.packages(c(\n    \"emodnet.wfs\",\n    \"sf\",\n    \"terra\",\n    \"dplyr\",\n    \"ggplot2\",\n    \"tmap\"\n))\n\n# Install emodnet.wcs' latest version (not yet on CRAN)\ninstall.packages('emodnet.wcs', repos = c('https://emodnet.r-universe.dev', 'https://cloud.r-project.org'))\n\n\n\nQuick Start\n\nNew to geospatial analysis? → Start with Geospatial Concepts\nReady to dive in? → Begin with Tutorial 1 to learn WFS basics\nInterested in raster analysis? → Jump to Tutorial 2 for WCS workflows\nWant to combine data sources? → Try Tutorial 3 or Tutorial 4"
  },
  {
    "objectID": "index.html#resources-and-links",
    "href": "index.html#resources-and-links",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "Resources and Links",
    "text": "Resources and Links\n\nEMODnet Resources\n\nEMODnet Biology Portal - Access marine biological data\nEMODnet Seabed Habitats - Habitat maps and classifications\nEMODnet Bathymetry - Depth data and terrain models\nEMODnet Human Activities - Infrastructure and activity data\n\n\n\nR Package Documentation\n\nemodnet.wfs on GitHub - Access WFS vector data\nemodnet.wcs on GitHub - Access WCS raster data\nsf package - Spatial vector data in R\nterra package - Spatial raster data in R\n\n\n\nLearning Resources\n\nGeocomputation with R - Comprehensive guide to spatial analysis in R\nSpatial Data Science - Spatial data methods and applications\nsf package vignettes - Detailed sf documentation"
  },
  {
    "objectID": "index.html#about-this-project",
    "href": "index.html#about-this-project",
    "title": "EMODnet Biology Geospatial R Tutorials",
    "section": "About This Project",
    "text": "About This Project\nThese tutorials are part of the EMODnet Biology initiative. Learn more about the project, contributors, and funding on the About page."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "EMODnet Biology is the biological data portal of the European Marine Observation and Data Network (EMODnet). EMODnet is a network of European organisations working together to assemble marine data, data products, and metadata from diverse sources in a standardized way.\nEMODnet Biology provides free and open access to marine biological observations, species distributions, and biodiversity data from European seas. The portal aggregates data from diverse sources including research institutions, monitoring programmes, and citizen science initiatives, making it easily accessible for marine research, policy-making, and conservation efforts."
  },
  {
    "objectID": "about.html#about-emodnet-biology",
    "href": "about.html#about-emodnet-biology",
    "title": "About",
    "section": "",
    "text": "EMODnet Biology is the biological data portal of the European Marine Observation and Data Network (EMODnet). EMODnet is a network of European organisations working together to assemble marine data, data products, and metadata from diverse sources in a standardized way.\nEMODnet Biology provides free and open access to marine biological observations, species distributions, and biodiversity data from European seas. The portal aggregates data from diverse sources including research institutions, monitoring programmes, and citizen science initiatives, making it easily accessible for marine research, policy-making, and conservation efforts."
  },
  {
    "objectID": "about.html#about-this-tutorial-initiative",
    "href": "about.html#about-this-tutorial-initiative",
    "title": "About",
    "section": "About This Tutorial Initiative",
    "text": "About This Tutorial Initiative\nThese tutorials were developed as part of the EMODnet Biology initiative to demonstrate how researchers, students, and practitioners can access and analyze EMODnet data programmatically using R. By providing practical, reproducible workflows using real marine data, we aim to:\n\nLower barriers to accessing and using EMODnet biological and environmental data\nDemonstrate the value of web services (WFS and WCS) for programmatic data access\nShowcase real-world applications relevant to marine conservation and spatial planning\nBuild capacity in marine spatial data science across the research community\n\nThe tutorials highlight how EMODnet data can be integrated with other European marine data infrastructures, such as Copernicus Marine Service, to support evidence-based marine management and research."
  },
  {
    "objectID": "about.html#emodnet-web-services",
    "href": "about.html#emodnet-web-services",
    "title": "About",
    "section": "EMODnet Web Services",
    "text": "EMODnet Web Services\nEMODnet provides standardized geospatial web services following Open Geospatial Consortium (OGC) specifications. These services are maintained by the EMODnet thematic portals (Biology, Bathymetry, Seabed Habitats, Human Activities, etc.), each operated by a consortium of European marine research institutions.\nEach thematic portal is responsible for:\n\nAggregating data from multiple sources across Europe\nStandardizing and quality-controlling the data\nHosting and maintaining the web service infrastructure\nEnsuring long-term data preservation and access\n\nThis infrastructure enables researchers and practitioners to programmatically access marine data without needing to manage large file downloads or navigate multiple data repositories."
  },
  {
    "objectID": "about.html#the-r-packages",
    "href": "about.html#the-r-packages",
    "title": "About",
    "section": "The R Packages",
    "text": "The R Packages\nThese tutorials demonstrate two R packages developed specifically for accessing EMODnet data services:\nemodnet.wfs provides programmatic access to EMODnet’s Web Feature Service (WFS) endpoints, enabling users to retrieve vector data such as species occurrences, habitat boundaries, and infrastructure locations directly into R.\nemodnet.wcs enables access to EMODnet’s Web Coverage Service (WCS) endpoints, allowing users to download raster data such as depth models, species distributions, and environmental variables.\nBoth packages simplify data discovery, querying, and retrieval, making EMODnet’s extensive data holdings readily available for spatial analysis in R."
  },
  {
    "objectID": "about.html#acknowledgments-and-funding",
    "href": "about.html#acknowledgments-and-funding",
    "title": "About",
    "section": "Acknowledgments and Funding",
    "text": "Acknowledgments and Funding\nThese tutorials were developed as part of the EMODnet Biology initiative, funded by the European Commission’s Directorate-General for Maritime Affairs and Fisheries (DG MARE) under the European Maritime and Fisheries Fund (EMFF).\nThe tutorial materials are made available under open licenses to support the broader marine science and data science communities."
  },
  {
    "objectID": "about.html#contributing",
    "href": "about.html#contributing",
    "title": "About",
    "section": "Contributing",
    "text": "Contributing\nWe welcome contributions, suggestions, and feedback! Please visit our GitHub repository to:\n\nReport issues or bugs\nSuggest improvements or new tutorial topics\nSubmit pull requests with corrections or enhancements\n\nFor detailed contribution guidelines, see CONTRIBUTING.md."
  },
  {
    "objectID": "about.html#links-and-resources",
    "href": "about.html#links-and-resources",
    "title": "About",
    "section": "Links and Resources",
    "text": "Links and Resources\n\nEMODnet Biology Portal\nEMODnet Main Portal\nemodnet.wfs Package\nemodnet.wcs Package"
  },
  {
    "objectID": "concepts.html",
    "href": "concepts.html",
    "title": "Geospatial Concepts & Glossary",
    "section": "",
    "text": "This page provides foundational knowledge for working with geospatial marine data. If you’re new to spatial analysis or need a refresher, start here before diving into the tutorials."
  },
  {
    "objectID": "concepts.html#introduction",
    "href": "concepts.html#introduction",
    "title": "Geospatial Concepts & Glossary",
    "section": "",
    "text": "This page provides foundational knowledge for working with geospatial marine data. If you’re new to spatial analysis or need a refresher, start here before diving into the tutorials."
  },
  {
    "objectID": "concepts.html#spatial-data-types",
    "href": "concepts.html#spatial-data-types",
    "title": "Geospatial Concepts & Glossary",
    "section": "Spatial Data Types",
    "text": "Spatial Data Types\nGeospatial data comes in two fundamental forms: vector and raster (Figure 1). Understanding the difference is crucial for choosing the right analysis methods.\n\n\n\n\n\n\n\n\nFigure 1: Comparison of vector (left) and raster (right) representations of the same geographic area\n\n\n\n\n\n\nVector Data\nVector data represents discrete geographic features as points, lines, or polygons. Each feature has a precise location and can carry associated attributes (metadata).\nCommon vector data types:\n\nPoints - Specific locations (e.g., species observation sites, sampling stations, platform locations)\nLines - Linear features (e.g., ship tracks, transects, pipelines)\nPolygons - Enclosed areas (e.g., marine protected areas, habitat boundaries, survey regions)\n\nExamples in EMODnet:\n\nMarine protected area boundaries\nSpecies occurrence records\nSubsea infrastructure (pipelines, cables)\nHabitat classification polygons\nSurvey locations\n\nVector data is ideal when you need exact boundaries, discrete locations, or want to perform operations like counting features or measuring precise distances.\n\n\nRaster Data\nRaster data represents continuous spatial phenomena as a grid of cells (pixels), where each cell contains a value representing a measurement or category.\nCommon raster characteristics:\n\nOrganized as rows and columns of cells\nEach cell has a specific resolution (size)\nValues can be continuous (e.g., depth, temperature) or categorical (e.g., habitat types)\nOften used for environmental variables\n\nExamples in EMODnet:\n\nBathymetric depth models\nSpecies abundance grids\nHabitat suitability indices\nEnvironmental variables (temperature, salinity)\nDerived biodiversity metrics\n\nRaster data excels at representing continuous surfaces, enabling analyses like extracting values at points, calculating zonal statistics, or modeling spatial patterns."
  },
  {
    "objectID": "concepts.html#web-services-for-spatial-data",
    "href": "concepts.html#web-services-for-spatial-data",
    "title": "Geospatial Concepts & Glossary",
    "section": "Web Services for Spatial Data",
    "text": "Web Services for Spatial Data\n\nWhat is a Web Service?\nA web service is a standardized protocol that allows software applications to communicate with databases over the internet. In the context of spatial data, web services provide programmatic access to spatial databases - you send a request (e.g., “give me species observations in this bounding box”) and the service queries its database and returns the data.\nEssentially, web services are spatial databases + standardized communication protocols that let you query and retrieve data through HTTP requests instead of needing direct database access.\nKey benefits:\n\nProgrammatic access - Query data directly from R without manual downloads\nSelective retrieval - Request only specific regions, time periods, or attributes\nAlways current - Access the latest data without managing file versions\nReproducible - Your code documents exactly what data was retrieved\nEfficient - Download only what you need, reducing bandwidth and storage\n\n\n\nHow Web Services Work\nFigure 2 illustrates the typical workflow when accessing EMODnet data through web services.\n\n\n\n\n\n\nflowchart LR\n    A[Your R Script] --&gt;|HTTP Request&lt;br/&gt;bbox, layer, filters| B[EMODnet WFS/WCS Server]\n    B --&gt;|Query| C[(Spatial Database)]\n    C --&gt;|Matching Data| B\n    B --&gt;|Response&lt;br/&gt;GeoJSON/GeoTIFF| A\n    A --&gt;|Load into| D[R Object&lt;br/&gt;sf or terra]\n\n    style A fill:#e1f5ff\n    style B fill:#fff4e1\n    style C fill:#f0f0f0\n    style D fill:#e1f5ff\n\n\n\n\nFigure 2: Web service request flow from R to EMODnet data services\n\n\n\n\n\n\n\nOGC Standards and Spatial Data Types\nThe Open Geospatial Consortium (OGC) has developed different standard protocols optimized for different types of spatial data. The protocols, underlying database technologies, and data formats all differ based on whether you’re working with vector or raster data.\nEMODnet provides two primary types of OGC-compliant geospatial web services, each designed for a specific spatial data type:\n\n\nWFS (Web Feature Service)\nWFS delivers vector data: discrete geographic features with attributes.\nKey characteristics:\n\nReturns features in formats like GeoJSON or GML\nSupports spatial and attribute filtering\nAllows querying specific areas or feature properties\nIdeal for points, lines, and polygons\n\nIn R: Use the emodnet.wfs package to access WFS services. The package simplifies discovering available layers, filtering by extent or attributes, and retrieving data as sf objects.\nWhat information can you access?\nBefore downloading data, WFS services let you discover which feature types (layers) exist and what attributes each layer contains. Once you retrieve data, you receive discrete geographic features (points, lines, polygons) with associated attributes describing those features (e.g., species observations with taxonomic details, protected area boundaries with designation information, infrastructure with operational attributes).\nExample WFS data from EMODnet:\n\nSpecies occurrences and distributions\nMarine protected area boundaries\nInfrastructure features (platforms, pipelines, cables)\nHabitat polygons\n\n\n\nWCS (Web Coverage Service)\nWCS delivers raster data: gridded coverage representing continuous variables.\nKey characteristics:\n\nReturns coverage in formats like GeoTIFF\nSupports spatial and temporal subsetting\nCan extract specific bands from multi-band datasets\nIdeal for environmental layers and modeled surfaces\n\nIn R: Use the emodnet.wcs package to access WCS services. The package handles coverage discovery, spatial/temporal subsetting, and returns data as terra raster objects.\nWhat information can you access?\nBefore downloading data, WCS services provide metadata about available coverages: which datasets exist, their spatial and temporal extent, resolution, coordinate reference systems, and what bands/variables each coverage contains. When you retrieve data, you receive gridded rasters where each cell contains measurements or modeled values for continuous variables (e.g., bathymetric depth, species abundance predictions, habitat suitability indices, environmental measurements).\nExample WCS data from EMODnet:\n\nBathymetric depth models\nSpecies abundance and diversity grids\nHabitat suitability models\nGridded biodiversity metrics\n\n\n\nAdvantages of Web Services\nCompared to direct file downloads, web services offer:\n\nOn-demand access - Get only the data you need, when you need it\nSpatial filtering - Request data for specific regions using bounding boxes\nTemporal subsetting - Extract data for particular time periods\nAlways current - Access the latest data without managing downloads\nReproducibility - Script your data access for transparent, repeatable workflows"
  },
  {
    "objectID": "concepts.html#coordinate-reference-systems-crs",
    "href": "concepts.html#coordinate-reference-systems-crs",
    "title": "Geospatial Concepts & Glossary",
    "section": "Coordinate Reference Systems (CRS)",
    "text": "Coordinate Reference Systems (CRS)\nA Coordinate Reference System defines how coordinates relate to locations on Earth’s surface. Understanding CRS is essential for accurate spatial analysis.\n\nThe Challenge: From 3D Earth to 2D Maps\nEarth is a three-dimensional sphere, but maps and computer screens are two-dimensional. Think of trying to peel an orange and flatten the peel completely - you can’t do it without distorting, stretching, tearing, or overlapping parts of it. This is the fundamental challenge of cartography.\nProjections are different methods of “peeling and flattening” Earth’s surface. Just as there are many ways you could cut and flatten an orange peel (peel it in strips, cut it into wedges, try to keep it in one piece), there are many different projection methods, each making different choices about:\n\nWhere to cut (what regions to split)\nWhat to stretch (which areas get distorted)\nWhat to preserve (angles, areas, distances, or shapes)\n\nThere is no perfect solution - every projection sacrifices something. This is why dozens of projections exist: each is optimized for different purposes and geographic regions.\n\n\n\n\n\n\nNoteEPSG Codes\n\n\n\nThroughout this page, you’ll see CRS referenced by EPSG codes (e.g., EPSG:4326, EPSG:3857). EPSG stands for the European Petroleum Survey Group (now maintained by the International Association of Oil & Gas Producers), which created a standardized registry assigning unique numeric codes to coordinate reference systems. These codes provide an unambiguous way to specify which CRS you’re using.\n\n\n\n\nGeographic vs Projected CRS\nGeographic Coordinate Systems (Unprojected)\nGeographic CRS don’t actually “flatten” Earth - they describe locations on the 3D spheroid surface using angles (latitude and longitude in degrees). Think of this as leaving the orange intact and describing locations by their angular position from the center.\n\nExample: WGS84 (EPSG:4326) (Figure 3 (a)) - Most common for global marine data and default for EMODnet services\nUnits in degrees, not meters\nGood for storing and sharing data globally\nNot suitable for measurements - a degree of longitude represents different distances at different latitudes (degrees get closer together near the poles)\n\nProjected Coordinate Systems\nProjected CRS actually perform the “flattening” using mathematical transformations. Each projection is a different flattening method with different trade-offs:\n\nWeb Mercator (EPSG:3857) (Figure 3 (b)) - “Peels the orange” by stretching areas increasingly toward the poles. Preserves angles (conformal projection), which historically made it invaluable for maritime navigation - sailors could plot a straight line between two points and maintain a constant compass bearing throughout their journey. However, this comes at the cost of severely distorting areas at high latitudes. Used by most web maps because it makes the whole world fit in a square.\nUTM zones (e.g., EPSG:32631 for UTM 31N) - “Cuts the orange” into 60 vertical strips (zones), each 6° of longitude wide. Each strip is flattened with minimal distortion within that zone. Excellent for regional analysis.\nLambert Azimuthal Equal Area (EPSG:3035) (Figure 3 (c)) - “Flattens the orange” while preserving area relationships. A 100 km² habitat appears as 100 km² on the map, regardless of location. Essential for statistical analyses involving area.\nLocal projections - Optimized flattening methods for specific countries or regions, minimizing distortion in areas of interest.\n\nFigure 3 compares these three coordinate reference systems using Europe and Greenland to illustrate the dramatic differences in how projections distort geographic features.\n\n\n\n\n\n\n\n\n\n\n\n\n(a) WGS84 (EPSG:4326) - Unprojected geographic CRS\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Web Mercator (EPSG:3857) - Projected CRS with severe distortion at high latitudes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) Lambert Azimuthal Equal Area (EPSG:3035) - Projected CRS preserving area\n\n\n\n\n\n\n\n\nFigure 3: Comparison of Europe and Greenland in three different coordinate reference systems. Notice how Greenland’s size changes dramatically across projections - Mercator makes it appear huge through vertical stretching, while LAEA shows its true relative size.\n\n\n\n\n\nWhy This Matters for Marine Spatial Analysis\n\nMeasurements require projected CRS - You can’t accurately calculate distances or areas in degrees (geographic CRS). You need a projection that converts to meters.\nChoose projections for your region - A projection optimized for Europe will distort tropical regions. Use UTM zones for your study area or regional equal-area projections.\nMatch your analysis goal - Use equal-area projections for habitat area calculations, equidistant projections for dispersal distance analyses, or conformal projections for angular relationships.\nAlignment is critical - All datasets in an analysis must use the same CRS, or features won’t align correctly.\n\n\n\nWorking with CRS in R\nBoth major R spatial packages provide CRS transformation functions:\n\nVector data (sf) - Use st_transform() to convert between coordinate systems\nRaster data (terra) - Use project() to reproject raster layers\n\nThe tutorials demonstrate when and how to transform between CRS for different types of spatial analyses."
  },
  {
    "objectID": "concepts.html#bounding-boxes-and-spatial-queries",
    "href": "concepts.html#bounding-boxes-and-spatial-queries",
    "title": "Geospatial Concepts & Glossary",
    "section": "Bounding Boxes and Spatial Queries",
    "text": "Bounding Boxes and Spatial Queries\nA bounding box defines a rectangular area of interest using minimum and maximum coordinates (xmin, ymin, xmax, ymax). Bounding boxes are fundamental to spatial queries, allowing you to request only the data you need from web services rather than downloading entire datasets. Figure 4 shows a bounding box for the North Sea region.\n\n\n\n\n\n\n\n\nFigure 4: Example bounding box for the North Sea region. The blue rectangle shows the spatial extent that would be requested from a web service.\n\n\n\n\n\n\nWhy Use Bounding Boxes?\nBounding boxes enable efficient spatial data retrieval by:\n\nReducing data transfer: Download only features or coverage within your study area\nImproving performance: Smaller data volumes mean faster processing and lower memory requirements\nFocusing analyses: Limit results to relevant geographic regions from the start\nReproducible workflows: Explicit spatial extent definitions make analyses transparent and repeatable\n\n\n\nBounding Boxes in EMODnet Services\nBoth WFS (vector) and WCS (raster) services accept bounding box parameters to spatially filter results. When querying EMODnet data through the emodnet.wfs and emodnet.wcs packages, you specify bounding boxes as numeric vectors with minimum and maximum coordinates. The coordinate reference system for bounding boxes should match the CRS of the data you’re requesting, which varies by layer.\nThe tutorials demonstrate practical bounding box usage for retrieving EMODnet data in specific regions, from local study sites to broader management areas."
  },
  {
    "objectID": "concepts.html#the-geospatial-software-stack",
    "href": "concepts.html#the-geospatial-software-stack",
    "title": "Geospatial Concepts & Glossary",
    "section": "The Geospatial Software Stack",
    "text": "The Geospatial Software Stack\nBefore diving into R packages, it helps to understand the foundational libraries that power geospatial computing. These open-source C/C++ libraries do the heavy lifting. R packages like sf and terra are interfaces that make them accessible from R.\n\nCore Libraries\nGDAL (Geospatial Data Abstraction Library)\nGDAL handles reading and writing spatial data formats. When you load a GeoTIFF, GeoJSON, or Shapefile in R, GDAL is doing the work behind the scenes. It supports over 200 raster and vector formats, making it the universal translator for geospatial data.\n\nWebsite: gdal.org\n\nPROJ\nPROJ handles coordinate transformations and projections. When you convert data from WGS84 (latitude/longitude) to a projected coordinate system like UTM, PROJ performs the mathematical transformation. It maintains an extensive database of coordinate reference system definitions.\n\nWebsite: proj.org\n\nGEOS (Geometry Engine - Open Source)\nGEOS performs geometric operations on vector data: intersections, buffers, unions, validity checks, and more. It works with planar coordinates, treating geometries as flat 2D shapes and using Euclidean geometry. This is fast and works well with projected coordinate systems.\n\nWebsite: libgeos.org\n\ns2 (S2 Geometry Library)\ns2 is Google’s library for spherical geometry. Unlike GEOS, it treats the Earth as a sphere and performs calculations on the curved surface. This is appropriate for geographic CRS like WGS84 (EPSG:4326), where coordinates are in degrees. s2 is geometrically correct for unprojected data but slower than GEOS, stricter about geometry validity, and doesn’t support all operations (e.g., st_simplify() requires GEOS).\n\nWebsite: s2geometry.io\n\n\n\nWhy This Matters\nUnderstanding this stack helps explain behaviours you’ll encounter:\n\nGEOS vs s2: The sf package uses s2 by default for geographic CRS and GEOS for projected CRS. Some operations only work with GEOS, which is why you sometimes see sf_use_s2(FALSE) in code to temporarily switch engines.\nCRS transformations: When you call st_transform(), PROJ does the coordinate conversion.\nFormat support: If R can read a spatial format, it’s because GDAL supports it.\n\n\n\nThe Stack in Practice\nWhen you run a typical spatial workflow in R:\n\nLoading data: GDAL reads the file format\nReprojecting: PROJ transforms coordinates\nSpatial operations: GEOS or s2 performs intersections, buffers, etc.\nSaving results: GDAL writes the output format\n\nThe R packages coordinate these libraries and provide a consistent interface, but the underlying work happens in optimised C/C++ code."
  },
  {
    "objectID": "concepts.html#key-r-packages",
    "href": "concepts.html#key-r-packages",
    "title": "Geospatial Concepts & Glossary",
    "section": "Key R Packages",
    "text": "Key R Packages\n\nsf - Simple Features for R\nThe sf package is the modern standard for vector spatial data in R. It provides an R interface to GDAL (for data I/O), PROJ (for CRS transformations), and GEOS/s2 (for geometric operations).\nKey features:\n\nRepresents spatial data as data frames with geometry columns\nIntegrates with tidyverse workflows\nProvides spatial operations (intersections, buffers, joins, etc.)\nHandles CRS transformations\nReads/writes common spatial formats\n\nWhen to use: Working with points, lines, polygons, or any vector data.\n\n\nterra - Spatial Data Analysis\nThe terra package is the modern replacement for raster, designed for raster spatial data.\nKey features:\n\nHandles single and multi-layer rasters\nPerforms raster algebra and focal operations\nExtracts values at points or within polygons\nManages large datasets efficiently\nSupports raster-vector operations\n\nWhen to use: Working with gridded data, environmental layers, or continuous surfaces."
  },
  {
    "objectID": "concepts.html#understanding-spatial-data-objects-in-r",
    "href": "concepts.html#understanding-spatial-data-objects-in-r",
    "title": "Geospatial Concepts & Glossary",
    "section": "Understanding Spatial Data Objects in R",
    "text": "Understanding Spatial Data Objects in R\nUnderstanding how R represents spatial data internally helps you work more effectively with these packages and troubleshoot issues when they arise.\n\nStructure of sf Objects\nAn sf object is fundamentally a data frame with a special geometry column. This elegant design means you can use familiar data manipulation tools (like dplyr) while preserving spatial information.\nEach row in an sf data frame represents one feature: a discrete geographic entity (point, line, or polygon) with associated descriptive information. Each feature consists of:\n\nGeometry: The spatial component stored in a special list-column (typically named geometry)\nAttributes: Regular data frame columns containing information about that feature\n\nThe key concept: attributes describe the entire spatial object defined in the geometry column. For a point, attributes describe that location. For a polygon, attributes describe the entire enclosed area. For a line, attributes describe the entire linear feature.\nExample with point features (species observations):\n# sf object with benthic species observations\n#   scientificname      datecollected  depth_m              geometry\n# 1 Abra alba           2018-05-12        35   POINT (4.2 52.1)\n# 2 Nephtys hombergii   2018-05-12        35   POINT (4.2 52.1)\n# 3 Lanice conchilega   2018-05-15        42   POINT (4.5 52.3)\nEach feature is one species observation. The attributes (scientificname, datecollected, depth_m) describe what was observed at that specific point location. Row 1 tells us Abra alba was found at coordinates (4.2, 52.1) on 2018-05-12 at 35m depth.\nExample with polygon features (protected areas):\n# sf object with marine protected areas\n#   area_name          designation  year_designated  area_km2   geometry\n# 1 Dogger Bank SAC    Natura 2000       2010         12,331   POLYGON (...)\n# 2 Klaverbank         OSPAR MPA          2016          2,576   POLYGON (...)\n# 3 Cleaver Bank       OSPAR MPA          2016          2,362   POLYGON (...)\nEach feature is one marine protected area. The attributes describe characteristics of the entire polygon area. The Dogger Bank SAC attributes (Natura 2000 designation, 2010 designation year, 12,331 km² area) apply to every point within that polygon boundary.\nTypes of attributes you’ll encounter:\n\nIdentifiers: Names, codes, or IDs (site_code, scientificname, area_name)\nCategorical variables: Classifications or types (habitat_type, designation, infrastructure_type)\nContinuous variables: Measured quantities (sp_lost_beta_repl, sp_gained_beta_repl, beta_total, area_km2)\nTemporal information: Dates or time periods (datecollected, year_designated, period)\n\nWhen retrieving vector data from WFS services using the emodnet.wfs package, you get both geometries and attributes. You can filter and analyze attributes like any data frame while spatial operations work on geometries.\n\n\nStructure of terra Objects\nA terra raster object (SpatRaster) represents gridded spatial data organized as a rectangular array of cells, like a spatial spreadsheet where each cell has a location and one or more values.\nCore components:\n\nDimensions: Number of rows (nrow), columns (ncol), and total cells (ncell). Rasters may also include a temporal dimension when data represents time series or seasonal measurements.\nExtent: The geographic area covered (xmin, xmax, ymin, ymax)\nResolution: The size of each cell (usually in meters or degrees)\nCoordinate Reference System: Defines the spatial reference\nBands: One or more data layers, each containing values for every cell\nCell values: The actual measurements or categories stored in the raster\n\nWhat are Bands?\nBands (also called layers) are individual data grids within a raster dataset. Each band covers the same geographic extent with the same grid structure but contains different information. Rasters can be:\n\nSingle-band: One variable per raster (e.g., bathymetric depth)\nMulti-band: Multiple related variables in one dataset (e.g., abundances for different species, habitat suitability for different life stages, measurements across time periods)\n\nMulti-band rasters are common in marine datasets. EMODnet Biology WCS services may provide copepod abundance grids where each band represents a different species or time period. EMODnet Seabed Habitats provides Essential Fish Habitat models where bands represent spawning grounds, nursery areas, and feeding habitats.\nExample: Single-band raster (bathymetry)\n# class       : SpatRaster\n# dimensions  : 500, 750, 1  (nrow, ncol, nlyr)\n# resolution  : 250, 250  (x, y)\n# extent      : 200000, 387500, 5650000, 5775000  (xmin, xmax, ymin, ymax)\n# crs         : EPSG:3857\n# source      : emodnet_bathymetry.tif\n# name        : depth_m\nThis raster has one band (nlyr = 1) containing bathymetric depth measurements for the North Sea. Each of the 375,000 cells (500 rows × 750 columns) holds a depth value in meters.\nExample: Multi-band raster (copepod relative abundances)\n# class       : SpatRaster\n# dimensions  : 200, 300, 3  (nrow, ncol, nlyr)\n# resolution  : 0.1, 0.1  (x, y)\n# extent      : 0.0, 30.0, 49.0, 69.0  (xmin, xmax, ymin, ymax)\n# crs         : EPSG:4326\n# source      : copepod_abundances.tif\n# names       : Acartia_spp, Temora_longicornis, Calanus_finmarchicus\nThis raster has three bands (nlyr = 3), each representing relative abundance of a different copepod species. All bands share the same extent and resolution but contain different values for each cell. When working with multi-band WCS data, you can extract individual bands, compare patterns across bands, or perform calculations combining multiple bands."
  },
  {
    "objectID": "concepts.html#common-spatial-operations",
    "href": "concepts.html#common-spatial-operations",
    "title": "Geospatial Concepts & Glossary",
    "section": "Common Spatial Operations",
    "text": "Common Spatial Operations\n\nVector Operations (sf)\n\nSpatial intersection - Identifies features that overlap spatially, returning the geometric intersection and combined attributes from both input layers. Useful for finding which features from different datasets occupy the same locations (e.g., protected areas intersecting with infrastructure).\nBuffering - Creates zones of specified distance around features, generating polygons that represent areas within a given radius. Essential for proximity analyses, such as identifying areas within a certain distance of sampling stations or evaluating buffer zones around sensitive habitats.\nSpatial joins - Combines features from two layers based on their spatial relationship (e.g., contains, intersects, within). Allows you to transfer attributes from one layer to another based on location, such as assigning habitat types to species occurrence points or aggregating observations within management zones.\nDistance calculations - Measures distances between features, either point-to-point or between features and geometries. Critical for analyses involving dispersal distances, connectivity assessments, or identifying nearest neighbors.\nArea and length measurements - Calculates geometric properties of features, providing area measurements for polygons and length measurements for lines. Required for quantifying habitat extent, assessing patch sizes, or measuring transect lengths.\n\n\n\nRaster Operations (terra)\n\nExtraction - Retrieves raster cell values at specified point locations or within polygon boundaries. Commonly used to extract environmental variables (depth, temperature, salinity) at species occurrence locations or calculate zonal statistics within habitat polygons.\nMasking - Restricts raster data to areas defined by a polygon or another raster, setting values outside the mask to NA. Useful for limiting analyses to specific regions such as marine protected areas, exclusive economic zones, or specific depth ranges.\nRaster algebra - Performs mathematical operations on raster layers, either within a single layer (e.g., unit conversions, transformations) or across multiple layers (e.g., calculating change between time periods, combining variables). Enables creation of derived metrics like biodiversity change or habitat suitability indices.\nAggregation and resampling - Changes raster resolution by combining or subdividing cells. Aggregation reduces resolution for computational efficiency or matching other datasets, while resampling adjusts resolution or aligns grids from different sources.\nFocal operations - Applies functions to neighborhoods of cells, such as calculating moving window statistics (mean, standard deviation) or smoothing. Used for identifying spatial patterns, creating terrain derivatives, or reducing noise in environmental data."
  },
  {
    "objectID": "concepts.html#data-formats",
    "href": "concepts.html#data-formats",
    "title": "Geospatial Concepts & Glossary",
    "section": "Data Formats",
    "text": "Data Formats\nUnderstanding spatial data formats is important when working with web services, even through R packages. While the emodnet.wfs and emodnet.wcs packages handle data retrieval and automatically load results as R objects (sf for vector, terra for raster), the underlying format requested from the service can have significant practical implications:\nDownload speed and data size - Different formats have different compression and encoding schemes, affecting transfer time and bandwidth usage.\nGeometry types and plotting compatibility - Format choice affects what feature geometries are returned. For example, WFS services may return complex geometry types like MULTISURFACE in GML format, which cannot be easily plotted and require conversion to standard POLYGONs. Requesting GeoJSON format instead often returns simpler geometry types that integrate directly with plotting workflows.\nSaving data locally - After retrieving data from EMODnet, you may want to save it for archival, sharing with collaborators, or use in other software. Understanding format characteristics helps you choose the best option for your needs.\nThe tutorials demonstrate when and how to specify output formats to optimize your workflow.\n\nVector Formats\nGeoJSON (.geojson)\n\nText-based, human-readable\nWidely supported across platforms\nGood for web applications and data sharing\nDefault output from many WFS services\n\nShapefiles (.shp + supporting files)\n\nTraditional GIS format\nRequires multiple files (.shp, .shx, .dbf, .prj)\nWell-supported but has limitations (field name length, size limits)\n\nGeoPackage (.gpkg)\n\nModern, single-file format\nSupports multiple layers\nNo size limits\nRecommended for new projects\n\n\n\nRaster Formats\nGeoTIFF (.tif)\n\nIndustry standard for raster data\nEmbeds spatial reference information\nSupports multiple bands\nEfficient for large datasets\nDefault output from many WCS services\n\nNetCDF (.nc)\n\nMulti-dimensional arrays\nCommon for oceanographic and climate data\nHandles time series and multiple variables\nUsed by Copernicus Marine Service"
  },
  {
    "objectID": "concepts.html#glossary-of-common-terms",
    "href": "concepts.html#glossary-of-common-terms",
    "title": "Geospatial Concepts & Glossary",
    "section": "Glossary of Common Terms",
    "text": "Glossary of Common Terms\n\n\n\n\nTable 1\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nAttribute\nNon-spatial data associated with a feature, stored in data frame columns. Attributes describe characteristics of the entire spatial object (e.g., species name, designation type, measurement values).\n\n\nBand\nAn individual data layer within a raster dataset. Single-band rasters contain one variable; multi-band rasters contain multiple related variables (e.g., different species, time periods, or measurements) sharing the same grid structure.\n\n\nBathymetry\nThe measurement of ocean depth; underwater topography.\n\n\nBenthic\nRelating to organisms living on or in the seafloor.\n\n\nBiodiversity metrics\nQuantitative measures of biological diversity (e.g., species richness, evenness, β-diversity).\n\n\nβ-diversity (Beta diversity)\nTurnover in species composition between locations or time periods.\n\n\nBounding box\nA rectangular area defined by minimum and maximum coordinates, used to specify a region of interest.\n\n\nBuffer\nAn area of specified distance around a geographic feature.\n\n\nCoverage\nA raster dataset served by WCS, representing spatial data as a grid of cells with associated values. Term used in WCS terminology for what is more generally called a raster or gridded dataset.\n\n\nCRS (Coordinate Reference System)\nDefines how coordinates correspond to locations on Earth.\n\n\nEPSG code\nA unique numeric identifier for a coordinate reference system from the EPSG registry (e.g., EPSG:4326 for WGS84). Named after the European Petroleum Survey Group, now maintained by the International Association of Oil & Gas Producers.\n\n\nExtent\nThe geographic area covered by a spatial dataset.\n\n\nFeature\nA discrete geographic entity in vector data (point, line, or polygon) with associated attributes.\n\n\nGeometry\nThe spatial component of a feature (its shape and location).\n\n\nGridded data\nRaster data organized as a regular grid of cells.\n\n\nIntersection\nThe spatial overlap between geographic features.\n\n\nLayer\nA collection of geographic features or a raster dataset representing a theme.\n\n\nMasking\nRestricting raster data to areas defined by a polygon.\n\n\nMPA (Marine Protected Area)\nDesignated ocean area where human activities are restricted for conservation.\n\n\nProjection\nA mathematical transformation converting Earth's curved surface to a flat map.\n\n\nRaster\nGridded spatial data where each cell contains a value.\n\n\nResolution\nThe size of raster cells (e.g., 100m × 100m); smaller cells = finer detail.\n\n\nSpatial join\nCombining features from different layers based on spatial relationships.\n\n\nVector\nSpatial data representing discrete features as points, lines, or polygons.\n\n\nWCS (Web Coverage Service)\nA standard protocol for serving raster data.\n\n\nWFS (Web Feature Service)\nA standard protocol for serving vector data."
  },
  {
    "objectID": "concepts.html#external-resources",
    "href": "concepts.html#external-resources",
    "title": "Geospatial Concepts & Glossary",
    "section": "External Resources",
    "text": "External Resources\n\nBooks and Guides\n\nGeocomputation with R - Comprehensive guide to spatial analysis in R by Robin Lovelace, Jakub Nowosad, and Jannes Muenchow\nSpatial Data Science - Modern approaches to spatial data analysis with R\nterra Documentation - Official terra package manual and tutorials\n\n\n\nPackage Documentation\n\nsf Package Vignettes - Detailed guides for working with vector data\nterra Package Reference - Complete function reference for raster operations\nemodnet.wfs Documentation - Guide to accessing EMODnet WFS services\nemodnet.wcs Documentation - Guide to accessing EMODnet WCS services\n\n\n\nAdditional Resources\n\nrspatial.org Tutorials - Free tutorials on spatial analysis with R\nCRAN Spatial Task View - Comprehensive overview of spatial packages in R\n\n\nReady to get started? Head to the tutorials to apply these concepts with real EMODnet data!"
  },
  {
    "objectID": "tutorials/tutorial-01.html",
    "href": "tutorials/tutorial-01.html",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "",
    "text": "The North Sea is one of Europe’s most heavily industrialised marine regions. Beneath its waters lies a dense network of energy infrastructure, including oil and gas platforms, pipelines, and offshore wind installations, alongside a growing network of marine protected areas (MPAs) established under EU directives such as the Marine Strategy Framework Directive and the Habitats Directive.\nUnderstanding where these features intersect is crucial for:\n\nMarine spatial planning: balancing conservation with economic activities\nEnvironmental impact assessments: evaluating potential effects of infrastructure on protected habitats\nPolicy compliance: ensuring activities align with conservation objectives\n\nIn this tutorial, we’ll focus on the energy sector’s footprint on marine protected areas, using open-access EMODnet data to identify and quantify overlaps between protected areas and energy infrastructure. This demonstrates how the emodnet.wfs package enables data-driven environmental analysis entirely within R.\n\n\nBy the end of this tutorial, you will be able to:\n\nExplore and discover available WFS layers using emodnet.wfs functions\nRetrieve multiple vector datasets representing MPAs and subsea infrastructure\nHarmonise coordinate reference systems across layers\nApply spatial intersection techniques to detect overlaps\nSummarise and visualise the extent of intersection between protected areas and human activities\n\n\n\n\nAll data comes from the EMODnet Human Activities portal:\nProtected Areas:\n\n\n\n\n\n\n\nLayer\nDescription\n\n\n\n\ncddaareas\nCDDA (Common Database on Designated Areas), the European inventory of nationally designated protected areas including nature reserves, national parks, and other site types\n\n\nnatura2000areas\nNatura 2000 network, the EU-wide network of protected areas established under the Birds and Habitats Directives to protect Europe’s most valuable species and habitats\n\n\nmarineprotectedareas\nOther marine protected areas, sites designated under regional sea conventions (OSPAR, HELCOM, Barcelona Convention) and other international frameworks\n\n\n\nEnergy Infrastructure:\n\n\n\n\n\n\n\nLayer\nDescription\n\n\n\n\nplatforms\nOffshore platforms, including oil, gas, and wind energy installations such as production platforms, substations, and support structures\n\n\npipelines\nSubsea pipelines for oil, gas, and chemical transport on the seabed\n\n\npcablesbshcontis\nPower cables from BSH (German Federal Maritime and Hydrographic Agency) and CONTIS database\n\n\npcablesshom\nPower cables from SHOM (French Naval Hydrographic and Oceanographic Service)\n\n\npcablesrijks\nPower cables from Rijkswaterstaat (Dutch Directorate-General for Public Works and Water Management)\n\n\npcablesnve\nPower cables from Norwegian sources\n\n\n\nNote: EMODnet also provides telecommunication cable datasets (e.g., sigcables, ukfibrecables), but we focus on energy infrastructure in this tutorial."
  },
  {
    "objectID": "tutorials/tutorial-01.html#introduction",
    "href": "tutorials/tutorial-01.html#introduction",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "",
    "text": "The North Sea is one of Europe’s most heavily industrialised marine regions. Beneath its waters lies a dense network of energy infrastructure, including oil and gas platforms, pipelines, and offshore wind installations, alongside a growing network of marine protected areas (MPAs) established under EU directives such as the Marine Strategy Framework Directive and the Habitats Directive.\nUnderstanding where these features intersect is crucial for:\n\nMarine spatial planning: balancing conservation with economic activities\nEnvironmental impact assessments: evaluating potential effects of infrastructure on protected habitats\nPolicy compliance: ensuring activities align with conservation objectives\n\nIn this tutorial, we’ll focus on the energy sector’s footprint on marine protected areas, using open-access EMODnet data to identify and quantify overlaps between protected areas and energy infrastructure. This demonstrates how the emodnet.wfs package enables data-driven environmental analysis entirely within R.\n\n\nBy the end of this tutorial, you will be able to:\n\nExplore and discover available WFS layers using emodnet.wfs functions\nRetrieve multiple vector datasets representing MPAs and subsea infrastructure\nHarmonise coordinate reference systems across layers\nApply spatial intersection techniques to detect overlaps\nSummarise and visualise the extent of intersection between protected areas and human activities\n\n\n\n\nAll data comes from the EMODnet Human Activities portal:\nProtected Areas:\n\n\n\n\n\n\n\nLayer\nDescription\n\n\n\n\ncddaareas\nCDDA (Common Database on Designated Areas), the European inventory of nationally designated protected areas including nature reserves, national parks, and other site types\n\n\nnatura2000areas\nNatura 2000 network, the EU-wide network of protected areas established under the Birds and Habitats Directives to protect Europe’s most valuable species and habitats\n\n\nmarineprotectedareas\nOther marine protected areas, sites designated under regional sea conventions (OSPAR, HELCOM, Barcelona Convention) and other international frameworks\n\n\n\nEnergy Infrastructure:\n\n\n\n\n\n\n\nLayer\nDescription\n\n\n\n\nplatforms\nOffshore platforms, including oil, gas, and wind energy installations such as production platforms, substations, and support structures\n\n\npipelines\nSubsea pipelines for oil, gas, and chemical transport on the seabed\n\n\npcablesbshcontis\nPower cables from BSH (German Federal Maritime and Hydrographic Agency) and CONTIS database\n\n\npcablesshom\nPower cables from SHOM (French Naval Hydrographic and Oceanographic Service)\n\n\npcablesrijks\nPower cables from Rijkswaterstaat (Dutch Directorate-General for Public Works and Water Management)\n\n\npcablesnve\nPower cables from Norwegian sources\n\n\n\nNote: EMODnet also provides telecommunication cable datasets (e.g., sigcables, ukfibrecables), but we focus on energy infrastructure in this tutorial."
  },
  {
    "objectID": "tutorials/tutorial-01.html#setup",
    "href": "tutorials/tutorial-01.html#setup",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Setup",
    "text": "Setup\n\nPackages\nWe’ll use emodnet.wfs to access EMODnet WFS services, sf for spatial data handling, rnaturalearth to get European coastlines, dplyr and purrr for data manipulation, and ggplot2 and tmap for visualisation.\n\nlibrary(emodnet.wfs)\nlibrary(sf)\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(ggplot2)\nlibrary(tmap)\n\n\n\n\n\n\n\nTipPackage installation\n\n\n\n\n\nIf you haven’t installed these packages, run:\ninstall.packages(c(\n  \"emodnet.wfs\", \"sf\", \"dplyr\", \"purrr\", \"ggplot2\", \"tmap\",\n  \"rnaturalearth\", \"skimr\"\n))\nFor the latest development version:\n# install.packages(\"pak\")\npak::pak(\"EMODnet/emodnet.wfs\")\n\n\n\n\n\nStudy Area\nWe’ll focus on the North Sea, defined by the following bounding box. We’ll use EPSG:3035 (ETRS89-LAEA) as our working CRS, a projected coordinate system with metric units that’s well-suited for European marine analysis.\n\n# Geographic bbox for WFS queries (EPSG:4326)\nnorth_sea_bbox &lt;- c(xmin = -4, ymin = 51, xmax = 9, ymax = 62)\n\n# Create bbox polygon and transform to ETRS89-LAEA (EPSG:3035) for analysis\nbbox_polygon &lt;- sf::st_as_sfc(sf::st_bbox(north_sea_bbox, crs = 4326))\nbbox_3035 &lt;- sf::st_transform(bbox_polygon, 3035)\n\n\n\nCode\n# Get European coastlines, transform to EPSG:3035, and crop to study area\neurope &lt;- rnaturalearth::ne_countries(\n  scale = \"medium\",\n  continent = \"Europe\",\n  returnclass = \"sf\"\n) |&gt;\n  sf::st_transform(3035) |&gt;\n  sf::st_crop(bbox_3035)\n\nggplot() +\n  geom_sf(data = europe, fill = \"gray90\", color = \"gray60\", linewidth = 0.3) +\n  geom_sf(data = bbox_3035, fill = NA, color = \"#004494\", linewidth = 1.5) +\n  labs(x = NULL, y = NULL) +\n  theme_minimal() +\n  theme(panel.grid = element_line(color = \"gray85\", linewidth = 0.2))\n\n\n\n\n\n\n\n\nFigure 1: Study area: North Sea region"
  },
  {
    "objectID": "tutorials/tutorial-01.html#exploring-emodnet-wfs-services",
    "href": "tutorials/tutorial-01.html#exploring-emodnet-wfs-services",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Exploring EMODnet WFS Services",
    "text": "Exploring EMODnet WFS Services\nBefore downloading data, it’s good practice to explore what’s available. The emodnet.wfs package provides several functions to discover services, layers, and their attributes, helping you understand the data before committing to a download.\n\nDiscovering Available Services\nEMODnet provides data through several thematic portals. Let’s see what WFS services are available:\n\nemodnet_wfs()\n\n\n\n\n\n\n\n\n\n\n\nemodnet_thematic_lot\nservice_name\nservice_url\n\n\n\n\nEMODnet Bathymetry\nbathymetry\nhttps://ows.emodnet-bathymetry.eu/wfs\n\n\nEMODnet Biology\nbiology\nhttps://geo.vliz.be/geoserver/Emodnetbio/wfs\n\n\nEMODnet Biology\nbiology_occurrence_data\nhttps://geo.vliz.be/geoserver/Dataportal/wfs\n\n\nEMODnet Chemistry\nchemistry_cdi_data_discovery_and_access_service\nhttps://geo-service.maris.nl/emodnet_chemistry/wfs\n\n\nEMODnet Chemistry\nchemistry_cdi_distribution_observations_per_category_and_region\nhttps://geo-service.maris.nl/emodnet_chemistry_p36/wfs\n\n\nEMODnet Chemistry\nchemistry_contaminants\nhttps://geoserver.hcmr.gr/geoserver/EMODNET_SHARED/wfs\n\n\nEMODnet Chemistry\nchemistry_marine_litter\nhttps://www.ifremer.fr/services/wfs/emodnet_chemistry2\n\n\nEMODnet Geology\ngeology_coastal_behavior\nhttps://drive.emodnet-geology.eu/geoserver/tno/wfs\n\n\nEMODnet Geology\ngeology_events_and_probabilities\nhttps://drive.emodnet-geology.eu/geoserver/ispra/wfs\n\n\nEMODnet Geology\ngeology_marine_minerals\nhttps://drive.emodnet-geology.eu/geoserver/gsi/wfs\n\n\nEMODnet Geology\ngeology_sea_floor_bedrock\nhttps://drive.emodnet-geology.eu/geoserver/bgr/wfs\n\n\nEMODnet Geology\ngeology_seabed_substrate_maps\nhttps://drive.emodnet-geology.eu/geoserver/gtk/wfs\n\n\nEMODnet Geology\ngeology_submerged_landscapes\nhttps://drive.emodnet-geology.eu/geoserver/bgs/wfs\n\n\nEMODnet Human Activities\nhuman_activities\nhttps://ows.emodnet-humanactivities.eu/wfs\n\n\nEMODnet Physics\nphysics\nhttps://prod-geoserver.emodnet-physics.eu/geoserver/ows\n\n\nEMODnet Seabed Habitats\nseabed_habitats_general_datasets_and_products\nhttps://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_open/wfs\n\n\nEMODnet Seabed Habitats\nseabed_habitats_individual_habitat_map_and_model_datasets\nhttps://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_open_maplibrary/wfs\n\n\n\n\n\nFor this tutorial, we’ll use the human_activities service, which contains both protected area boundaries and infrastructure data.\n\n\nConnecting to a Service\nTo query a service, we first create a WFS client connection:\n\nwfs &lt;- emodnet_init_wfs_client(service = \"human_activities\")\n\n\n\nDiscovering Available Layers\nEach service contains multiple layers. Let’s explore what’s available:\n\navailable_layers &lt;- emodnet_get_wfs_info(wfs)\navailable_layers |&gt;\n  select(layer_name, title, abstract)\n\n\n\n\n\n\n\nThe full output also includes service_name, service_url, class (the WFS feature type), format (the R object class returned, typically sf), and layer_namespace.\nWith many layers available, we can filter to find those relevant to our analysis.\n\nProtected Area Layers\nLet’s search for layers related to protected areas:\n\navailable_layers |&gt;\n  filter(grepl(\"protected|natura|cdda\", layer_name, ignore.case = TRUE)) |&gt;\n  select(layer_name, title)\n\n\n  \n\n\n\nWe’ll use three complementary datasets to get comprehensive coverage of marine protected areas:\n\ncddaareas: the CDDA database captures nationally designated sites, giving us country-level protected areas\nnatura2000areas: the EU’s flagship conservation network, essential for any European marine analysis\nmarineprotectedareas: includes sites designated under regional conventions (OSPAR, HELCOM) that may not appear in the other datasets\n\nNote that cddalocations also appears in the filter results. This layer contains point geometries representing the same protected areas, but we need the polygon boundaries from cddaareas for spatial intersection analysis.\n\nmpa_layers &lt;- c(\n  \"cddaareas\",\n  \"natura2000areas\",\n  \"marineprotectedareas\"\n)\n\n\n\nEnergy Infrastructure Layers\nNow let’s find layers related to energy infrastructure. The service includes both power cables (pcables*) and telecommunication cables, but we’ll focus on energy sector infrastructure:\n\navailable_layers |&gt;\n  filter(grepl(\"platform|pipeline|cable\", layer_name, ignore.case = TRUE)) |&gt;\n  select(layer_name, title)\n\n\n  \n\n\n\nFor our energy sector focus, we’ll use:\n\nplatforms: offshore installations (oil, gas, wind) as point locations\npipelines: subsea pipelines for oil and gas transport as line features\npcables*: power cables from multiple national sources (BSH, SHOM, Rijkswaterstaat, Norwegian) for offshore wind and interconnector coverage\n\n\ninfrastructure_layers &lt;- c(\n  \"platforms\",\n  \"pipelines\",\n  \"pcablesbshcontis\",\n  \"pcablesshom\",\n  \"pcablesrijks\",\n  \"pcablesnve\"\n)\n\n\n\n\nUnderstanding Layer Structure\nWFS layers can contain thousands of features with dozens of attributes. Downloading everything and filtering afterwards wastes bandwidth and time. Before committing to a download, we should:\n\nDiscover available attributes: what columns exist and what types are they?\nIdentify filter candidates: which attributes contain categorical values we can filter on?\nCheck actual values: what values exist so we can write accurate filter expressions?\n\nThe emodnet.wfs package provides lightweight metadata functions that answer these questions without downloading full datasets. This “look before you leap” approach helps us write efficient, targeted queries.\n\nInspecting Attribute Metadata\nThe layer_attribute_descriptions() function returns metadata about each attribute in a layer: name, type, and whether it’s the geometry column. It takes a WFS client connection (wfs) and a layer name (layer).\nSince we have three layers to inspect, we use map() to apply the function to each layer name in mpa_layers:\n\nmpa_descriptions &lt;- map(\n  set_names(mpa_layers),\n  \\(x) layer_attribute_descriptions(wfs = wfs, layer = x)\n)\n\nbind_rows(mpa_descriptions, .id = \"layer\")\n\n\n  \n\n\n\n\n\nIdentifying Geometry Columns\nThe geometry column in the output flags which attribute holds the spatial data. We extract these for use when downloading:\n\nget_geom_cols &lt;- function(descriptions) {\n  map_chr(descriptions, \\(x) x$name[x$geometry])\n}\n\nmpa_geom_cols &lt;- get_geom_cols(mpa_descriptions)\nmpa_geom_cols\n#&gt;            cddaareas      natura2000areas marineprotectedareas \n#&gt;           \"the_geom\"           \"the_geom\"           \"the_geom\"\n\n\n\nIdentifying Filter Candidates\nLooking at these descriptions, we can identify attributes useful for filtering:\nCategorical attributes (character type): useful for selecting specific categories\n\ncddaareas: majorecosy (ecosystem type) and designated (designation status) look promising\nmarineprotectedareas: status likely indicates whether sites are designated or proposed\n\nNumeric attributes: useful for threshold-based filtering\n\nnatura2000areas: mar_perc (marine percentage) could help us select predominantly marine sites\n\n\n\nExploring Categorical Values\nFor categorical attributes, we can use layer_attribute_inspect() to fetch unique values. This is much cheaper than downloading the full dataset:\n\n# Check ecosystem types in CDDA - we'll want to exclude terrestrial\nlayer_attribute_inspect(\n  wfs = wfs,\n  layer = \"cddaareas\",\n  attribute = \"majorecosy\"\n)\n\n\n  \n\n\n\n# Check designation status in CDDA\nlayer_attribute_inspect(\n  wfs = wfs,\n  layer = \"cddaareas\",\n  attribute = \"designated\"\n)\n\n\n  \n\n\n\n# Check status values in marine protected areas\nlayer_attribute_inspect(\n  wfs = wfs,\n  layer = \"marineprotectedareas\",\n  attribute = \"status\"\n)\n\n\n  \n\n\n\nThis tells us:\n\ncddaareas: exclude majorecosy = 'Terrestrial' and keep only designated = 'Designated Site'\nmarineprotectedareas: keep status IN ('Designated', 'Designated and managed')\n\n\n\nExploring Numeric Values\nFor numeric attributes like mar_perc, we need to understand the distribution of values to choose an appropriate threshold. The same layer_attribute_inspect() function works here too, but returns summary statistics instead of unique values:\n\nlayer_attribute_inspect(\n  wfs = wfs,\n  layer = \"natura2000areas\",\n  attribute = \"mar_perc\"\n)\n#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#&gt;    0.00    0.00   14.76   39.10   89.89  100.00\n\nThe mar_perc attribute represents the percentage of each Natura 2000 site that is marine (0-100). The summary shows sites span the full range from fully terrestrial (0%) to fully marine (100%), with a median of 15% and mean of 39%.\nFor our analysis, we want sites that are predominantly marine. A threshold of 50% ensures we include sites that are more marine than terrestrial, while excluding coastal sites that are primarily land-based. This gives us:\n\nnatura2000areas: filter to mar_perc &gt; 50 for predominantly marine sites\n\n\n\n\n\n\n\nNoteFetching complete attribute tables\n\n\n\n\n\nFor more comprehensive exploration, layer_attributes_tbl() fetches all attribute data (without geometry) as a tibble. The related layer_attributes_summarise() provides summary statistics.\nmpa_attr_tbls &lt;- map(\n set_names(mpa_layers),\n \\(x) layer_attributes_tbl(wfs = wfs, layer = x)\n)\nBoth functions are more expensive than layer_attribute_inspect() since they fetch the complete dataset. Use them when you need to explore relationships between multiple attributes or perform detailed data quality checks.\nWe’ve included pre-fetched attribute tables as package data. Use the tabs below to browse:\n\nCDDA AreasNatura 2000Marine Protected Areas\n\n\n\nmpa_attr_tbls$cddaareas\n\n\n  \n\n\nskimr::skim(mpa_attr_tbls$cddaareas)\n\n\nData summary\n\n\nName\nmpa_attr_tbls$cddaareas\n\n\nNumber of rows\n13128\n\n\nNumber of columns\n35\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n26\n\n\nDate\n1\n\n\nnumeric\n8\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ngml_id\n0\n1.00\n11\n15\n0\n13128\n0\n\n\ncddacountr\n0\n1.00\n2\n2\n0\n26\n0\n\n\ncountry\n0\n1.00\n5\n11\n0\n26\n0\n\n\ncddaregion\n0\n1.00\n2\n2\n0\n36\n0\n\n\nsitename\n0\n1.00\n1\n147\n0\n12720\n0\n\n\nlocalid\n0\n1.00\n1\n36\n0\n13127\n0\n\n\nnamespace\n0\n1.00\n2\n116\n0\n44\n0\n\n\nversionid\n10186\n0.22\n1\n14\n0\n618\n0\n\n\nmetadata_v\n0\n1.00\n54\n92\n0\n26\n0\n\n\nmetadata_s\n0\n1.00\n5\n5\n0\n1\n0\n\n\nmetadata_f\n0\n1.00\n1\n1\n0\n1\n0\n\n\nmetadata_1\n13128\n0.00\nNA\nNA\n0\n0\n0\n\n\ngeomtype\n0\n1.00\n7\n7\n0\n1\n0\n\n\nnationalid\n10\n1.00\n1\n30\n0\n12632\n0\n\n\ndesignated\n0\n1.00\n15\n19\n0\n2\n0\n\n\ndesignatio\n0\n1.00\n4\n4\n0\n251\n0\n\n\niucncatego\n0\n1.00\n1\n13\n0\n10\n0\n\n\niucndesc\n0\n1.00\n12\n56\n0\n10\n0\n\n\niucnlink\n13128\n0.00\nNA\nNA\n0\n0\n0\n\n\nmajorecosy\n0\n1.00\n6\n22\n0\n3\n0\n\n\nspatialdat\n0\n1.00\n6\n6\n0\n1\n0\n\n\nspatialres\n0\n1.00\n7\n17\n0\n3\n0\n\n\npslocalid\n0\n1.00\n1\n36\n0\n13127\n0\n\n\npsnamespac\n0\n1.00\n2\n116\n0\n44\n0\n\n\npsversioni\n10186\n0.22\n1\n14\n0\n618\n0\n\n\nremark\n6309\n0.52\n3\n254\n0\n625\n0\n\n\n\nVariable type: Date\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\nmetadata_b\n0\n1\n2020-03-29\n2025-07-08\n2025-04-15\n22\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\ncddaid\n0\n1\n217326210.30\n271026192.66\n650\n175486.25\n387833.00\n555632146.75\n555774576.00\n▇▁▁▁▅\n\n\nlegalfound\n0\n1\n2000.29\n16.99\n1800\n1993.00\n2003.00\n2010.00\n2025.00\n▁▁▁▁▇\n\n\nid\n0\n1\n996824.78\n100897.59\n395195\n977769.50\n1012624.50\n1049099.50\n1077448.00\n▁▁▁▁▇\n\n\ncoast_mar\n0\n1\n1.00\n0.00\n1\n1.00\n1.00\n1.00\n1.00\n▁▁▇▁▁\n\n\nsitearea\n0\n1\n27573.80\n1689510.52\n0\n3.21\n20.28\n207.43\n166200000.00\n▇▁▁▁▁\n\n\nmarinearea\n0\n1\n19.17\n33.39\n0\n0.00\n0.00\n26.00\n100.00\n▇▁▁▁▁\n\n\nshape_leng\n0\n1\n0.51\n8.32\n0\n0.01\n0.04\n0.14\n843.75\n▇▁▁▁▁\n\n\nshape_area\n0\n1\n0.05\n3.73\n0\n0.00\n0.00\n0.00\n380.60\n▇▁▁▁▁\n\n\n\n\n\n\n\n\nmpa_attr_tbls$natura2000areas\n\n\n  \n\n\nskimr::skim(mpa_attr_tbls$natura2000areas)\n\n\nData summary\n\n\nName\nmpa_attr_tbls$natura2000a…\n\n\nNumber of rows\n4402\n\n\nNumber of columns\n17\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n8\n\n\nDate\n4\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ngml_id\n0\n1\n17\n20\n0\n4402\n0\n\n\nsitecode\n0\n1\n9\n9\n0\n4402\n0\n\n\nsitename\n0\n1\n2\n203\n0\n4300\n0\n\n\nms\n0\n1\n2\n2\n0\n22\n0\n\n\ncountry\n0\n1\n5\n11\n0\n22\n0\n\n\nsitetype\n0\n1\n1\n1\n0\n3\n0\n\n\nsitedesc\n0\n1\n16\n35\n0\n3\n0\n\n\ndirective\n0\n1\n68\n81\n0\n3\n0\n\n\n\nVariable type: Date\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\nrelease_da\n156\n0.96\n1998-04-30\n2024-02-01\n2018-12-01\n147\n\n\ndate_spa\n3083\n0.30\n1900-01-01\n2023-12-01\n2004-02-01\n173\n\n\ndate_sci\n2010\n0.54\n2001-12-01\n2023-01-01\n2006-06-30\n37\n\n\ndate_sac\n1381\n0.69\n1900-01-01\n2023-12-01\n2014-04-30\n163\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\narea_ha\n0\n1\n18553.07\n172261.85\n0.02\n107.11\n716.40\n5046.09\n7186094.00\n▇▁▁▁▁\n\n\nmar_perc\n0\n1\n39.10\n42.67\n0.00\n0.00\n14.76\n89.89\n100.00\n▇▁▁▁▅\n\n\ncoast_mar\n0\n1\n1.00\n0.00\n1.00\n1.00\n1.00\n1.00\n1.00\n▁▁▇▁▁\n\n\nshape_leng\n0\n1\n1.10\n13.39\n0.00\n0.09\n0.27\n0.78\n841.51\n▇▁▁▁▁\n\n\nshape_area\n0\n1\n0.02\n0.20\n0.00\n0.00\n0.00\n0.01\n8.53\n▇▁▁▁▁\n\n\n\n\n\n\n\n\nmpa_attr_tbls$marineprotectedareas\n\n\n  \n\n\nskimr::skim(mpa_attr_tbls$marineprotectedareas)\n\n\nData summary\n\n\nName\nmpa_attr_tbls$marineprote…\n\n\nNumber of rows\n826\n\n\nNumber of columns\n18\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n10\n\n\nnumeric\n8\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ngml_id\n0\n1.00\n22\n24\n0\n826\n0\n\n\nname\n0\n1.00\n3\n141\n0\n803\n0\n\n\nrsc\n0\n1.00\n5\n9\n0\n3\n0\n\n\norig_name\n188\n0.77\n3\n81\n0\n614\n0\n\n\ncountry\n0\n1.00\n5\n34\n0\n28\n0\n\n\ndesignatio\n188\n0.77\n29\n52\n0\n2\n0\n\n\niucn_cat\n224\n0.73\n1\n14\n0\n8\n0\n\n\nstatus\n0\n1.00\n7\n29\n0\n5\n0\n\n\nmang_auth\n298\n0.64\n3\n244\n0\n112\n0\n\n\nlink\n481\n0.42\n10\n165\n0\n269\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\ncode\n0\n1.00\n2348.53\n2397.33\n11.00\n599.25\n1705.00\n2323.50\n8669.00\n▇▅▁▁▂\n\n\nrep_m_area\n218\n0.74\n2848.90\n26867.43\n0.07\n16.60\n78.57\n410.02\n595156.00\n▇▁▁▁▁\n\n\ngis_m_area\n194\n0.77\n2819.55\n26397.30\n0.01\n15.78\n85.17\n425.80\n595158.13\n▇▁▁▁▁\n\n\nrep_area\n369\n0.55\n3653.83\n30940.67\n0.07\n17.24\n115.53\n594.36\n595156.00\n▇▁▁▁▁\n\n\ngis_area\n188\n0.77\n2803.07\n26283.21\n0.04\n16.32\n85.70\n439.98\n595158.13\n▇▁▁▁▁\n\n\nstatus_yr\n0\n1.00\n2011.79\n5.28\n1991.00\n2008.00\n2011.00\n2016.00\n2023.00\n▁▁▇▇▅\n\n\nshape_leng\n0\n1.00\n2.51\n8.93\n0.01\n0.47\n1.07\n2.26\n199.29\n▇▁▁▁▁\n\n\nshape_area\n0\n1.00\n0.32\n2.97\n0.00\n0.00\n0.01\n0.05\n72.30\n▇▁▁▁▁\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlanning Our Data Schema\nNow that we’ve explored the available attributes and identified our filter criteria, we can plan exactly what to request. Defining a schema upfront has several benefits:\n\nReduces download size: we only request the columns we actually need\nDocuments our decisions: the schema captures which filters we’re applying and why\nEnables standardisation: different layers use different names for similar concepts (sitename vs name), which we’ll need to reconcile when combining data later\nSupports automation: we can programmatically extract property names and filters from the schema\n\nOur schema structure has two components per layer:\n\ncols: a named list defining the columns for our final combined dataset. The names are what we want our output columns to be called. Each element is either:\n\nNULL: the WFS layer already uses this column name and no type casting is needed\nA list with from and/or type:\n\nfrom: the actual attribute name in the WFS layer (when it differs from our desired output name)\ntype: type shorthand for casting: \"d\" (double), \"i\" (integer), \"c\" (character), etc.\n\n\nfilter: a CQL/ECQL filter expression to apply server-side\n\nFor example, sitename = list(from = \"name\") means: “download the name attribute from the WFS, but rename it to sitename in our output”. This lets us harmonise column names across layers that use different conventions.\n\n\n\n\n\n\nNote\n\n\n\nRenaming and type casting happen later when we combine the layers, not at download time.\n\n\n\nmpa_schemas &lt;- list(\n  cddaareas = list(\n    cols = list(\n      sitename = NULL,\n      country = NULL,\n      majorecosy = NULL,\n      designated = NULL\n    ),\n    filter = \"majorecosy &lt;&gt; 'Terrestrial' AND designated = 'Designated Site'\"\n  ),\n  natura2000areas = list(\n    cols = list(\n      sitename = NULL,\n      country = NULL,\n      sitedesc = NULL,\n      directive = NULL,\n      mar_perc = list(type = \"d\")\n    ),\n    filter = \"mar_perc &gt; 50\"\n  ),\n  marineprotectedareas = list(\n    cols = list(\n      sitename = list(from = \"name\"),\n      country = NULL,\n      designatio = NULL,\n      rsc = NULL,\n      status = NULL\n    ),\n    filter = \"status IN ('Designated', 'Designated and managed')\"\n  )\n)\n\n\n\nDefining the Spatial Filter\nTo avoid downloading entire datasets and filtering afterwards, we’ll use an ECQL BBOX filter to request only features within our study area.\nThe BBOX filter requires the geometry column name. We extracted these in Identifying Geometry Columns. Let’s verify all layers use the same name so we can use a single filter:\n\nunique(mpa_geom_cols)\n#&gt; [1] \"the_geom\"\n\nAll layers use the_geom, so we can use a shared bbox filter. If layers had different geometry column names, we’d need to construct per-layer filters.\n\n# Create ECQL BBOX filter string\n# Format: BBOX(geometry_column, minx, miny, maxx, maxy, 'CRS')\nbbox_filter &lt;- sprintf(\n  \"BBOX(%s, %s, %s, %s, %s, 'EPSG:4326')\",\n  unique(mpa_geom_cols),\n  north_sea_bbox[\"xmin\"],\n  north_sea_bbox[\"ymin\"],\n  north_sea_bbox[\"xmax\"],\n  north_sea_bbox[\"ymax\"]\n)\n\nbbox_filter\n#&gt; [1] \"BBOX(the_geom, -4, 51, 9, 62, 'EPSG:4326')\"\n\n\n\nExtracting Property Names\nTo limit which attributes are downloaded, we pass a propertyName argument to the WFS request. This expects a comma-separated string of attribute names (WFS calls these “properties”, hence the parameter name). We can extract these from our schema: for each column, we use the from value if specified, otherwise the column name itself. We also include the geometry column so we get spatial data back:\n\n# Helper to build propertyName string from schema\nget_property_names &lt;- function(schema, geom_col) {\n  cols &lt;- schema$cols\n  attrs &lt;- imap_chr(cols, \\(x, y) x$from %||% y)\n  paste(c(geom_col, attrs), collapse = \",\")\n}\n\n# Build propertyName strings for each layer\nmpa_property_names &lt;- map2_chr(\n  mpa_schemas,\n  mpa_geom_cols,\n  \\(x, y) get_property_names(schema = x, geom_col = y)\n)\nmpa_property_names\n#&gt;                                               cddaareas \n#&gt;       \"the_geom,sitename,country,majorecosy,designated\" \n#&gt;                                         natura2000areas \n#&gt; \"the_geom,sitename,country,sitedesc,directive,mar_perc\" \n#&gt;                                    marineprotectedareas \n#&gt;           \"the_geom,name,country,designatio,rsc,status\""
  },
  {
    "objectID": "tutorials/tutorial-01.html#retrieving-protected-area-data",
    "href": "tutorials/tutorial-01.html#retrieving-protected-area-data",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Retrieving Protected Area Data",
    "text": "Retrieving Protected Area Data\nNow that we’ve defined our schema, filters, and property names, let’s download the protected area boundaries.\n\nDownloading Multiple Layers\nThe emodnet_get_layers() function downloads one or more layers. Each argument helps keep downloads lean and processing efficient by pushing work to the server (the WFS service) rather than doing it client-side (locally in R after downloading):\n\ncrs = 3035: requests data pre-transformed to our target coordinate reference system, avoiding a local st_transform() call\ncql_filter: filters features on the server so we only download what matches our spatial and attribute criteria\npropertyName: limits which attributes are returned, reducing payload size for layers with many columns\noutputFormat = \"application/json\": requests GeoJSON format for faster downloads and simpler geometry types\nsimplify = TRUE: returns an sf object directly instead of a list (convenient for single-layer requests)\n\nSince each layer has different attribute names and filters, we loop through them using our pre-defined schemas:\n\nmpa_sf_list &lt;- map(mpa_layers, \\(layer) {\n  # Combine bbox filter with layer-specific attribute filter\n  layer_filter &lt;- mpa_schemas[[layer]]$filter\n  combined_filter &lt;- paste(bbox_filter, layer_filter, sep = \" AND \")\n\n  emodnet_get_layers(\n    wfs = wfs,\n    layers = layer,\n    crs = 3035,\n    cql_filter = combined_filter,\n    propertyName = mpa_property_names[[layer]],\n    outputFormat = \"application/json\",\n    simplify = TRUE\n  )\n}) |&gt;\n  set_names(mpa_layers)\n\n\n\n\n\n\n\nNoteWhy use GeoJSON format?\n\n\n\n\n\nWe specify outputFormat = \"application/json\" (GeoJSON) rather than the default GML format for two reasons:\n\nFaster downloads: GeoJSON is typically more compact and efficient to transfer over the network\nSimpler geometries: GeoJSON returns standard geometry types like POLYGON and MULTIPOLYGON, while GML may return complex types like MULTISURFACE or CURVE that can cause issues with spatial operations and plotting functions\n\nThis is recommended practice for most emodnet_get_layers() calls.\n\n\n\nThis returns a named list of sf objects, one per layer:\n\nnames(mpa_sf_list)\n#&gt; [1] \"cddaareas\"            \"natura2000areas\"      \"marineprotectedareas\"\n\n\nmap_int(mpa_sf_list, nrow)\n#&gt;            cddaareas      natura2000areas marineprotectedareas \n#&gt;                  358                   56                  183\n\nLet’s examine the downloaded layers:\n\nCDDA AreasNatura 2000Marine Protected Areas\n\n\n\nmpa_sf_list$cddaareas\n\n\n  \n\n\n\n\n\n\nmpa_sf_list$natura2000areas\n\n\n  \n\n\n\n\n\n\nmpa_sf_list$marineprotectedareas\n\n\n  \n\n\n\n\n\n\n\n\nFiltering by Location (Post-download)\nOur rectangular bounding box captures some protected areas in the Irish Sea that aren’t part of our North Sea study area. We can apply a more precise spatial filter locally to remove these while keeping Scottish MPAs further north.\nThe sf package provides st_filter() for filtering spatial data based on geometric relationships. We’ll use it with st_disjoint as the predicate, which keeps features that have no points in common with our exclusion zone.\nFirst, we define the Irish Sea exclusion zone as a bounding box polygon. We create it in geographic coordinates (EPSG:4326) and then transform it to our working CRS (EPSG:3035) to match our MPA data:\n\n# Define Irish Sea exclusion zone as a polygon\nirish_sea_bbox &lt;- st_bbox(\n  c(xmin = -7, ymin = 51, xmax = -2.5, ymax = 55.5),\n  crs = 4326\n) |&gt;\n  st_as_sfc() |&gt;\n  st_transform(3035)\n\nNow we apply st_filter() with st_disjoint to keep only features that don’t touch the Irish Sea:\n\n# Keep features that are disjoint from (don't touch) the Irish Sea\nmpa_sf_list &lt;- map(mpa_sf_list, \\(x) {\n  st_filter(x, irish_sea_bbox, .predicate = st_disjoint)\n})\n\n# Check the filtered counts\nmap_int(mpa_sf_list, nrow)\n#&gt;            cddaareas      natura2000areas marineprotectedareas \n#&gt;                  358                   56                  156\n\n\n\n\n\n\n\nTipAlternative: Server-side spatial filtering\n\n\n\n\n\nWhen working with web services like WFS, filtering can happen in two places:\n\nServer-side: The WFS server applies filters before sending data. You receive only the features that match your criteria. This is what our CQL BBOX and attribute filters do.\nClient-side: You download the data first, then filter it locally in R using functions like st_filter(). This is what we did above with the Irish Sea exclusion.\n\nThe Irish Sea filter could also be applied server-side using CQL’s DISJOINT function, which selects features that don’t intersect with a geometry:\n# Define exclusion zone as WKT (in EPSG:4326 to match the bbox filter)\nirish_sea_wkt &lt;- \"POLYGON((-7 51, -2.5 51, -2.5 55.5, -7 55.5, -7 51))\"\n\n# Add to the CQL filter\ncombined_filter &lt;- paste(\n  bbox_filter,\n  layer_filter,\n  sprintf(\"DISJOINT(the_geom, %s)\", irish_sea_wkt),\n  sep = \" AND \"\n)\nServer-side filtering reduces download size, which matters for large datasets. Client-side filtering with sf functions like st_filter() is more flexible and works with any spatial data, not just WFS, making it a valuable skill for spatial analysis in R.\n\n\n\n\n\nQuick Visualisation\nLet’s do a quick visual check with ggplot2, showing all three protected area types. First, we prepare the data for plotting:\n\nExtract the bounding box extent for consistent map limits across plots\nSelect only the geometry column, dropping attributes we don’t need for plotting\nAdd a type column for colour-coding, then combine all layers into a single sf object\nSimplify geometries to speed up rendering (500m tolerance is imperceptible at this scale)\n\n\n# Get bbox extent for coord_sf (used by multiple plots)\nbbox_ext &lt;- st_bbox(bbox_3035)\n\n# Combine all protected areas with type labels (simplify for faster rendering)\nmpa_preview &lt;- imap(\n  mpa_sf_list,\n  \\(x, y) {\n    select(x, geometry) |&gt;\n      mutate(type = y) |&gt;\n      st_simplify(dTolerance = 500, preserveTopology = TRUE)\n  }\n) |&gt;\n  bind_rows()\n\n\nggplot() +\n  geom_sf(data = europe, fill = \"gray90\", colour = \"gray70\") +\n  geom_sf(\n    data = mpa_preview,\n    aes(fill = type, colour = type),\n    alpha = 0.4\n  ) +\n  scale_fill_brewer(palette = \"Set2\", name = \"Type\") +\n  scale_colour_brewer(palette = \"Set2\", guide = \"none\") +\n  coord_sf(\n    xlim = c(bbox_ext[\"xmin\"], bbox_ext[\"xmax\"]),\n    ylim = c(bbox_ext[\"ymin\"], bbox_ext[\"ymax\"])\n  ) +\n  labs(title = \"Protected Areas by Type\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\nFigure 2: Protected areas in the North Sea by type"
  },
  {
    "objectID": "tutorials/tutorial-01.html#retrieving-infrastructure-data",
    "href": "tutorials/tutorial-01.html#retrieving-infrastructure-data",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Retrieving Infrastructure Data",
    "text": "Retrieving Infrastructure Data\nNext, let’s download the subsea infrastructure data. First, let’s check the layer attributes:\n\ninfra_descriptions &lt;- map(\n  set_names(infrastructure_layers),\n  \\(x) layer_attribute_descriptions(wfs = wfs, layer = x)\n)\n\nimap(infra_descriptions, \\(x, y) x$name)\n#&gt; $platforms\n#&gt;  [1] \"country\"            \"platformid\"         \"current_status\"    \n#&gt;  [4] \"category\"           \"function\"           \"operator\"          \n#&gt;  [7] \"location_blocks\"    \"primary_production\" \"weight_sub\"        \n#&gt; [10] \"weight_top\"         \"production_start\"   \"valid_from\"        \n#&gt; [13] \"valid_to\"           \"water_depth\"        \"coast_dist\"        \n#&gt; [16] \"remarks\"            \"the_geom\"          \n#&gt; \n#&gt; $pipelines\n#&gt;  [1] \"id\"         \"status\"     \"medium\"     \"operator\"   \"size_in\"   \n#&gt;  [6] \"length_m\"   \"year\"       \"from_loc\"   \"to_loc\"     \"country_co\"\n#&gt; [11] \"country\"    \"notes\"      \"the_geom\"  \n#&gt; \n#&gt; $pcablesbshcontis\n#&gt; [1] \"featureid\"  \"featurespe\" \"status\"     \"featuretyp\" \"name_\"     \n#&gt; [6] \"uuid\"       \"shape_leng\" \"the_geom\"  \n#&gt; \n#&gt; $pcablesshom\n#&gt; [1] \"catcbl\"    \"status\"    \"inspireid\" \"the_geom\" \n#&gt; \n#&gt; $pcablesrijks\n#&gt;  [1] \"kabel_nr\"   \"naam\"       \"eigenaar\"   \"kabel_type\" \"kabelsoort\"\n#&gt;  [6] \"legmethode\" \"rpl_status\" \"omschrijvi\" \"trace_van\"  \"trace_tot\" \n#&gt; [11] \"status\"     \"aanleg_dd\"  \"geldig_van\" \"geldig_tot\" \"aanmaak_dd\"\n#&gt; [16] \"mutatie_dd\" \"comcode\"    \"comoms\"     \"the_geom\"  \n#&gt; \n#&gt; $pcablesnve\n#&gt;  [1] \"objekttype\" \"komponentk\" \"komponen_1\" \"nvenettniv\" \"nettnivaa\" \n#&gt;  [6] \"eier\"       \"eierorgnr\"  \"navn\"       \"spenning_k\" \"driftsatta\"\n#&gt; [11] \"nveopprett\" \"nveendretd\" \"kildeendre\" \"malemetode\" \"noyaktighe\"\n#&gt; [16] \"lokalid\"    \"datauttaks\" \"eksporttyp\" \"the_geom\"\n\nThe layers have different attributes, reflecting different data sources and national reporting conventions. Unlike our protected area layers (which share common concepts like sitename and country), infrastructure attributes are specific to each layer type and source.\nWe’ll keep infrastructure layers separate rather than combining them. Mixing different geometry types (points and lines) in a single sf object is awkward. Plotting requires filtering by type to apply appropriate aesthetics (size for points, linewidth for lines), and some spatial operations behave unexpectedly with mixed geometries. We’ll download all attributes for each layer and reorganise them by infrastructure type later.\nLet’s verify these layers use the_geom so our bbox filter works:\n\ninfra_geom_cols &lt;- get_geom_cols(infra_descriptions)\nunique(infra_geom_cols)\n#&gt; [1] \"the_geom\"\n\nGood, they match. Since all layers share the same geometry column and we’re applying the same bbox filter to each (no attribute filters or property name restrictions), we can pass all layer names directly to emodnet_get_layers() without mapping.\n\nDownloading Infrastructure Layers\nWe omit simplify = TRUE because we’re downloading multiple layers and want the result as a named list:\n\ninfra_sf_list &lt;- emodnet_get_layers(\n  wfs = wfs,\n  layers = infrastructure_layers,\n  crs = 3035,\n  cql_filter = bbox_filter,\n  outputFormat = \"application/json\"\n)\n\n\nnames(infra_sf_list)\n#&gt; [1] \"platforms\"        \"pipelines\"        \"pcablesbshcontis\" \"pcablesshom\"     \n#&gt; [5] \"pcablesrijks\"     \"pcablesnve\"\n\n\nmap_int(infra_sf_list, nrow)\n#&gt;        platforms        pipelines pcablesbshcontis      pcablesshom \n#&gt;             1212             3258               69                4 \n#&gt;     pcablesrijks       pcablesnve \n#&gt;               37              317\n\nAs with the protected areas, we apply the Irish Sea exclusion filter to keep our visualisations focused on the North Sea:\n\ninfra_sf_list &lt;- map(infra_sf_list, \\(x) {\n  st_filter(x, irish_sea_bbox, .predicate = st_disjoint)\n})\n\nmap_int(infra_sf_list, nrow)\n#&gt;        platforms        pipelines pcablesbshcontis      pcablesshom \n#&gt;             1177             3187               69                4 \n#&gt;     pcablesrijks       pcablesnve \n#&gt;               37              317\n\n\n\nUnderstanding Geometry Types\nUnlike protected areas (polygons), infrastructure features have different geometry types:\n\nmap(infra_sf_list, \\(x) unique(st_geometry_type(x)))\n#&gt; $platforms\n#&gt; [1] POINT\n#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n#&gt; \n#&gt; $pipelines\n#&gt; [1] MULTILINESTRING\n#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n#&gt; \n#&gt; $pcablesbshcontis\n#&gt; [1] MULTILINESTRING\n#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n#&gt; \n#&gt; $pcablesshom\n#&gt; [1] MULTILINESTRING\n#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n#&gt; \n#&gt; $pcablesrijks\n#&gt; [1] MULTILINESTRING\n#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n#&gt; \n#&gt; $pcablesnve\n#&gt; [1] MULTILINESTRING\n#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n\nThe output shows MULTILINESTRING and MULTIPOINT rather than simple LINESTRING and POINT. The “MULTI” variants can store multiple disconnected parts in a single feature. For example, a pipeline route that has a gap, or a platform complex with several separate structures recorded as one feature.\nIn practice, sf spatial operations handle both variants identically: st_intersects() works the same whether you have LINESTRING or MULTILINESTRING geometries. The distinction matters mainly when you need to count or iterate over individual line segments.\nFor our analysis:\n\nPlatforms are points (locations of oil, gas, or wind installations)\nPipelines are lines (connecting infrastructure)\nCables are lines (power transmission and interconnectors)\n\nThis matters because spatial operations behave differently with different geometry types. Intersecting a polygon with a line returns different results than intersecting two polygons.\n\n\nQuick Visualisation\nLet’s preview the infrastructure with ggplot2:\n\n# Combine all cable layers\ncables_preview &lt;- bind_rows(\n  infra_sf_list$pcablesbshcontis,\n  infra_sf_list$pcablesshom,\n  infra_sf_list$pcablesrijks,\n  infra_sf_list$pcablesnve\n)\n\nggplot() +\n  geom_sf(data = europe, fill = \"gray90\", colour = \"gray70\") +\n  geom_sf(\n    data = cables_preview,\n    aes(colour = \"Cables\"),\n    linewidth = 0.3,\n    alpha = 0.5,\n    key_glyph = \"path\"\n  ) +\n  geom_sf(\n    data = infra_sf_list$pipelines,\n    aes(colour = \"Pipelines\"),\n    linewidth = 0.5,\n    key_glyph = \"path\"\n  ) +\n  geom_sf(\n    data = infra_sf_list$platforms,\n    aes(colour = \"Platforms\"),\n    size = 0.5,\n    key_glyph = \"point\"\n  ) +\n  scale_colour_manual(\n    values = c(\n      \"Cables\" = \"purple\",\n      \"Pipelines\" = \"orange\",\n      \"Platforms\" = \"red\"\n    ),\n    name = NULL\n  ) +\n  coord_sf(\n    xlim = c(bbox_ext[\"xmin\"], bbox_ext[\"xmax\"]),\n    ylim = c(bbox_ext[\"ymin\"], bbox_ext[\"ymax\"])\n  ) +\n  labs(title = \"Energy Infrastructure\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\nFigure 3: Energy infrastructure in the North Sea"
  },
  {
    "objectID": "tutorials/tutorial-01.html#preparing-for-spatial-analysis",
    "href": "tutorials/tutorial-01.html#preparing-for-spatial-analysis",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Preparing for Spatial Analysis",
    "text": "Preparing for Spatial Analysis\nBefore we can test for intersections between protected areas and infrastructure, we need to prepare both datasets. This involves three steps:\n\nVerify CRS alignment: all layers must share the same coordinate reference system\nValidate geometries: fix any invalid geometries that could cause errors\nOrganise data structures: combine MPA layers into a single dataset; group infrastructure by type\n\n\nChecking CRS Alignment\nAll layers should share the same coordinate reference system. Let’s verify both protected areas and infrastructure:\n\n# Check CRS of protected areas\npurrr::map_chr(mpa_sf_list, \\(x) st_crs(x)[[\"input\"]])\n#&gt;            cddaareas      natura2000areas marineprotectedareas \n#&gt;          \"EPSG:3035\"          \"EPSG:3035\"          \"EPSG:3035\"\n\n# Check CRS of infrastructure\npurrr::map_chr(infra_sf_list, \\(x) st_crs(x)[[\"input\"]])\n#&gt;        platforms        pipelines pcablesbshcontis      pcablesshom \n#&gt;      \"EPSG:3035\"      \"EPSG:3035\"      \"EPSG:3035\"      \"EPSG:3035\" \n#&gt;     pcablesrijks       pcablesnve \n#&gt;      \"EPSG:3035\"      \"EPSG:3035\"\n\nSince we specified crs = 3035 when downloading, all layers are in ETRS89-LAEA with metric units. This projected CRS is ideal for spatial analysis as it avoids the complexities of spherical geometry calculations.\n\n\nValidating Geometries\nSpatial data from web services occasionally contains invalid geometries (self-intersections, duplicate points, etc.) that can cause errors in spatial operations. Let’s check and fix both datasets:\n\nProtected areas\n\n# Check for invalid geometries\nmap_int(mpa_sf_list, \\(x) sum(!st_is_valid(x)))\n#&gt;            cddaareas      natura2000areas marineprotectedareas \n#&gt;                    1                    1                    1\n\n\n# Fix any invalid geometries\nmpa_sf_list &lt;- map(mpa_sf_list, st_make_valid)\n\n\n\nInfrastructure\n\nmap_int(infra_sf_list, \\(x) sum(!st_is_valid(x)))\n#&gt;        platforms        pipelines pcablesbshcontis      pcablesshom \n#&gt;                0                0                0                0 \n#&gt;     pcablesrijks       pcablesnve \n#&gt;                0                0\n\n\ninfra_sf_list &lt;- map(infra_sf_list, st_make_valid)\n\n\n\n\nOrganising Data Structures\nNow we need to organise our data for analysis. The protected areas and infrastructure require different approaches:\n\nProtected areas: We’ll combine the three MPA layers into a single dataset. Our analysis question is “which protected areas intersect with infrastructure?” We want to test all MPAs together, while preserving a type column to distinguish their source. This requires standardising column names across layers.\nInfrastructure: We’ll keep pipelines, cables, and platforms as separate objects. Mixing different geometry types (points and lines) in a single sf object is awkward for both analysis and plotting, so it’s more practical to keep them separate.\n\n\nCombining protected area layers\nThe three MPA layers have different column names. For example, site names are stored as sitename in two layers but name in the third:\n\nmap(mpa_sf_list, names)\n#&gt; $cddaareas\n#&gt; [1] \"id\"         \"country\"    \"sitename\"   \"designated\" \"majorecosy\"\n#&gt; [6] \"geometry\"  \n#&gt; \n#&gt; $natura2000areas\n#&gt; [1] \"id\"        \"sitename\"  \"country\"   \"sitedesc\"  \"directive\" \"mar_perc\" \n#&gt; [7] \"geometry\" \n#&gt; \n#&gt; $marineprotectedareas\n#&gt; [1] \"id\"         \"rsc\"        \"name\"       \"country\"    \"designatio\"\n#&gt; [6] \"status\"     \"geometry\"\n\nTo combine them with bind_rows(), we need to standardise these first. We’ll use the schema we defined in Planning Our Data Schema, where the from field maps source column names to our target names (e.g., name → sitename).\nHere’s a helper function that applies these transformations:\n\nstandardise_sf &lt;- function(data, schema = NULL) {\n  if (is.null(schema)) {\n    return(data)\n  }\n\n  # Type conversion map using readr-style shorthand\n  type_map &lt;- list(\n    c = as.character,\n    i = as.integer,\n    d = as.double,\n    l = as.logical,\n    D = as.Date,\n    T = as.POSIXct\n  )\n\n  # Build rename vector: target_name = source_name\n  # If 'from' not specified, use the target name (no rename)\n  rename_vec &lt;- map_chr(names(schema), ~ schema[[.x]]$from %||% .x)\n  names(rename_vec) &lt;- names(schema)\n\n  # Get type for each column, defaulting to \"c\" (character)\n  get_type &lt;- function(col) type_map[[schema[[col]]$type %||% \"c\"]]\n\n  data |&gt;\n    select(any_of(rename_vec)) |&gt;\n    mutate(across(any_of(names(schema)), \\(x) get_type(cur_column())(x)))\n}\n\nNow we apply the schema to each layer, add a type label to track the source, and combine:\n\n# Standardise each layer and combine with type labels\ntype_labels &lt;- c(\n  cddaareas = \"CDDA\",\n  natura2000areas = \"Natura 2000\",\n  marineprotectedareas = \"MPA\"\n)\n\nmpa_combined &lt;- imap(\n  mpa_sf_list,\n  \\(x, y) {\n    standardise_sf(x, mpa_schemas[[y]]$cols) |&gt;\n      mutate(type = type_labels[[y]])\n  }\n) |&gt;\n  bind_rows()\nrownames(mpa_combined) &lt;- NULL\n\nmpa_combined\n\n\n  \n\n\n\n\n\nOrganising infrastructure layers\nWe reorganise infra_sf_list (named by WFS layer) into a new list organised by infrastructure type, consolidating the four cable sources:\n\ninfra_by_type &lt;- list(\n  pipelines = infra_sf_list$pipelines,\n  cables = bind_rows(infra_sf_list[startsWith(\n    names(infra_sf_list),\n    \"pcables\"\n  )]),\n  platforms = infra_sf_list$platforms\n)\n\nmap_int(infra_by_type, nrow)\n#&gt; pipelines    cables platforms \n#&gt;      3187       427      1177"
  },
  {
    "objectID": "tutorials/tutorial-01.html#spatial-intersection-analysis",
    "href": "tutorials/tutorial-01.html#spatial-intersection-analysis",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Spatial Intersection Analysis",
    "text": "Spatial Intersection Analysis\nNow we’re ready for the core analysis: identifying which protected areas are affected by subsea infrastructure.\n\nUnderstanding Spatial Predicates\nThe sf package provides several functions for testing spatial relationships:\n\n\n\n\n\n\n\n\nFunction\nReturns\nUse case\n\n\n\n\nst_intersects()\nSparse index list\nWhich features touch or overlap?\n\n\nst_intersection()\nNew geometries\nWhat is the actual overlapping area?\n\n\nst_within()\nSparse index list\nWhich features are completely inside?\n\n\nst_contains()\nSparse index list\nWhich features completely contain others?\n\n\n\nFor our analysis, we’ll use st_intersects() to find protected areas that have any spatial overlap with infrastructure, even if a pipeline just crosses through.\n\n\n\n\n\n\nNotest_intersects() vs st_intersection()\n\n\n\n\n\n\nst_intersects() is a predicate: it tests whether geometries touch/overlap and returns a logical result. It’s fast because it doesn’t compute new geometries.\nst_intersection() is an operation: it computes and returns the actual overlapping geometry. It’s slower but gives you the precise overlap area.\n\nFor identifying which features are affected, use st_intersects(). For calculating how much area is affected, use st_intersection().\n\n\n\n\n\n\n\n\n\nTipBenefits of using a projected CRS\n\n\n\nBy requesting data in EPSG:3035, we avoid the complexities of spherical geometry. The sf package uses planar geometry operations (via GEOS) for projected coordinate systems, which are faster and more tolerant of minor geometry issues than the s2 spherical geometry library used for geographic CRS like WGS84.\n\n\n\n\nUnderstanding st_intersects() Output\nst_intersects(x, y) returns a sparse geometry binary predicate list (sgbp). Each list element corresponds to a feature in x and contains the row indices of features in y that it intersects:\n\n# Create 3 circular polygons at different positions\n# st_point() creates a point, st_buffer() expands it into a circle\ndemo_features &lt;- st_sfc(\n  st_buffer(st_point(c(0, 0)), 1),\n  st_buffer(st_point(c(3, 0)), 1),\n  st_buffer(st_point(c(5, 0)), 1)\n)\n\n# Create a region to check for intersection (overlaps features 2 and 3)\ndemo_check_area &lt;- st_buffer(st_point(c(4, 0)), 2) |&gt; st_sfc()\n\n# Which features intersect the check area?\nresult &lt;- st_intersects(demo_features, demo_check_area)\nresult\n#&gt; Sparse geometry binary predicate list of length 3, where the predicate\n#&gt; was `intersects'\n#&gt;  1: (empty)\n#&gt;  2: 1\n#&gt;  3: 1\n\n\n\n\n\n\n\nTipVisualise intersections\n\n\n\n\n\n\n\nCode\nggplot() +\n  geom_sf(\n    data = st_sf(geometry = demo_check_area),\n    fill = \"red\", alpha = 0.2, color = \"red\", linetype = \"dashed\", linewidth = 1\n  ) +\n  geom_sf(\n    data = st_sf(\n      id = factor(1:3),\n      intersects = lengths(st_intersects(demo_features, demo_check_area)) &gt; 0,\n      geometry = demo_features\n    ),\n    aes(fill = intersects), alpha = 0.5, color = \"black\"\n  ) +\n  geom_sf_text(\n    data = st_sf(id = 1:3, geometry = demo_features),\n    aes(label = id), size = 5\n  ) +\n  scale_fill_manual(\n    values = c(\"TRUE\" = \"green\", \"FALSE\" = \"grey70\"),\n    labels = c(\"TRUE\" = \"Yes\", \"FALSE\" = \"No\"),\n    name = \"Intersects?\"\n  ) +\n  theme_minimal() +\n  theme(axis.text = element_blank(), axis.title = element_blank())\n\n\n\n\n\n\n\n\nFigure 4: Features 2 and 3 (green) intersect the check area (dashed red), while feature 1 does not.\n\n\n\n\n\n\n\n\nTo use this for filtering or flagging, we convert to a logical vector using lengths() &gt; 0, which is TRUE for features that intersect with at least one feature in the other dataset:\n\n# Convert to counts, then to logical\nlengths(result)\n#&gt; [1] 0 1 1\nlengths(result) &gt; 0\n#&gt; [1] FALSE  TRUE  TRUE\n\nThis lengths(st_intersects(...)) &gt; 0 pattern is the standard way to create logical flags from spatial intersection tests.\n\n\nComputing Intersections\nRather than testing each infrastructure type separately, we map st_intersects() over infra_by_type. For each infrastructure type, st_intersects() returns a sparse list with one entry per MPA (in the same row order as mpa_combined), and lengths() &gt; 0 converts this to a logical vector. Since the row order is preserved, we can use bind_cols() to combine these into a data frame of intersection flags. We also add an any column that’s TRUE if a protected area intersects with any infrastructure type:\n\n# Compute intersection flags for each infrastructure type\nintersections &lt;- map(\n  infra_by_type,\n  \\(x) lengths(st_intersects(mpa_combined, x)) &gt; 0\n) |&gt;\n  bind_cols() |&gt;\n  mutate(any = pipelines | cables | platforms)\n\n# Combine with MPA attributes (without geometry for efficient summaries)\nmpa_analysis &lt;- mpa_combined |&gt;\n  st_drop_geometry() |&gt;\n  bind_cols(intersections)\n\nmpa_analysis\n\n\n  \n\n\n\nThis gives us a tidy data frame where each row is a protected area and each column indicates whether it intersects with that infrastructure type. Now we can use standard dplyr operations to summarise."
  },
  {
    "objectID": "tutorials/tutorial-01.html#summary-and-visualisation",
    "href": "tutorials/tutorial-01.html#summary-and-visualisation",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Summary and Visualisation",
    "text": "Summary and Visualisation\n\nSummary Table\nLet’s create a summary table breaking down the results by protected area type:\n\nsummary_table &lt;- mpa_analysis |&gt;\n  group_by(type) |&gt;\n  summarise(\n    `Total MPAs` = n(),\n    `With Pipelines` = sum(pipelines),\n    `With Cables` = sum(cables),\n    `With Platforms` = sum(platforms),\n    `With Any Infrastructure` = sum(any),\n    .groups = \"drop\"\n  ) |&gt;\n  mutate(\n    `% Affected` = round(100 * `With Any Infrastructure` / `Total MPAs`, 1)\n  )\n\nknitr::kable(summary_table)\n\n\n\nTable 1: Protected areas intersecting with subsea infrastructure in the North Sea\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntype\nTotal MPAs\nWith Pipelines\nWith Cables\nWith Platforms\nWith Any Infrastructure\n% Affected\n\n\n\n\nCDDA\n358\n20\n35\n12\n41\n11.5\n\n\nMPA\n156\n33\n20\n20\n50\n32.1\n\n\nNatura 2000\n56\n17\n19\n11\n26\n46.4\n\n\n\n\n\n\n\n\n\n\nPreparing Geometries for Visualisation\nTo visualise the results, we need to combine the intersection flags with the MPA geometries. We also simplify the geometries because marine protected area boundaries often contain highly detailed coastlines with thousands of vertices, which slows down plotting.\nWe temporarily disable s2 (spherical geometry) because st_simplify() uses the GEOS library, which expects planar coordinates. Since our data is already in a projected CRS (EPSG:3035), this is safe:\n\n# Add intersection flags to MPA geometries and simplify\nsf_use_s2(FALSE)\n\nmpa_simple &lt;- mpa_combined |&gt;\n  bind_cols(intersections) |&gt;\n  st_simplify(dTolerance = 2000, preserveTopology = TRUE)\n\nsf_use_s2(TRUE)\n\nThe dTolerance parameter specifies the simplification tolerance in CRS units. Since we’re using EPSG:3035 (metric), dTolerance = 2000 means 2 km, imperceptible at our map scale but dramatically faster to render.\n\n# Compare object sizes as proxy for complexity reduction\noriginal_size &lt;- object.size(mpa_combined)\nsimplified_size &lt;- object.size(mpa_simple)\n\nsprintf(\n  \"Object size reduced from %s to %s (%.0f%% reduction)\",\n  format(original_size, units = \"MB\"),\n  format(simplified_size, units = \"MB\"),\n  100 * (1 - as.numeric(simplified_size) / as.numeric(original_size))\n)\n#&gt; [1] \"Object size reduced from 73.9 Mb to 5.2 Mb (93% reduction)\"\n\n\n\n\n\n\n\nNote\n\n\n\nAlways perform spatial analysis on the original geometries, then simplify for visualisation. Simplifying before analysis can introduce errors in intersection tests.\n\n\n\n\nVisualising the Results\n\nMap of All Protected Areas\nFirst, let’s create a base map showing all protected areas, coloured by whether they intersect with infrastructure. Compare with Figure 2 which showed the three MPA types before analysis:\n\nggplot() +\n  geom_sf(data = europe, fill = \"gray95\", colour = \"gray70\") +\n  geom_sf(\n    data = mpa_simple,\n    aes(fill = any, colour = any),\n    linewidth = 0.1,\n    alpha = 0.3\n  ) +\n  scale_fill_manual(\n    values = c(\"FALSE\" = \"lightgreen\", \"TRUE\" = \"coral\"),\n    labels = c(\"No intersection\", \"Intersects infrastructure\"),\n    name = NULL\n  ) +\n  scale_colour_manual(\n    values = c(\"FALSE\" = \"lightgreen\", \"TRUE\" = \"coral\"),\n    guide = \"none\"\n  ) +\n  coord_sf(\n    xlim = c(bbox_ext[\"xmin\"], bbox_ext[\"xmax\"]),\n    ylim = c(bbox_ext[\"ymin\"], bbox_ext[\"ymax\"])\n  ) +\n  labs(\n    title = \"Protected Areas and Infrastructure Overlap\",\n    subtitle = \"North Sea region\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\nFigure 5: Protected areas in the North Sea coloured by infrastructure intersection status\n\n\n\n\n\n\n\nMap with Infrastructure Overlay\nNow let’s add the infrastructure layers to see the spatial pattern:\n\nggplot() +\n  # Basemap\n  geom_sf(data = europe, fill = \"gray95\", colour = \"gray70\") +\n  # Protected areas\n  geom_sf(\n    data = mpa_simple,\n    aes(fill = any),\n    colour = \"gray50\",\n    linewidth = 0.1,\n    alpha = 0.3\n  ) +\n  # Cables\n  geom_sf(\n    data = infra_by_type$cables,\n    aes(colour = \"Cables\"),\n    linewidth = 0.3,\n    alpha = 0.5,\n    key_glyph = \"path\"\n  ) +\n  # Pipelines\n  geom_sf(\n    data = infra_by_type$pipelines,\n    aes(colour = \"Pipelines\"),\n    linewidth = 0.5,\n    key_glyph = \"path\"\n  ) +\n  # Platforms\n  geom_sf(\n    data = infra_by_type$platforms,\n    aes(colour = \"Platforms\"),\n    size = 2,\n    key_glyph = \"point\"\n  ) +\n  scale_fill_manual(\n    values = c(\"FALSE\" = \"lightgreen\", \"TRUE\" = \"coral\"),\n    labels = c(\"No intersection\", \"Intersects infrastructure\"),\n    name = \"Protected Area Status\"\n  ) +\n  scale_colour_manual(\n    values = c(\n      \"Cables\" = \"purple\",\n      \"Pipelines\" = \"orange\",\n      \"Platforms\" = \"red\"\n    ),\n    name = \"Infrastructure\"\n  ) +\n  coord_sf(\n    xlim = c(bbox_ext[\"xmin\"], bbox_ext[\"xmax\"]),\n    ylim = c(bbox_ext[\"ymin\"], bbox_ext[\"ymax\"])\n  ) +\n  labs(\n    title = \"Marine Protected Areas and Subsea Infrastructure\",\n    subtitle = \"North Sea region\",\n    caption = \"Data: EMODnet Human Activities\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\") +\n  guides(\n    fill = guide_legend(order = 1),\n    colour = guide_legend(order = 2)\n  )\n\n\n\n\n\n\n\nFigure 6: Protected areas with subsea infrastructure overlay\n\n\n\n\n\n\n\nInteractive Exploration\nFor a more detailed exploration, let’s create an interactive map with tmap. Setting tmap_mode(\"view\") switches from static plots to interactive Leaflet maps:\n\ntmap_mode(\"view\")\n\ntm_shape(mpa_simple) +\n  tm_polygons(\n    fill = \"any\",\n    fill.scale = tm_scale_categorical(values = c(\"lightgreen\", \"coral\")),\n    fill.legend = tm_legend(title = \"Intersects Infrastructure\"),\n    fill_alpha = 0.3,\n    col = \"any\",\n    col.scale = tm_scale_categorical(values = c(\"lightgreen\", \"coral\")),\n    col.legend = tm_legend(show = FALSE),\n    lwd = 0.5,\n    popup.vars = c(\n      \"sitename\",\n      \"type\",\n      \"pipelines\",\n      \"cables\",\n      \"platforms\"\n    )\n  ) +\n  tm_shape(infra_by_type$pipelines) +\n  tm_lines(col = \"orange\", lwd = 2, popup.vars = TRUE) +\n  tm_add_legend(type = \"lines\", col = \"orange\", lwd = 2, labels = \"Pipelines\") +\n  tm_shape(infra_by_type$cables) +\n  tm_lines(col = \"purple\", lwd = 1, col_alpha = 0.5) +\n  tm_add_legend(type = \"lines\", col = \"purple\", lwd = 1, labels = \"Cables\") +\n  tm_shape(infra_by_type$platforms) +\n  tm_symbols(fill = \"red\", size = 0.05, popup.vars = TRUE) +\n  tm_add_legend(\n    type = \"symbols\",\n    fill = \"red\",\n    size = 0.3,\n    labels = \"Platforms\"\n  )"
  },
  {
    "objectID": "tutorials/tutorial-01.html#interpretation-and-conclusion",
    "href": "tutorials/tutorial-01.html#interpretation-and-conclusion",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Interpretation and Conclusion",
    "text": "Interpretation and Conclusion\n\nKey Findings\nThis analysis identified protected areas in the North Sea that spatially overlap with subsea infrastructure. Of the 570 protected areas examined:\n\n117 (21%) intersect with at least one type of energy infrastructure\nNatura 2000 sites are most affected: 46% intersect with infrastructure, compared to 32% of other MPAs and 12% of CDDA sites\nCables are the most common intersection: 74 protected areas intersect with power cables, compared to 70 with pipelines and 43 with platforms\n\n\n\nInterpreting the Patterns\nThe higher intersection rate for Natura 2000 sites likely reflects their typically larger size and offshore extent. These sites often cover broad areas of seabed habitat like sandbanks (e.g., Dogger Bank), which are also attractive corridors for infrastructure routing. CDDA sites, with the lowest intersection rate, include many smaller coastal reserves where infrastructure is less prevalent.\nThe prominence of cable intersections reflects the rapid expansion of offshore wind and cross-border power interconnectors in the North Sea. Unlike legacy oil and gas infrastructure (pipelines, platforms), cable networks are actively growing as part of Europe’s energy transition.\nThese patterns raise questions for further investigation:\n\nSize effects: Do larger MPAs have higher intersection rates simply due to their greater spatial extent?\nCoastal vs offshore: Are offshore MPAs disproportionately affected compared to coastal sites?\nGeographic clustering: Are intersections concentrated in particular areas (e.g., the southern North Sea wind development zone)?\nTemporal trends: How has infrastructure-MPA overlap changed over time, and what does planned infrastructure imply for future conflicts?\n\n\n\nEcological and Policy Implications\nThese findings are relevant for:\n\nMarine spatial planning: Understanding existing infrastructure-conservation conflicts helps inform future planning decisions\nEnvironmental impact assessment: Identifying where infrastructure crosses protected areas can prioritise monitoring efforts\nPolicy compliance: Supports assessment of whether activities within protected areas align with conservation objectives under the Habitats Directive and Marine Strategy Framework Directive\n\n\n\nLimitations and Caveats\nThis analysis has several limitations to consider:\n\nSpatial intersection ≠ impact: A pipeline crossing a protected area doesn’t necessarily cause ecological harm. Actual impacts depend on factors including burial depth, operational status, and habitat sensitivity\nData currency: EMODnet data is regularly updated but may not reflect the most recent infrastructure installations or MPA designations\nGeometric simplification: We tested only for intersection; a more detailed analysis might calculate the length of pipeline within each MPA or buffer distances around platforms\nMissing infrastructure: Some infrastructure (e.g., certain cable routes) may not be fully represented in the available datasets\n\n\n\nNext Steps\nTo extend this analysis, you could:\n\nCalculate the length of pipelines/cables within each protected area using st_intersection()\nAdd buffer zones around platforms to assess potential impact areas\nJoin with habitat classification data to identify which habitat types are most affected\nIncorporate temporal data to track how overlap has changed over time\n\n\n\nWhat You’ve Learned\nIn this tutorial, you learned how to:\n\nExplore EMODnet WFS services to discover available data\nDownload vector data with spatial filters for efficient queries\nPrepare and validate spatial data for analysis\nApply spatial intersection techniques to identify overlapping features\nVisualise results using both static (ggplot2) and interactive (tmap) maps\n\nThese skills form the foundation for marine spatial analysis and can be applied to many other research questions involving EMODnet data."
  },
  {
    "objectID": "tutorials/tutorial-01.html#further-resources",
    "href": "tutorials/tutorial-01.html#further-resources",
    "title": "1: Protected Areas and Subsea Infrastructure",
    "section": "Further Resources",
    "text": "Further Resources\n\nEMODnet Seabed Habitats Portal: Explore more protected area and habitat data\nEMODnet Human Activities Portal: Access additional infrastructure datasets\nemodnet.wfs package documentation: Full function reference\nsf package vignettes: Deep dive into spatial operations\nGeocomputation with R: Comprehensive spatial analysis guide\n\nReady for more? Continue to Tutorial 2 to learn about accessing raster data with EMODnet WCS services."
  },
  {
    "objectID": "tutorials/tutorial-03.html",
    "href": "tutorials/tutorial-03.html",
    "title": "3: Biodiversity Change and Depth",
    "section": "",
    "text": "This tutorial is currently under development.\n\n\n\nUsing emdn_get_features() to access spatiotemporal diversity metrics from EMODnet Biology (WFS)\nUsing emdn_get_coverage() to retrieve raster bathymetry from EMODnet Bathymetry (WCS)\nPerforming spatial joins and point-based extraction from raster datasets\nVisualising and summarising patterns of species gain/loss across depth gradients\n\n\n\n\nWFS (vector): - Layer ID: all_diversity_measures - Source: EMODnet Biology - Key variables: Species loss, species gain, β-diversity, time periods\nWCS (raster): - Layer ID: emodnet__mean_2020 - Source: EMODnet Bathymetry - Description: Mean depth (m), regularly gridded\n\n\n\nNorth Sea\nBounding box (WGS84): xmin = 1.5, ymin = 53, xmax = 6.5, ymax = 58\nCheck back soon for the complete tutorial!"
  },
  {
    "objectID": "tutorials/tutorial-03.html#tutorial-content",
    "href": "tutorials/tutorial-03.html#tutorial-content",
    "title": "3: Biodiversity Change and Depth",
    "section": "",
    "text": "This tutorial is currently under development.\n\n\n\nUsing emdn_get_features() to access spatiotemporal diversity metrics from EMODnet Biology (WFS)\nUsing emdn_get_coverage() to retrieve raster bathymetry from EMODnet Bathymetry (WCS)\nPerforming spatial joins and point-based extraction from raster datasets\nVisualising and summarising patterns of species gain/loss across depth gradients\n\n\n\n\nWFS (vector): - Layer ID: all_diversity_measures - Source: EMODnet Biology - Key variables: Species loss, species gain, β-diversity, time periods\nWCS (raster): - Layer ID: emodnet__mean_2020 - Source: EMODnet Bathymetry - Description: Mean depth (m), regularly gridded\n\n\n\nNorth Sea\nBounding box (WGS84): xmin = 1.5, ymin = 53, xmax = 6.5, ymax = 58\nCheck back soon for the complete tutorial!"
  }
]